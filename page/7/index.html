<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>hex55</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="hex55">
<meta property="og:url" content="http://hex55.com/page/7/index.html">
<meta property="og:site_name" content="hex55">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="hex55">
  
    <link rel="alternative" href="/atom.xml" title="hex55" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: false,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img src="/img/head.jpg" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/">shawge</a></h1>
        </hgroup>

        
        <p class="header-subtitle">shawge的电子技术分享</p>
        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">博客首页</a></li>
                        
                            <li><a href="/categories/MCU-ARM/">MCU/ARM</a></li>
                        
                            <li><a href="/categories/FPGA/">FPGA</a></li>
                        
                            <li><a href="/categories/windows-linux/">WINDOWS/LINUX</a></li>
                        
                            <li><a href="/categories/硬件设计/">硬件设计</a></li>
                        
                            <li><a href="/archives/">归档</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=27O_o_7um6qq9bi0tg" title="mail">mail</a>
                            
                                <a class="fl github" target="_blank" href="https://github.com/hex55" title="github">github</a>
                            
                                <a class="fl rss" target="_blank" href="/atom.xml" title="rss">rss</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/github-提速/" style="font-size: 10px;">github 提速</a>
                    </div>
                </section>
                
                
                

                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">没想好。。。</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">shawge</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img src="/img/head.jpg" class="js-avatar" style="width: 100%; height: 100%; opacity: 1;">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">shawge</a></h1>
            </hgroup>
            
            <p class="header-subtitle">shawge的电子技术分享</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">博客首页</a></li>
                
                    <li><a href="/categories/MCU-ARM/">MCU/ARM</a></li>
                
                    <li><a href="/categories/FPGA/">FPGA</a></li>
                
                    <li><a href="/categories/windows-linux/">WINDOWS/LINUX</a></li>
                
                    <li><a href="/categories/硬件设计/">硬件设计</a></li>
                
                    <li><a href="/archives/">归档</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=27O_o_7um6qq9bi0tg" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/hex55" title="github">github</a>
                    
                        <a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-e8-a7-a3-e5-86-b3-top-overlay-silk-primitive-on-board-region-without-silkscreen" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/11/e8-a7-a3-e5-86-b3-top-overlay-silk-primitive-on-board-region-without-silkscreen/" class="article-date">
      <time datetime="2015-08-11T11:37:04.000Z" itemprop="datePublished">2015-08-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/11/e8-a7-a3-e5-86-b3-top-overlay-silk-primitive-on-board-region-without-silkscreen/">解决 Top Overlay Silk primitive on board region without silkscreen</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Altium designer PCB运行DRC时提示以下错误：</p>
<blockquote>
<p>[Silk To Board Region Clearance Violation]    Motherboard.PcbDoc  Advanced PCB    Silk To Board Region Clearance: (Out of silkscreen region) Text “Cap” (4405.501mil,-158.5mil)  Top Overlay Silk primitive on board region without silkscreen    13:55:13    2015/8/10   53</p>
</blockquote>
<hr>
<p><strong>PS更新：最近又遇到这个问题，发现下文所述重新导入的方法比较麻烦，细细理会这个警告才知原来下文的解决方法没有找到根本原因。</strong></p>
<blockquote>
<p>Class  Document    Source  Message Time    Date    No.<br>  [Silk To Board Region Clearance Violation]  ccd_1209.PcbDoc Advanced PCB    Silk To Board Region Clearance: (Out of silkscreen region) Text “Header 25X2” (2.07mm,-1.079mm)  Top Overlay Silk primitive on board region without silkscreen  21:19:42    2015/10/10  3</p>
</blockquote>
<p>请注意警告中提到”Header 25X2”文本丝印在板框外，而我的图中根本只能看到一个白圈圈，</p>
<p><a href="/uploads/2015/08/2015-10-10_212918.png"><img src="/uploads/2015/08/2015-10-10_212918-300x230.png" alt="2015-10-10_212918"></a></p>
<p>说明这年文本可能是被隐藏了，细想这个”Header 25X2”是元件的注释，右键点击属性让其显示</p>
<p><a href="/uploads/2015/08/2015-10-10_213015.png"><img src="/uploads/2015/08/2015-10-10_213015-252x300.png" alt="2015-10-10_213015"></a></p>
<p><a href="/uploads/2015/08/2015-10-10_213055.png"><img src="/uploads/2015/08/2015-10-10_213055-258x300.png" alt="2015-10-10_213055"></a></p>
<p>这下可以看见这个玩意了，我们将个”Header 25X2”字符串拖到板子上，然后进行DRC检查发现没有警告了，最后为了美观我们让其不显示即可。</p>
<p><a href="/uploads/2015/08/2015-10-10_213333.png"><img src="/uploads/2015/08/2015-10-10_213333-300x131.png" alt="2015-10-10_213333"></a></p>
<p><strong>以下作废</strong></p>
<hr>
<p>找了半天也没找着问题，我原先以为是下面这个元理图库中勾选了这个选项的原因：</p>
<p><a href="/uploads/2015/08/2015-08-10_135850.png"><img src="/uploads/2015/08/2015-08-10_135850-300x265.png" alt="2015-08-10_135850"></a></p>
<p>并且我的丝印并未在PCB之外，它即也提示这种错误，在它的白色提示圈中说什么“out of silkscreen region”，可是里面什么玩意也没有。</p>
<p><a href="/uploads/2015/08/2015-08-10_140556.png"><img src="/uploads/2015/08/2015-08-10_140556-300x270.png" alt="2015-08-10_140556"></a></p>
<p><a href="/uploads/2015/08/2015-08-10_140638.png"><img src="/uploads/2015/08/2015-08-10_140638-300x83.png" alt="2015-08-10_140638"></a></p>
<p>后来终于发现是PCB库的原因，PCB的参考点没有设置在1号引脚上。</p>
<p><a href="/uploads/2015/08/2015-08-10_140030.png"><img src="/uploads/2015/08/2015-08-10_140030-300x281.png" alt="2015-08-10_140030"></a></p>
<p>将其参考点修改为1号脚，即如下：</p>
<p><a href="/uploads/2015/08/2015-08-10_140332.png"><img src="/uploads/2015/08/2015-08-10_140332-300x241.png" alt="2015-08-10_140332"></a></p>
<hr>
<p><strong>PS: 上面这个解决办法并未找到问题的实质，实际上只需要删掉PCB中的原件，并再次导入即可，可能是由于本人拖动过整个PCB，导致了一些问题。但是根据提示比较难找到问题元件，好在可以在提示附近内逐一排除。</strong></p>
<p>当你拖动一个可疑元件时，它的白色错误提示也会跟着移动，那么说明你找到了它。下面就是我的板中所有可疑元件，尽管他们原本丝印并未在板框之外，但它们仍然有错误提示，所以我找到它们并将他们干掉，然后重新导入（没办法既然改造不了那就让他们重新轮回，^-^）。</p>
<p><a href="/uploads/2015/08/2015-08-10_155252.png"><img src="/uploads/2015/08/2015-08-10_155252-300x139.png" alt="2015-08-10_155252"></a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/硬件设计/">硬件设计</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e9-ab-98-e9-80-9f-e7-ba-bf-e9-98-b5ccd-e7-ba-a2-e5-a4-96-e6-b5-8b-e5-be-84-e4-bb-aapcb-e6-9c-80-e7-bb-88-e7-89-88" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/10/e9-ab-98-e9-80-9f-e7-ba-bf-e9-98-b5ccd-e7-ba-a2-e5-a4-96-e6-b5-8b-e5-be-84-e4-bb-aapcb-e6-9c-80-e7-bb-88-e7-89-88/" class="article-date">
      <time datetime="2015-08-10T12:45:21.000Z" itemprop="datePublished">2015-08-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/10/e9-ab-98-e9-80-9f-e7-ba-bf-e9-98-b5ccd-e7-ba-a2-e5-a4-96-e6-b5-8b-e5-be-84-e4-bb-aapcb-e6-9c-80-e7-bb-88-e7-89-88/">高速线阵CCD红外测径仪PCB最终版</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>终于做完了，发出去打板，哈哈。</p>
<p><a href="/uploads/2015/08/2015-08-10_164313.png"><img src="/uploads/2015/08/2015-08-10_164313-300x199.png" alt="高速红外测径仪主板PCB"></a></p>
<p><a href="/uploads/2015/08/2015-08-10_164436.png"><img src="/uploads/2015/08/2015-08-10_164436-300x199.png" alt="高速红外测径仪CCD转板PCB"></a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/FPGA/">FPGA</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e4-b8-80-e7-a7-8d-e6-94-b9-e8-bf-9b-e5-9e-8b-e7-9a-84-e8-b6-85-e4-bd-8e-e6-88-90-e6-9c-ac-e5-92-8c-e5-bc-a6-e9-9f-b3-e8-9c-82-e9-b8-a3-e5-99-a8-e4-ba-a7-e7-94-9f-e7-94-b5-e8-b7-af" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/10/e4-b8-80-e7-a7-8d-e6-94-b9-e8-bf-9b-e5-9e-8b-e7-9a-84-e8-b6-85-e4-bd-8e-e6-88-90-e6-9c-ac-e5-92-8c-e5-bc-a6-e9-9f-b3-e8-9c-82-e9-b8-a3-e5-99-a8-e4-ba-a7-e7-94-9f-e7-94-b5-e8-b7-af/" class="article-date">
      <time datetime="2015-08-10T00:20:02.000Z" itemprop="datePublished">2015-08-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/10/e4-b8-80-e7-a7-8d-e6-94-b9-e8-bf-9b-e5-9e-8b-e7-9a-84-e8-b6-85-e4-bd-8e-e6-88-90-e6-9c-ac-e5-92-8c-e5-bc-a6-e9-9f-b3-e8-9c-82-e9-b8-a3-e5-99-a8-e4-ba-a7-e7-94-9f-e7-94-b5-e8-b7-af/">一种改进型的超低成本和弦音蜂鸣器产生电路</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <hr>
<p>上次介绍了一个用无源蜂鸣器产生和弦音的电路<a href="http://www.hex55.com/2015/08/09/%E4%B8%80%E7%A7%8D%E4%BD%8E%E6%88%90%E6%9C%AC%E9%9F%B3%E6%95%88%E4%B8%B0%E5%AF%8C%E7%9A%84%E5%92%8C%E5%BC%A6%E9%9F%B3%E8%9C%82%E9%B8%A3%E5%99%A8%E4%BA%A7%E7%94%9F%E7%94%B5%E8%B7%AF%E5%8F%8A%E5%85%B6/" target="_blank" rel="external">《一种低成本音效丰富的和弦音蜂鸣器产生电路及其驱动代码》</a>，这一次我又从某处见到另一电路，据说这是某一国内知名厂商申请的专利，这个电路的元器件更少更省成本，话说这个消费电子领域的成本竞争真是短兵相接，拼刺刀见血啊！</p>
<p><strong>改进型原理图</strong></p>
<p>这个图很明显，bz_hz引脚用PWM波驱动，bz_switch引脚用于控制回音时间。</p>
<p><img src="/uploads/2015/08/2015-08-07_085549.png" alt="和弦音蜂鸣器改进低成本版原理图"></p>
<p><strong>旧版原理图</strong></p>
<p><img src="/uploads/2015/08/2015-08-07_200358.png" alt="和弦音蜂鸣器原理图"></p>
<p>小伙伴们可以按下述时序图，用MCU的定时器或者FPGA/CPLD驱动来听听效果吧。</p>
<p><strong>音效时序图</strong></p>
<p><img src="/uploads/2015/08/2015-08-07_085937.png" alt="和弦音蜂鸣器乐谱1"></p>
<p><img src="/uploads/2015/08/2015-08-07_090003.png" alt="和弦音蜂鸣器乐谱2"></p>
<p><img src="/uploads/2015/08/2015-08-07_090042.png" alt="和弦音蜂鸣器乐谱3"></p>
<p><img src="/uploads/2015/08/2015-08-07_090107.png" alt="和弦音蜂鸣器乐谱4"></p>
<p><img src="/uploads/2015/08/2015-08-07_090128.png" alt="和弦音蜂鸣器乐谱5"></p>
<p><img src="/uploads/2015/08/2015-08-07_090146.png" alt="和弦音蜂鸣器乐谱6"></p>
<p><img src="/uploads/2015/08/2015-08-07_090225.png" alt="和弦音蜂鸣器乐谱7"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/硬件设计/">硬件设计</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e4-b8-80-e7-a7-8d-e4-bd-8e-e6-88-90-e6-9c-ac-e9-9f-b3-e6-95-88-e4-b8-b0-e5-af-8c-e7-9a-84-e5-92-8c-e5-bc-a6-e9-9f-b3-e8-9c-82-e9-b8-a3-e5-99-a8-e4-ba-a7-e7-94-9f-e7-94-b5-e8-b7-af-e5-8f-8a-e5-85-b6" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/09/e4-b8-80-e7-a7-8d-e4-bd-8e-e6-88-90-e6-9c-ac-e9-9f-b3-e6-95-88-e4-b8-b0-e5-af-8c-e7-9a-84-e5-92-8c-e5-bc-a6-e9-9f-b3-e8-9c-82-e9-b8-a3-e5-99-a8-e4-ba-a7-e7-94-9f-e7-94-b5-e8-b7-af-e5-8f-8a-e5-85-b6/" class="article-date">
      <time datetime="2015-08-09T12:17:59.000Z" itemprop="datePublished">2015-08-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/09/e4-b8-80-e7-a7-8d-e4-bd-8e-e6-88-90-e6-9c-ac-e9-9f-b3-e6-95-88-e4-b8-b0-e5-af-8c-e7-9a-84-e5-92-8c-e5-bc-a6-e9-9f-b3-e8-9c-82-e9-b8-a3-e5-99-a8-e4-ba-a7-e7-94-9f-e7-94-b5-e8-b7-af-e5-8f-8a-e5-85-b6/">一种低成本音效丰富的和弦音蜂鸣器产生电路及其驱动代码</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <hr>
<p><strong>原理图</strong></p>
<p><img src="/uploads/2015/08/2015-08-07_200358.png" alt="和弦音蜂鸣器原理图"></p>
<p>说明： 三极管集电极R94下面那个脚用于PWM波驱动，R65那个脚用于控制回音时间。</p>
<p><strong>源代码</strong></p>
<p>一段烂代码，抄的别人的，项目紧我也懒得去改，大伙凑合着看，实在看不下去自行改写或实现也很容易，等我优化完软件定时器模块就把这段代码扔掉。</p>
<pre><code>typedef struct{
    uint8_t ring_times;     //响铃次数
    uint8_t ring_time_set;  //设置的升调时间
    uint8_t stop_time_set;  //设置降调时间
    uint8_t task_count;     //执行状态
    uint8_t ring_time;      //当前升调时间
    uint8_t stop_time;      //当前降调时间

}buzzer_uion;
buzzer_uion buzzer;

void initBuzzer(void)
{
    buzzer.ring_time = 0;
    buzzer.ring_time_set = 0;
    buzzer.stop_time_set = 0;
    buzzer.task_count = 0;
    buzzer.ring_time = 0;
    buzzer.ring_time = 0;
    buzzer.stop_time = 0;
}

//===========================================================
//  dlyctr = dlyctr | 0x80 ;        //----- buzzer output on 
//  dlyctr = dlyctr &amp;amp; 0x7f ;        //----- buzzer output on 
//===========================================================
void  buz_set(uint8_t loop,uint8_t delay_H,uint8_t delay_L)
{
    buzzer.ring_times=loop;
    buzzer.ring_time_set=delay_H;
    buzzer.stop_time_set=delay_L;
    buzzer.task_count=0;
}

//----------------------------------------------
void buz_task(void)
{
    if(buzzer.ring_times!=0)
    {
        if(getTimer(1).cntMs%2)
            return;

        if(buzzer.task_count==0)
        {
            buzzer.ring_time=buzzer.ring_time_set;
            ++buzzer.task_count;
        } 
        else if(buzzer.task_count==1) //由低到高
        {
            //BUZZER_ON;
            DLYCTR |= 0x80;//|= ((uint8_t)0x01&amp;lt;&amp;lt;7); //开启PWM
            //speaker_set;
            aftersound_set;
            if(--buzzer.ring_time==0) 
                ++buzzer.task_count;
        }
        else if(buzzer.task_count==2) 
        {
            buzzer.stop_time=buzzer.stop_time_set;
            ++buzzer.task_count;
        } 
        else if(buzzer.task_count==3) //由高到低
        {
            //BUZZER_OFF;
            //speaker_clr;
            aftersound_clr;

            if(--buzzer.stop_time==0)   //结束条件判断
            {
                DLYCTR &amp;amp;= 0x7f;//&amp;amp;= ~((uint8_t)0x01&amp;lt;&amp;lt;7); //关闭PWM
                if(buzzer.ring_times!=0xff)         //-----=0xff时报警
                    --buzzer.ring_times;
                buzzer.task_count=0;
            }
        }
    }
    else 
    {
        aftersound_clr;
        speaker_clr;
        DLYCTR &amp;amp;= 0x7f;//&amp;amp;= ~((uint8_t)0x01&amp;lt;&amp;lt;7); //关闭PWM
    }       
}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/硬件设计/">硬件设计</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e3-80-8a-e7-96-af-e7-8b-82-e7-9a-84-e6-8a-95-e8-b5-84-e8-b7-a8-e8-b6-8a-e5-a4-a7-e8-a5-bf-e6-b4-8b-e7-94-b5-e7-bc-86-e7-9a-84-e5-95-86-e4-b8-9a-e4-bc-a0-e5-a5-87-e3-80-8b-e8-af-bb" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/07/e3-80-8a-e7-96-af-e7-8b-82-e7-9a-84-e6-8a-95-e8-b5-84-e8-b7-a8-e8-b6-8a-e5-a4-a7-e8-a5-bf-e6-b4-8b-e7-94-b5-e7-bc-86-e7-9a-84-e5-95-86-e4-b8-9a-e4-bc-a0-e5-a5-87-e3-80-8b-e8-af-bb/" class="article-date">
      <time datetime="2015-08-07T12:34:22.000Z" itemprop="datePublished">2015-08-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/07/e3-80-8a-e7-96-af-e7-8b-82-e7-9a-84-e6-8a-95-e8-b5-84-e8-b7-a8-e8-b6-8a-e5-a4-a7-e8-a5-bf-e6-b4-8b-e7-94-b5-e7-bc-86-e7-9a-84-e5-95-86-e4-b8-9a-e4-bc-a0-e5-a5-87-e3-80-8b-e8-af-bb/">《疯狂的投资——跨越大西洋电缆的商业传奇》读书笔记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>记得是前年（对，是前年，去年春晚微信抢红包才火起来）春节微信红包抢到一百多块钱，一直放那没管，后来用“蜻蜓FM” APP听《罗辑思维》与这本书有关的一期，突然记起来微信红包可以直接在它公共帐号里面买书。正好那段时间我自己也在创业（当然后来的后来无果而终），这书有提神之用，然后就买了。再然后翻了翻，跟所有的西方传记一样，我根本搞不清里面的人物名称，就懒得看下去。比如该书的主人翁赛勒斯*菲尔德（直到后来把这本书读完我也没能记住他的全名，直到写这篇读书笔记我重新翻书印证了一下）他有好几个兄弟，从他的祖辈讲起，书中至少出现六七个菲尔德（西方的家族式精英比较泛行，作者介绍A人物的时候发现A的兄弟姐妹都很优秀，不得不也作一下介绍，或者是穿插在书中作为旁白）。</p>
<p><a href="/uploads/2015/08/2015-08-07-13.29.53-e1438927379340.jpg"><img src="/uploads/2015/08/2015-08-07-13.29.53-e1438927379340-225x300.jpg" alt="2015-08-07 13.29.53"></a></p>
<p>后来在现在这家公司住宿舍，每天中午闲着没事把这本书翻完了，离买这本书已过去了大半年，说实话这本书我觉得写得不怎么样，《罗辑思维》吹得厉害。但是我确实喜欢书中的主人翁，而这本书中最让我记忆深刻是这一段：</p>
<blockquote>
<p>某个投资人问菲尔德，“如果这次电缆铺设失败了怎么办？”。菲尔德不加思索地说了一句,“计算损益，然后再铺一条！”</p>
</blockquote>
<p>从这一点足可以看出菲尔德的乐观精神，他的乐观在整个长达十几年，多达四五次失败的电缆铺设工程中起到了定海神针的作用。你也可以理解为他是个不知深浅的愣头青，但无论怎样用毛爷爷的观点来看革命乐观主义精神必不可少。可能也正是这种不计风险的乐观冒险精神导致主人翁在晚年的多项大工程投资中失败，也正是这种电缆铺设的经历让他喜欢投资修筑大坝、铁路、高速公路这种高风险高回报的项目。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/闲言碎语/">闲言碎语</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-fpga-e3-80-81cpld-e6-9e-b6-e6-9e-84-e7-9a-84-e9-80-9f-e5-ba-a6-e4-bc-98-e5-8c-96" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/07/fpga-e3-80-81cpld-e6-9e-b6-e6-9e-84-e7-9a-84-e9-80-9f-e5-ba-a6-e4-bc-98-e5-8c-96/" class="article-date">
      <time datetime="2015-08-07T00:24:41.000Z" itemprop="datePublished">2015-08-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/07/fpga-e3-80-81cpld-e6-9e-b6-e6-9e-84-e7-9a-84-e9-80-9f-e5-ba-a6-e4-bc-98-e5-8c-96/">FPGA、CPLD架构的速度优化</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>原文：《Advanced FPGA Design Architecture, Implementation, and Optimization》, Architecting Speed</p>
<p>作者：Steve Kilts</p>
<p>译者：shawge</p>
<hr>
<p>对于大多数设计，如果编码风格太过随意，工具常常不足以让设计符合约束。本章主要讨论数字设计中的三大物理特性中的第一点：速度。本章也将讨论FPGA的架构优化方法。</p>
<p>速度有以下三种主要的定义：吞吐量，延迟，时序。在FPGA数据处理中，吞吐量是指每个时钟周期处理的数据量。通常用比特每秒（bits per second）来量化。延迟是指从数据输入到数据输出所需要的时间。常用时间或者是时钟数来量化。时序是指串行元件之间的延时。当我们说一个设计不符合时序时，这意味着关键路么的延时，即寄存器之间的最大延时（由组合逻辑延时，输出延时，布线延时，建立时序，时钟倾斜等等组成）比目标时钟周期更大。典型的量化单位是时钟周期和频率。</p>
<p>本章我们将详细讨论以下几点:</p>
<ul>
<li>高吞吐量，最大化对该设计每秒能够处理的比特数。</li>
<li>延迟，最小化模块从输入到输出有效的时间。</li>
<li><p>时序优化，降低关键路径的组合延时。</p>
<p>在组合逻辑中添加寄存器层。<br>将无关联的串行执行结构并行化。<br>展平具有优先级的逻辑结构。<br>通过重新分配流水线周围的组合逻辑实现寄存器平衡。<br>通过路径重排序将关键路径中的一些操作转移到非关键路径中。</p><p></p>
</li>
</ul>
<hr>
<h2 id="1-1-高吞吐量"><a href="#1-1-高吞吐量" class="headerlink" title="1.1 高吞吐量"></a>1.1 高吞吐量</h2><p></p><p>一个高吞吐量的设计主要关注稳定的数据速率，而较少关注具体数据片通过设计的传输时间（延时）。高吞吐量的设计思想与福特所想到的通过装配线来实现大量汽车生产的想法是一致的。在数据处理的数字设计世界里，我们往往用一个更抽象的词汇：流水线。</p>
<p>流水线的设计概念作品非常类似于装配线，原料或者数据从前端输入，然后通过各个阶断的操作和处理，最后生成产品或者数据输出。流水线的妙处在于前面数据处理完前新的数据已经在被处理，非常像汽车在装置线上被处理的过程。流水线在几乎所有的高性能设备中被采用，而与具体形式无关。例如CPU指令集，网络协议栈，加密引擎等等。</p>
<p>从算法角度看，流水线的一个重要理念就是展开循环。例如下面这个代码段常常用来在软件中实现X的三次乘方处理。注意，与这段代码相关的软件是在一个微处理器中通过指令执行的。</p>
<pre><code>XPower = 1;
for (i=0;i &amp;lt; 3; i++)
    XPower = X * XPower;
`&lt;/pre&gt;

注意，以上的代码是一个迭代处理。同样的变量和地址被访问直到计算完成。因为微处理器一次只能执行一条指令（为便于讨论，只考虑单核处理器）所以在这里没有使用并行。在硬件上可以创建一个类似的实现。看看以下的verilog代码，它完成同上面相同的算法（不考虑输出范围）:

&lt;pre&gt;`module power3(
output [7:0] XPower,
output finished,
input [7:0] X,
input clk, start); // the duration of start is a
single clock
reg [7:0] ncount;
reg [7:0] XPower;
assign finished = (ncount == 0);
always@(posedge clk)
    if(start) begin
        XPower &amp;lt;= X;
        ncount &amp;lt;= 2;
    end
    else if(!finished) begin
        ncount &amp;lt;= ncount - 1;
        XPower &amp;lt;= XPower * X;
    end
endmodule
`&lt;/pre&gt;

在上面这个例子中，同样的寄存器和计算资源被使用直到整个计算完成,如图1.1。

![](
</code></pre><p>/uploads/2015/07/2015-07-03_141054.png)</p>
<pre><code>在这种类型的迭代计实现中，直到前一个计算完成才能有新的计算开始。这个迭代原理非常类似软件实现。还要注意到，需要某些握手信号去指示计算的开始和完成。一个外部模块也需要用一个握手信号去给这个模块传递数据和接收计算结果。这个实现的性能如下：

吞吐量 = 8/3, 或 2.7bit/clock

延迟 = 3 clock

时序 = 关键路径上的一个乘法器延时

对比相同算法的流水线版本：

&lt;pre&gt;`module power3(
    output reg [7:0] XPower,
    input clk,
    input [7:0] X
    );
    reg [7:0] XPower1, XPower2;
    reg [7:0] X1, X2;

    always @(posedge clk) begin
        // Pipeline stage 1
        X1 &amp;lt;= X;
        XPower1 &amp;lt;= X;
        // Pipeline stage 2
        X2 &amp;lt;= X1;
        XPower2 &amp;lt;= XPower1 * X1;
        // Pipeline stage 3
        XPower &amp;lt;= XPower2 * X2;
    end
endmodule

`&lt;/pre&gt;

在上面这个实现中，X的值被送到两个流水阶段，分别采用独立的资源去计算乘法。注意，当X被用来在第二个流水线阶段去计算最终的3次乘方时，下一个X的值已能被送往第一个流水阶段，如图1.2。

![](
</code></pre><p>/uploads/2015/07/2015-07-03_134305.png)</p>
<pre><code>计算2次方和计算三次方的过程同时执行。这个设计性能如下：

吞吐量 = 8/1， 或 8 bits/clock

延时 = 3 clocks

时序 = 关键路径上的一个乘法器延时

吞吐量性能相比于迭代方式实现提高了三倍。一般来讲，如果一个算法有n次迭代循不环被展开，流水线实现将会让吞吐量提高n倍。在延时方面则没有什么优劣，因为流水线实现仍然需要3个时钟来填充流水线。同样，在时序方面也没什么优劣，仍然只有一个乘法器延时。

**展开迭代循环将增加吞吐量。**

展开循环所带来的代价是增加了面积。迭代实现只需要一个寄存器和一个乘法器（还伴随一些没有在框图中展示的控制逻辑），而流水线实现则要求为X和XPower分别提供独立的寄存器，并且每个流水阶段都要一个乘法器。面积的优化将在第2章中讨论。

**展开迭代循环，面积将成比例增加**

## 1.2 低延时

低延时设计是让数据从输入到输出尽可能快地通过，通过最小化中间处理延时。通常一个低延时设计将会要求并行，移除流水线，还有会降低设计吞吐量和最大时钟速度的逻辑捷径。

回顾一下求三次方的例子，显然不能对迭代作任何延时优化，因为为了下一个操作每一个相继的乘法操作都需要被寄存。但是，流水现实现却有一个清晰的降低延时的方法。注意到在每一个流水阶段，每个乘法器的结果都必须等到下一个时钟沿才能传递给下一级。移除流水寄存器，就能最小化输入输出时序：

&lt;pre&gt;`
module power3(
    output [7:0] XPower,
    input [7:0] X
    );
    reg [7:0] XPower1, XPower2;
    reg [7:0] X1, X2;
    assign XPower = XPower2 * X2;

    always @* begin
        X1 = X;
        XPower1 = X;
    end

    always @* begin
        X2 = X1;
        XPower2 = XPower1*X1;
    end
endmodule

`&lt;/pre&gt;

在上面这个例子中，寄存器被从流水中线剥离出来。每个阶段都是前一个阶段的组合表达式，如图1.3

![](
</code></pre><p>/uploads/2015/07/2015-07-03_150325.png)</p>
<pre><code>设计性能如下：

吞吐量 = 8 bits/clock(假定每个时钟只输入一个新数据)

延时 = 一到两个乘法器的延时，0 clocks

时序 = 关键路径上的两个乘法器延时

通过移除流水线寄存器，我们将这个设计的延时降低到了一个时钟周期。

**移除流水线寄存器能够降低延时**

在时序方面的劣势显而易见，原先的实现理论上能够让系统的时钟周期接近一个乘法器的延时，但是在低延时实中中，时钟周期必须至少是两个乘法器延时（取决于具体实现）加上在关键路径上的任何逻辑延时。

**移除流水线寄存器的劣势是增加了寄存器之间的组合延时**

## 1.3 时序

时序是指一个设计时钟速度。在设计中的任何两个串行元件间的最大延时决定了最大时钟速度。理想的时钟速度是比较简单的抽象，速度/面积平衡我们将在别处讨论，本章只是考虑一般的时钟速度，与这些拓扑结构无直接关系，虽然这些架构的取舍肯定会对时序产生影响。例如在不知道具体实现细节的情况下，没有人敢肯定地说流水线实现就一定比迭代实现更快。最大的速度，或最大频率，由下面这个公认的简单最大频率方程定义（不考虑时钟抖动）:

![](
</code></pre><p>/uploads/2015/07/2015-07-03_153327.png)</p>
<pre><code>式中F&amp;#95;max是所允许的最大时钟频率；T&amp;#95;clk-q是从时钟抵达到数据抵达Q（译者注：触发器输出延时）； T&amp;#95;logic是触发器之间的逻辑传播延时；T&amp;#95;rounging是触发器之间的布线延时;T&amp;#95;setup是在下一时钟沿到来前数据必须抵达的最小时间(建立时间)；T&amp;#95;skew是发射触发器和捕获触发器之间的时钟传捕延时（译者注：时钟倾斜）。

下一节描述提高时序性能的各种方法及取舍之道。

### 1.3.1 添加寄存器层

第一个提高时序性能的策略是在关键路径上增加寄存器。这一技术应该在流水线设计中被高度应用，前提是增加额外的延迟不会违反设计要求，并且总体功能也不受进一步增中的寄存器影响。

举个例子，假定如下的FIR（有限脉冲响应滤波器）实现不符合时序：

&lt;pre&gt;`module fir(
    output [7:0] Y,
    input [7:0] A, B, C, X, 
    input clk,
    input validsample);

reg [7:0] X1, X2, Y;

always @(posedge clk)
    if(validsample) begin
        X1 &amp;lt;= X;
        X2 &amp;lt;= x1;
        Y1 &amp;lt;= A * X + B * X1 + C * X2;
    end

endmodule
`&lt;/pre&gt;

在结构上，所有乘/加运算发生在一个时钟周期如图所示1.4。

![](
</code></pre><p>/uploads/2015/07/2015-07-03_160903.png)</p>
<pre><code>换句话说，关键路径上的一个乘法器和一个加法器的延时比所要求的最小时钟周期大。假定不要求延时是固定的一个时钟，我们就能够通过在乘法器后添加寄存器来让设计流水线化。第一步比较简单: 只要在乘法器和加法器之间添加流水层即可:

&lt;pre&gt;`module fir(
    output [7:0] Y,
    input [7:0] A, B, C, X,
    input clk,
    input validsample);
    reg [7:0] X1, X2, Y;
    reg [7:0] prod1, prod2, prod3;

    always @ (posedge clk) begin
    if(validsample) begin
        X1 &amp;lt;= X;
        X2 &amp;lt;= X1;
        prod1 &amp;lt;= A * X;
        prod2 &amp;lt;= B * X1;
        prod3 &amp;lt;= C * X2;
        end
        Y &amp;lt;= prod1 + prod2 + prod3;
    end
endmodule
`&lt;/pre&gt;

在上面这个例子中，乘法器被流水线隔离了，如图1.5。

![](
</code></pre><p>/uploads/2015/07/2015-07-03_161232.png)</p>
<pre><code>乘法器是很好的流水化候选，因为计算很容易被分阶段完成。通过独立寄存化把乘法和加法分段进行。

**通过添加寄存器层将关键路径分解成两个较小延时的路径来提升时序**

这种功能的各种实现涵盖在其他章节，但是一旦架构被分段，更多的流水线就像上面的例子一样简单。

### 1.3.2 并行化

第二个提升架构时序的策略是重组关键路径，使得逻辑结构能并行实现。当一个功能当前以可被分解的串行逻辑进行评估时，可以应用这一技术进行并行评估。举个例子，假如在前一节中讨论过的求三次方的标准流水实现不符合时序要求。为了创建并行结构，我们能够将乘法器分割成独立的操作，然后重组它们。例如，一个8-bit的二进制乘法器可以通过半字A和B表示：

X = {A, B}，

式中A是高半字，B是低半字。

由于在求三次方的例子中被乘法等于乘数，所以乘法操作能够如下重组：

X &amp;#42; X = {A，B} &amp;#42; {A, B} = {(A &amp;#42; A), (2 &amp;#42; A &amp;#42; B), (B &amp;#42; B)};

这将我们的问题降低成了一串4-bit乘法器，然后重组他们的结果。实现如下模块：

&lt;pre&gt;`module power3(
    output [7:0] XPower,
    input [7:0] X,
    input clk);
    reg [7:0] XPower1;
    // partial product registers
    reg [3:0] XPower2_ppAA, XPower2_ppAB, XPower2_ppBB;
    reg [3:0] XPower3_ppAA, XPower3_ppAB, XPower3_ppBB;
    reg [7:0] X1, X2;
    wire [7:0] XPower2;
    // nibbles for partial products (A is MS nibble, B is LS
    nibble)
    wire [3:0] XPower1_A = XPower1[7:4];
    wire [3:0] XPower1_B = XPower1[3:0];
    wire [3:0] X1_A = X1[7:4];
    wire [3:0] X1_B = X1[3:0];
    wire [3:0] XPower2_A = XPower2[7:4];
    wire [3:0] XPower2_B = XPower2[3:0];
    wire [3:0] X2_A = X2[7:4];
    wire [3:0] X2_B = X2[3:0];
    // assemble partial products
    assign XPower2 = (XPower2_ppAA &amp;lt;&amp;lt; 8)+
        (2*XPower2_ppAB &amp;lt;&amp;lt; 4)+
        XPower2_ppBB;
    assign XPower = (XPower3_ppAA &amp;lt;&amp;lt; 8)+
        (2*XPower3_ppAB &amp;lt;&amp;lt; 4)+
        XPower3_ppBB;
    always @(posedge clk) begin
        // Pipeline stage 1
        X1 &amp;lt;= X;
        XPower1 &amp;lt;= X;
        // Pipeline stage 2
        X2 &amp;lt;= X1;
        // create partial products
        XPower2_ppAA &amp;lt;= XPower1_A * X1_A;
        XPower2_ppAB &amp;lt;= XPower1_A * X1_B;
        XPower2_ppBB &amp;lt;= XPower1_B * X1_B;
        // Pipeline stage 3
        // create partial products
        XPower3_ppAA &amp;lt;= XPower2_A * X2_A;
        XPower3_ppAB &amp;lt;= XPower2_A * X2_B;
        XPower3_ppBB &amp;lt;= XPower2_B * X2_B;
    end
endmodule

`&lt;/pre&gt;

这个设计没有考虑溢出，但是它说明了本节的要点。如图1.6，乘法器被分割成能被独立操作的较小模块。

![](
</code></pre><p>/uploads/2015/07/2015-07-03_170158.png)</p>
<pre><code>通过将乘法操作分割成能并行执行的较小操作，最大延时降低为所有子结构的最长延时。

**将功能分离为多个能并行执的较小功能，能够将路径延时降低为所有子结构的最长延时**

### 1.3.3 展平逻辑结构

第三个去提升时序性能的策略是展平逻辑结构。这与上一节结构并行化的定义非常类似，但是特别适用于具有优先级逻辑链的结构。通常，综合和布线工具足以智能地去复制逻辑以减少扇出，但是它们的智能还不足以打破被串行编码的逻辑结构，它们也没有与设计优先级要求相关的信息。举个例子，如下的信号来自一个地址编码器，它们被用于去写四个寄存器：

&lt;pre&gt;`module regwrite(
    output reg [3:0] rout,
    input clk, in,
    input [3:0] ctrl);
    always @(posedge clk)
        if(ctrl[0]) rout[0] &amp;lt;= in;
        else if(ctrl[1]) rout[1] &amp;lt;= in;
        else if(ctrl[2]) rout[2] &amp;lt;= in;
        else if(ctrl[3]) rout[3] &amp;lt;= in;
endmodule
`&lt;/pre&gt;

在上面这个例子中，每个信号被编码成与其它信号有优先关系。这种优先级编码的实现结构如图1.7。

![](
</code></pre><p>/uploads/2015/07/2015-07-03_172111.png)</p>
<pre><code>如果控制线是被另一个模块中的地址解码器译码，那么每一个编码是与其它编码互斥平等的，因为它们代表唯一地址。然而如果按我们这种编码来它就是有优先级的。由于信号是控制信号，上面的代码的操作就像它是被并行编码，但是综合工具不足以智能到注意到这一点，特别是如果地址译码器是在其它寄存器层的后面。

移除优先级，展平逻辑后的模块代码如下：

&lt;pre&gt;`module regwrite(
    output reg [3:0] rout,
    input clk, in,
    input [3:0] ctrl);
    always @(posedge clk) begin
        if(ctrl[0]) rout[0] &amp;lt;= in;
        if(ctrl[1]) rout[1] &amp;lt;= in;
        if(ctrl[2]) rout[2] &amp;lt;= in;
        if(ctrl[3]) rout[3] &amp;lt;= in;
    end
endmodule
`&lt;/pre&gt;

如图1.8，可以看到门级实现没有任何优先级逻辑。每一个控制信号独立地控制了输出位。

![](
</code></pre><p>/uploads/2015/07/2015-07-03_174140.png)</p>
<pre><code>**通过移除没有必要的优先级编码，逻辑结构可以被展平，并且路径延时将会降低。**

### 1.3.4 寄存器平衡

第四策略叫寄存器平衡。从概念上讲，这个想法是均匀的重新分配寄存器之间的逻辑，以达到最小化两个寄存器之间的最坏延时。当关键路径和相邻路径之间的逻辑高度不平衡时可以使用这个技术。因为时钟速度只取决于最差路径，可能只需要一个小小的改变就能成功地重新平衡关键逻辑。

很多综合工具也有一个叫作寄存器平衡的选项。这个功能主要是以预定的方式识别特定的结构并重新放置该结构周围的寄存器。这对常见的结构如大乘法器是有用的，但是它的功能有限，并且它不会改变你的逻辑，也不能识别自定义结构。依赖该技术，则可能需要更为昂贵的综合工具去实现。因此理解这个概念是非常重要的，并且必须具备重新分配自定义结构逻辑的能力。

看看下面的代码，它是一个有三个8-bit输入的加法器:

&lt;pre&gt;`module adder(
    output reg [7:0] Sum,
    input [7:0] A, B, C,
    input clk);
    reg [7:0] rA, rB, rC;
    always @(posedge clk) begin
        rA &amp;lt;= A;
        rB &amp;lt;= B;
        rC &amp;lt;= C;
        Sum &amp;lt;= rA + rB + rC;
    end
endmodule
`&lt;/pre&gt;

第一个寄存器段包括rA， rB 和 rC，第二段包括Sum。在第一段和第二段之间的逻辑是用于所有输入的加法器，在输入和第一寄存器段之间不包含任何逻辑（假定这个模块的输出反馈是寄存器化的）如图1.9。

![](
</code></pre><p>/uploads/2015/07/2015-07-03_180133.png)</p>
<pre><code>如果关键路径被定义为加法器，一些关键路径上的逻辑可以被移回一段，从而实现两个寄存器段之间的逻辑平衡。参见如下的修正，一个加法操作被移回了一段:

&lt;pre&gt;`module adder(
    output reg [7:0] Sum,
    input [7:0] A, B, C,
    input clk);
    reg [7:0] rABSum, rC;
    always @(posedge clk) begin
        rABSum &amp;lt;= A + B;
        rC &amp;lt;= C;
        Sum &amp;lt;= rABSum + rC;
    end
endmodule
`&lt;/pre&gt;

现在，我们把一个加法器回移到了输入和第一寄存器段之间。这平衡了流水线，并且减少关键路径，如图1.10。

**寄存器平衡能够提升时序性能，通过将关键路径上的组合逻辑移到相邻路径来实现**

![](
</code></pre><p>/uploads/2015/07/2015-07-03_180934.png)</p>
<pre><code>### 1.3.5 路径重排

第五个策略是重排数据路径，以最小化关键路径。当有多个由关键路径组成的路径，并且这些组合路径可以被重排，使得关键路径能被移至离目的寄存器更近，那么可以使用这一技术。在这个策略中，我们只考虑任何给定寄存器之间逻辑。看看如下模块：

&lt;pre&gt;`
module randomlogic(
    output reg [7:0] Out,
    input [7:0] A, B, C,
    input clk,
    input Cond1, Cond2);

    always @(posedge clk)
    if(Cond1)
        Out &amp;lt;= A;
    else if(Cond2 &amp;amp;&amp;amp; (C &amp;lt; 8))
        Out &amp;lt;= B;
    else
        Out &amp;lt;= C;
endmodule

`&lt;/pre&gt;

![](
</code></pre><p>/uploads/2015/07/2015-07-03_184854.png)</p>
<pre><code>在这个例子中，我们假定C和输出之间是关键路径，在抵达目的选择器前它包含一个比较器以及串联着的两个门电路。如图1.11。假定条件并不互斥，我们可以修改代码重排长延时的比较器:

&lt;pre&gt;`
module randomlogic(
    output reg [7:0] Out,
    input [7:0] A, B, C,
    input clk,
    input Cond1, Cond2);
    wire CondB = (Cond2 &amp;amp; !Cond1);

    always @(posedge clk)
    if(CondB &amp;amp;&amp;amp; (C &amp;lt; 8))
        Out &amp;lt;= B;
    else if(Cond1)
        Out &amp;lt;= A;
    else
        Out &amp;lt;= C;
endmodule
</code></pre><p>经过重组代码，我们把一个门电路移到了与比较器串联着的关键路径之外，如图1.12。因此，通过仔细查看有无特定结构的代码，我们能够直接影响时序性能。</p>
<p><img src="/uploads/2015/07/2015-07-03_185649.png" alt=""></p>
<p><strong>时序性能可以被提高，通过重排序关键路径上的组合逻辑，依靠这种方式能够让关键路径更逼近目标寄存器。</strong></p>
<h2 id="1-4-关键点汇总"><a href="#1-4-关键点汇总" class="headerlink" title="1.4 关键点汇总"></a>1.4 关键点汇总</h2><ul>
<li>高吞吐量架构是指最大化设计每秒能够处理的比特数。</li>
<li>展开迭代循环能够提高吞吐量。</li>
<li>展开迭代循环的代价是增加了资源消耗面积。</li>
<li>低延时架构是指最小化模块从输入到输出所需的时间。</li>
<li>通过移除流水线寄存器可以减小输出延时。</li>
<li>移除流水线寄存器的代价是增加了寄存器之间的组合逻辑延时。</li>
<li>时序是指一个设计的时钟速度。当一个设计的任意两个串行元件之间的最大延时小于最小的时钟周期时，时序收敛。</li>
<li>增加寄存器层可以提升时序，通过打断关键路径，将其分割成到两条较小的延时路径来实现。</li>
<li>将一个逻辑功能分离成若干个可以独立并行执行的能够让路径延时降低为所有子结构的最长延时。</li>
<li>通过移除不必要的优先级编码，逻辑结构被展平，路径延时被减小。</li>
<li>寄存器平衡能够提升时序，通过将关键路径里的组合逻辑移至相邻的路径来实现。</li>
<li>时序可以过重排路径提升，通过重排由关键路径组成的路径，让关键路径更靠近目的寄存器来实现。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/FPGA/">FPGA</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e9-ab-98-e9-80-9f-e7-ba-a2-e5-a4-96-e7-ba-bf-e9-98-b5ccd-e6-b5-8b-e5-be-84-e4-bb-aapcb-e5-ae-8c-e5-b7-a5" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/05/e9-ab-98-e9-80-9f-e7-ba-a2-e5-a4-96-e7-ba-bf-e9-98-b5ccd-e6-b5-8b-e5-be-84-e4-bb-aapcb-e5-ae-8c-e5-b7-a5/" class="article-date">
      <time datetime="2015-08-05T10:53:27.000Z" itemprop="datePublished">2015-08-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/05/e9-ab-98-e9-80-9f-e7-ba-a2-e5-a4-96-e7-ba-bf-e9-98-b5ccd-e6-b5-8b-e5-be-84-e4-bb-aapcb-e5-ae-8c-e5-b7-a5/">高速红外线阵CCD测径仪PCB完工</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>整了两三天基本上终于整完了，明天再润色润色就发出去打板。</p>
<p><a href="/uploads/2015/08/2015-08-05_184838.png"><img src="/uploads/2015/08/2015-08-05_184838-300x213.png" alt="2015-08-05_184838"></a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/硬件设计/">硬件设计</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e6-99-ba-e8-83-bd-e9-a9-ac-e6-a1-b6-e9-a1-b9-e7-9b-ae-e6-80-bb-e7-bb-93" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/05/e6-99-ba-e8-83-bd-e9-a9-ac-e6-a1-b6-e9-a1-b9-e7-9b-ae-e6-80-bb-e7-bb-93/" class="article-date">
      <time datetime="2015-08-05T00:47:04.000Z" itemprop="datePublished">2015-08-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/05/e6-99-ba-e8-83-bd-e9-a9-ac-e6-a1-b6-e9-a1-b9-e7-9b-ae-e6-80-bb-e7-bb-93/">智能马桶项目总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <hr>
<h3 id="常用功能需求"><a href="#常用功能需求" class="headerlink" title="常用功能需求"></a>常用功能需求</h3><p>功能简要说明</p>
<p><img src="/uploads/2015/06/DG600_fun.png" alt=""></p>
<p>按键功能</p>
<p><img src="/uploads/2015/06/DG600_KEY_FUN.png" alt=""></p>
<hr>
<h3 id="硬件分析"><a href="#硬件分析" class="headerlink" title="硬件分析"></a>硬件分析</h3><ul>
<li><strong>电源</strong></li>
</ul>
<p><img src="/uploads/2015/06/DG600_PWR.png" alt=""></p>
<p>典型的单端反激式电源</p>
<p><img src="/uploads/2015/06/DG600_PWR2.png" alt=""></p>
<p>LDO输出12V。</p>
<ul>
<li><strong>加热负载</strong></li>
</ul>
<p>光耦隔离，可控硅开关。<br><img src="/uploads/2015/06/DG600_HEATER.png" alt=""></p>
<ul>
<li><strong>传感器接口</strong></li>
</ul>
<p><img src="/uploads/2015/06/DG600_SENSOR.png" alt=""></p>
<p>电容消抖</p>
<ul>
<li><strong>步进电机驱动</strong></li>
</ul>
<p><img src="/uploads/2015/06/DG600_MOTOR.png" alt=""></p>
<p>UL2803—— 8路大电流达林顿传输阵列</p>
<ul>
<li><strong>复位电路</strong></li>
</ul>
<p><img src="/uploads/2015/06/DG600_RST_Monitors.png" alt=""></p>
<p>电压监控复位电路</p>
<ul>
<li><strong>参数存储电路</strong></li>
</ul>
<p><img src="/uploads/2015/06/DG600_24C02.png" alt=""></p>
<ul>
<li><strong>蜂鸣器电路</strong></li>
</ul>
<p><img src="/uploads/2015/06/DG600_BUZZER.png" alt=""></p>
<p>蜂鸣器为无源蜂鸣器，蜂鸣器一端接PWM，与三极管相连这一端作开关控制，三极管开时蜂鸣器鸣叫，三极管关时蜂鸣器产生回音。</p>
<ul>
<li><strong>水泵和烘干风机PWM调速电路</strong></li>
</ul>
<p><img src="/uploads/2015/06/DG600_MOTOR_PWM.png" alt=""></p>
<ul>
<li><strong>烘干风格异常检测电路</strong></li>
</ul>
<p>用R64对电机的电流进行采样，用ADC读取采样值。</p>
<p><img src="/uploads/2015/06/DG600_FAN_ERR.png" alt=""></p>
<ul>
<li><strong>扶手板电路</strong></li>
</ul>
<p><img src="/uploads/2015/06/DG600_KEY_LED.png" alt=""></p>
<p>TM1628的典型应用</p>
<hr>
<h3 id="软件架构分析"><a href="#软件架构分析" class="headerlink" title="软件架构分析"></a>软件架构分析</h3><ol>
<li><strong>单片机软件的核心是软件架构，而不是各种外设驱动。架构是道，驱动是术。</strong></li>
<li>层次模块划分清晰，避免一杆子插到底和补丁式长城，各层只做份内之事，不越权。</li>
<li>擅用继承，避免冗余。</li>
<li>依赖接口而不是实现，保持抽象的一致性，具体的差异性由实现完成。</li>
<li>拥有最少的（如一个）适合fix bug的位置。</li>
<li>fix 一个 bug,只需要进行最少的修改。</li>
<li>上层不关注下层细节，下层对于上层为黑盒。</li>
<li>……</li>
</ol>
<p>简言之，设计模式六大原则:</p>
<ul>
<li>单一职责原则，即一个类只负责一项职责。</li>
<li>里氏替换原则，当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。</li>
<li>依赖倒置原则，高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</li>
<li>接口隔离原则，建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。</li>
<li>迪米特法则 ——又叫最少知道原则</li>
<li>开闭原则  ——一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</li>
</ul>
<p>详情请参考 <a href="http://www.uml.org.cn/sjms/201211023.asp#4" target="_blank" rel="external">http://www.uml.org.cn/sjms/201211023.asp#4</a></p>
<p>及GOF的 《设计模式》  一书， 及 《UNIX编程艺术》一书。</p>
<hr>
<h3 id="功能难点"><a href="#功能难点" class="headerlink" title="功能难点"></a>功能难点</h3><ol>
<li>按键板切换较为繁琐，功能划分不太合理，学习成本较高。</li>
<li>驱动负载较多，各个负载间依存关系较为复杂，细节较多。例如喷杆与烘干之间关系，喷杆与电磁阀之间的关系，需要考虑避免实际使用时的尴尬。</li>
<li>要注意各种器件的异常及保护，如发热器件。</li>
<li>水温调节中需考虑因素较多，加温模型不易建立，调温参数不易确定：<blockquote>
<ul>
<li>发热丝的功率与水箱大小的因素</li>
<li>水的流入速度：自来水压强，水泵压强</li>
<li>水的流出速度： 喷嘴模式不同，喷嘴口径大小不同</li>
<li>水箱内水温与喷嘴处水温差异</li>
<li>水箱外部气温，季节差异</li>
<li>流入水箱的自来水本身温度差异</li>
</ul>
</blockquote>
</li>
</ol>
<hr>
<h3 id="松下芯片及编译器的坑"><a href="#松下芯片及编译器的坑" class="headerlink" title="松下芯片及编译器的坑"></a>松下芯片及编译器的坑</h3><ol>
<li>main()的形式，不符合标准</li>
<li>enum不符合标准，是以有符号INT实现，避免溢出，应启用最小化生成。</li>
<li>避免发布DEBUG版本代码。</li>
<li>芯片初始化及调试堆栈大小的设置。</li>
<li>注意DF4和DF5初始化代码中断标识差异</li>
<li>PLL输入不支持16M晶振，避免超频。</li>
<li>DF5不支持UCHAR型位域，DF4代码移植需要注意。尽可不能使用bit型，注意对齐。<br>8.</li>
</ol>
<hr>
<h3 id="个人心得总结"><a href="#个人心得总结" class="headerlink" title="个人心得总结"></a>个人心得总结</h3><ol>
<li>细节打动人心，用好心做好产品。</li>
<li>方寸之间有乾坤，技术核心由若干个细节上的技术难点组成。</li>
<li>听取用户建议，但不接受用户指挥，在产品功能上有主见。</li>
<li>在用户体验上逐步追求完成，在技术实现上采取折衷态度，不能为了技术而技术，技术只是手段不是目的。</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/MCU-ARM/">MCU/ARM</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-fpga-e6-93-8d-e4-bd-9c-e5-9b-9b-e7-ba-bf-e5-88-b6spi-flash-ef-bc-88quad-spi-flash-ef-bc-89-ef-bc-883-ef-bc-89" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/04/fpga-e6-93-8d-e4-bd-9c-e5-9b-9b-e7-ba-bf-e5-88-b6spi-flash-ef-bc-88quad-spi-flash-ef-bc-89-ef-bc-883-ef-bc-89/" class="article-date">
      <time datetime="2015-08-04T05:33:30.000Z" itemprop="datePublished">2015-08-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/04/fpga-e6-93-8d-e4-bd-9c-e5-9b-9b-e7-ba-bf-e5-88-b6spi-flash-ef-bc-88quad-spi-flash-ef-bc-89-ef-bc-883-ef-bc-89/">FPGA操作四线制SPI FLASH（Quad SPI Flash） （3）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <hr>
<p><a href="http://www.hex55.com/2015/07/27/fpga%E6%93%8D%E4%BD%9C%E5%9B%9B%E7%BA%BF%E5%88%B6spi-flash%EF%BC%88quad-spi-flash%EF%BC%89-%EF%BC%882%EF%BC%89/" target="_blank" rel="external">FPGA操作四线制SPI FLASH（Quad SPI Flash） （2）</a></p>
<p><a href="http://www.hex55.com/2015/07/26/fpga%E6%93%8D%E4%BD%9C%E5%9B%9B%E7%BA%BF%E5%88%B6spi-flash%EF%BC%88quad-spi-flash%EF%BC%89-%EF%BC%881%EF%BC%89/" target="_blank" rel="external">FPGA操作四线制SPI FLASH（Quad SPI Flash） （1）</a></p>
<p>本文准备以SPANSION公司的S25FL128S 和 S25FL256S的datasheet为例 来说明四线SPI FLASH的操作要点。</p>
<p><img src="/uploads/2015/07/2015-07-10_174542.png" alt=""></p>
<hr>
<h2 id="读存储阵列命令"><a href="#读存储阵列命令" class="headerlink" title="读存储阵列命令"></a>读存储阵列命令</h2><p>读存储阵列命令提供了很多兼容上一代SPI和提升SPI性能的功能：</p>
<ul>
<li>有些命令在每个SCK的上沿传送地址或数据，被称为SDR命令。</li>
<li>有些SDR命令在SCK的上沿传产送每个地址位，并且在每个上沿返位1、2或4位的数据。这些被称作读或者快速读1位数据；双输出读2位数据；四输出读4位数据。</li>
<li>有些SDR命令会在SCK上沿即传送地址也传送2或者4位的数据。这被称作2位双IO和4位四IO。</li>
<li>有些命令会在SCK的上沿和下沿传送地址和数据。这被称为DDR命令。</li>
<li>有DDR命令会在SCK的每个沿传送1、2或4位的地址或数据。这被称作快速的1位DDR，双IO的2位DDR，4IO的四位DDR。</li>
</ul>
<h3 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h3><ul>
<li>03h (ExtAdd = 0 ),跟随3字节地址</li>
<li>03h (ExtAdd = 1 ),跟随4字节地址</li>
<li>13h 跟随4字节地址</li>
</ul>
<p><img src="/uploads/2015/07/2015-07-13_110528.png" alt=""></p>
<p>读命令的最大操作频率是50M，起始地址能够位于存储阵列的任何位置。地址将会自增，数据将会依次移出。将起始地址设为0，可以读出整片内容，当抵达最高地址后地址会再次翻转为0，这样就可以持续不断地读出。</p>
<h3 id="快速读"><a href="#快速读" class="headerlink" title="快速读"></a>快速读</h3><ul>
<li>0Bh (ExtAdd = 0 ),跟随3字节地址</li>
<li>0Bh (ExtAdd = 1 ),跟随4字节地址</li>
<li>0Ch 跟随4字节地址</li>
</ul>
<p><img src="/uploads/2015/07/2015-07-13_112205.png" alt=""></p>
<p>最大操作频率133M，地址跟上面的普通读操作类似。</p>
<h3 id="双输出读"><a href="#双输出读" class="headerlink" title="双输出读"></a>双输出读</h3><ul>
<li>3Bh (ExtAdd = 0 ),跟随3字节地址</li>
<li>3Bh (ExtAdd = 1 ),跟随4字节地址</li>
<li>3Ch 跟随4字节地址</li>
</ul>
<p><img src="/uploads/2015/07/2015-07-13_154819.png" alt=""></p>
<p>最大操作步率104M。</p>
<h3 id="4输出读"><a href="#4输出读" class="headerlink" title="4输出读"></a>4输出读</h3><ul>
<li>6Bh (ExtAdd = 0 ),跟随3字节地址</li>
<li>6Bh (ExtAdd = 1 ),跟随4字节地址</li>
<li>6Ch 跟随4字节地址</li>
</ul>
<p>带空周期的4输出读</p>
<p><img src="/uploads/2015/07/2015-07-13_155121.png" alt=""></p>
<p>不带空周期的4输出读</p>
<p><img src="/uploads/2015/07/2015-07-13_155209.png" alt=""></p>
<p>最大操作频率104M。</p>
<h3 id="双IO读"><a href="#双IO读" class="headerlink" title="双IO读"></a>双IO读</h3><ul>
<li>BBh (ExtAdd = 0 ),跟随3字节地址</li>
<li>BBh (ExtAdd = 1 ),跟随4字节地址</li>
<li>BCh 跟随4字节地址</li>
</ul>
<p>双IO读操作提升了双IO——IO0、IO1的性能。跟双IO输出命令类似，但是它能够在每个上沿输入两位地址。在有些应用中，减小地址输入时间就能允许就地执行代码（XIP）。最大操作频率104M。</p>
<blockquote>
<p>XIP即就地执行的意思，操作系统内核直接在Flash中运行，不需要拷贝到RAM。但是，Flash的存储器访问周期要比RAM大得多，在使用XIP技术后可能会降低程序的运行速度，不过由于CPU的指令预取机制以及Cache机制，实际使用起来并不会明显降低应用程序的运行速度。XIP的原理很简单，即指操作系统或应用程序直接从非易失性存储器中执行。就当前的技术来说，这里的非易失性存储器特指NOR型Flash，因为只有N0R型的Flash才可以随机存取。引用自<a href="http://blog.csdn.net/xzongyuan/article/details/28256443" target="_blank" rel="external">关于Nand Flash和Nor Flash的XIP</a></p>
</blockquote>
<p>对于双向IO读操作，在地址和数据之间有潜伏期。至于选择高性能LC表（HPLC）还是增强性LC表（EHPLC）给该命令取决于器件型号。HPLC不提供模式位周期，因此每个双IO命令以8位指令，紧随地址，然后潜伏期开始。</p>
<p>潜伏期（空周期）允许器件内部电路在初始地址有足够的时间去访问数据。在潜伏期，SI或者SO上的数据值都是无效的有可能是高阻态。潜伏期的周期数取决于SCK的频率（译者著，跟SDRAM类似）。潜伏期的LC位由配置寄存器1（CR1）设置。</p>
<p>EHPLC提供模式位。</p>
<p><img src="/uploads/2015/07/2015-07-13_162057.png" alt=""></p>
<p><img src="/uploads/2015/07/2015-07-13_162125.png" alt=""></p>
<h3 id="四IO读"><a href="#四IO读" class="headerlink" title="四IO读"></a>四IO读</h3><ul>
<li>EBh (ExtAdd = 0 ),跟随3字节地址</li>
<li>EBh (ExtAdd = 1 ),跟随4字节地址</li>
<li>ECh 跟随4字节地址</li>
</ul>
<p><img src="/uploads/2015/07/2015-07-13_162317.png" alt=""></p>
<p><img src="/uploads/2015/07/2015-07-13_162349.png" alt=""></p>
<p>最大频率104M。</p>
<p><img src="/uploads/2015/07/2015-07-13_162410.png" alt=""></p>
<h3 id="DDR快速读"><a href="#DDR快速读" class="headerlink" title="DDR快速读"></a>DDR快速读</h3><ul>
<li>0Dh (ExtAdd = 0 ),跟随3字节地址</li>
<li>0Dh (ExtAdd = 1 ),跟随4字节地址</li>
<li>0Eh 跟随4字节地址</li>
</ul>
<p><img src="/uploads/2015/07/2015-07-13_162604.png" alt=""></p>
<p>最大操作频率66M。</p>
<h3 id="DDR双IO读"><a href="#DDR双IO读" class="headerlink" title="DDR双IO读"></a>DDR双IO读</h3><ul>
<li>BDh (ExtAdd = 0 ),跟随3字节地址</li>
<li>BDh (ExtAdd = 1 ),跟随4字节地址</li>
<li>BEh 跟随4字节地址</li>
</ul>
<p><img src="/uploads/2015/07/2015-07-13_162711.png" alt=""></p>
<p>最大操作频率66M。</p>
<h3 id="DDR四IO读"><a href="#DDR四IO读" class="headerlink" title="DDR四IO读"></a>DDR四IO读</h3><ul>
<li>EDh (ExtAdd = 0 ),跟随3字节地址</li>
<li>EDh (ExtAdd = 1 ),跟随4字节地址</li>
<li>EEh 跟随4字节地址</li>
</ul>
<p><img src="/uploads/2015/07/2015-07-13_162835.png" alt=""></p>
<p>最大操作频率66M。</p>
<h2 id="闪存阵列编程命令"><a href="#闪存阵列编程命令" class="headerlink" title="闪存阵列编程命令"></a>闪存阵列编程命令</h2><h3 id="单页编程"><a href="#单页编程" class="headerlink" title="单页编程"></a>单页编程</h3><ul>
<li>02h (ExtAdd = 0 ),跟随3字节地址</li>
<li>02h (ExtAdd = 1 ),跟随4字节地址</li>
<li>12h 跟随4字节地址</li>
</ul>
<p><img src="/uploads/2015/07/2015-07-13_163202.png" alt=""></p>
<p><img src="/uploads/2015/07/2015-07-13_163237.png" alt=""></p>
<h3 id="四页编程"><a href="#四页编程" class="headerlink" title="四页编程"></a>四页编程</h3><ul>
<li>32h (ExtAdd = 0 ),跟随3字节地址</li>
<li>32h (ExtAdd = 1 ),跟随4字节地址</li>
<li>38h (ExtAdd = 0 ),跟随3字节地址</li>
<li>38h (ExtAdd = 1 ),跟随4字节地址*   12h 跟随4字节地址</li>
</ul>
<p><img src="/uploads/2015/07/2015-07-13_163439.png" alt=""></p>
<h3 id="编程挂起和恢复"><a href="#编程挂起和恢复" class="headerlink" title="编程挂起和恢复"></a>编程挂起和恢复</h3><p><img src="/uploads/2015/07/2015-07-13_163544.png" alt=""></p>
<h2 id="闪存阵列擦除命令"><a href="#闪存阵列擦除命令" class="headerlink" title="闪存阵列擦除命令"></a>闪存阵列擦除命令</h2><h3 id="4k扇区擦除"><a href="#4k扇区擦除" class="headerlink" title="4k扇区擦除"></a>4k扇区擦除</h3><p>4k扇区擦除指令只在FL128S和FL256S上实现。当扇区是256k时，这个指令将会被忽略。</p>
<p>该指令会将4k扇区所有的位编程为1，即所有指节全部为FFh。在该指令之前，必须先发送一个写使能（WREN）指令去解码器件，状诚寄存器里的写使能锁存（WEL）位使能所有的写操作。</p>
<ul>
<li>20h (ExtAdd = 0 ),跟随3字节地址</li>
<li>20h (ExtAdd = 1 ),跟随4字节地址</li>
<li>21h 跟随4字节地址</li>
</ul>
<p><img src="/uploads/2015/07/2015-07-13_164337.png" alt=""></p>
<h3 id="扇区擦除"><a href="#扇区擦除" class="headerlink" title="扇区擦除"></a>扇区擦除</h3><p>该指令会将扇区所有的位编程为1，即所有指节全部为FFh。在该指令之前，必须先发送一个写使能（WREN）指令去解码器件，状诚寄存器里的写使能锁存（WEL）位使能所有的写操作。</p>
<ul>
<li>D8h (ExtAdd = 0 ),跟随3字节地址</li>
<li>D8h (ExtAdd = 1 ),跟随4字节地址</li>
<li>DCh 跟随4字节地址</li>
</ul>
<p><img src="/uploads/2015/07/2015-07-13_165049.png" alt=""></p>
<h3 id="块擦除"><a href="#块擦除" class="headerlink" title="块擦除"></a>块擦除</h3><p>该指令会将整个闪存擦除掉，将所有位置1。<br><img src="/uploads/2015/07/2015-07-13_165148.png" alt=""></p>
<h3 id="擦除挂起和恢复指令"><a href="#擦除挂起和恢复指令" class="headerlink" title="擦除挂起和恢复指令"></a>擦除挂起和恢复指令</h3><p><img src="/uploads/2015/07/2015-07-13_165320.png" alt=""></p>
<p>所有在擦除或是编程挂起期间被允许指令列表</p>
<p><img src="/uploads/2015/07/2015-07-13_165446.png" alt=""></p>
<h2 id="内嵌操作性能表"><a href="#内嵌操作性能表" class="headerlink" title="内嵌操作性能表"></a>内嵌操作性能表</h2><p><img src="/uploads/2015/07/2015-07-13_165749.png" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/FPGA/">FPGA</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e5-9f-ba-e4-ba-8efpgacpld-e7-9a-84tft-e6-98-be-e7-a4-ba-e6-8e-a7-e5-88-b6-e5-99-a8-e9-80-bb-e8-be-91-e4-bb-a3-e7-a0-81-e7-9a-84-e8-af-a6-e7-bb-86-e8-ae-be-e8-ae-a1-e8-af-b4-e6-98-8e-e4-b9-a6" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/02/e5-9f-ba-e4-ba-8efpgacpld-e7-9a-84tft-e6-98-be-e7-a4-ba-e6-8e-a7-e5-88-b6-e5-99-a8-e9-80-bb-e8-be-91-e4-bb-a3-e7-a0-81-e7-9a-84-e8-af-a6-e7-bb-86-e8-ae-be-e8-ae-a1-e8-af-b4-e6-98-8e-e4-b9-a6/" class="article-date">
      <time datetime="2015-08-02T08:38:04.000Z" itemprop="datePublished">2015-08-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/02/e5-9f-ba-e4-ba-8efpgacpld-e7-9a-84tft-e6-98-be-e7-a4-ba-e6-8e-a7-e5-88-b6-e5-99-a8-e9-80-bb-e8-be-91-e4-bb-a3-e7-a0-81-e7-9a-84-e8-af-a6-e7-bb-86-e8-ae-be-e8-ae-a1-e8-af-b4-e6-98-8e-e4-b9-a6/">基于FPGA/CPLD + SDRAM 的TFT液晶控制器(lcd controller)逻辑代码的详细设计说明书</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <hr>
<p>先看看两张效果图吧,<strong>手机拍摄效果差于实际效果</strong>。</p>
<p><img src="/uploads/2015/06/tft1.jpg" alt=""></p>
<p><img src="/uploads/2015/06/tft0.jpg" alt=""></p>
<p>看看NES游戏的《坦克世界》，^_^</p>
<p><img src="/uploads/2015/06/tft2.jpg" alt=""></p>
<p><img src="/uploads/2015/06/tft3.jpg" alt=""></p>
<p><img src="/uploads/2015/06/tft4.jpg" alt=""></p>
<p><a href="http://120.24.164.199
/uploads/2015/06/TFT控制器用户手册-副本.pdf" target="_blank" rel="external">TFT控制器用户手册 - 副本</a></p>
<h2 id="项目背景及开发目的"><a href="#项目背景及开发目的" class="headerlink" title="项目背景及开发目的"></a>项目背景及开发目的</h2><p>目前市面上各种TFT显示专用控制器价格相对较为高昂，且存在以下缺点：</p>
<ul>
<li>通常TFT控制芯片成本在 22~33 RMB区间。</li>
<li>支持的显示分辨率通常在800&#42;480以内，而在分辨率为800&#42;480时能刷新率却不能满足要求(&lt;24fps/s)，有闪烁感。</li>
<li>支持的显存容量有限，如通常为一页或两页显存，不利于进行较为高级的UI混合渲染。</li>
<li>支持的外部存储容量有限，在显示界面较多时存储不了所需的UI图片资源。</li>
<li>通常只支持HV模式、DE模式，而不支持高分辨率TFT屏所带的LVDS、MIPI接口。</li>
<li>各TFT控制芯片的接口和寄存器互异，配置寄存器繁多，操作繁复。</li>
<li>部分TFT控制芯片开发资料少，规格书内容不详细，开发需要厂商FAE支持，而厂商FAE支持力度不太到位。</li>
<li>部分TFT控制芯片标称的技术性能指标与实际值不一致，导致项目临时换方案。</li>
</ul>
<p>由于以上这些原因，为了满足我司TFT相关产品的不同需求，工程师选取了多种TFT控制器方案，这不利于技术复用和维护，直接增加了开发工程师和测试工程师的工作量，同时还在一定程度上增加了项目的开发风险。<br>本设计的目的就在于实现成本控制和技术指标设计两方面的灵活性，增强技术的复用，降低开发难度，简化设计和维护成本，降低开发工程师和测试工程师的工作量，同时减少项目风险。</p>
<h2 id="项目需求及设计指标"><a href="#项目需求及设计指标" class="headerlink" title="项目需求及设计指标"></a>项目需求及设计指标</h2><ul>
<li>样品成本在20 RMB左右，批量成本 <strong>15RMB </strong>以下。</li>
<li>分辨率支持 <strong>1024&#42;768</strong>及以下。</li>
<li>支持<strong>16bit、24bit</strong>真彩色。</li>
<li>支持多页缓存（对于800*480分辨率支持8页），显示页和读写页互相独立。</li>
<li>用户读写最大带宽<strong>50M&#42;16bit（或50M&#42;24bit）</strong>。</li>
<li><strong>16bit\24bit</strong>位宽的<strong>8080或6800</strong>并行接口。</li>
<li>支持<strong>HV、DE</strong>模式，同时可扩展支持<strong>VGA、LVDS、MIPI DSI</strong>接口。</li>
<li>支持<strong>0~16（或更高）</strong>级分辨率的背光控制。</li>
<li>支持画面<strong>水平和垂直显示镜像</strong>。</li>
<li><strong>支持指定区域突发读写</strong>，即只需要指定一次操作矩形区，X、Y坐标即可自动增长，无需重复发送坐标位置。</li>
</ul>
<h2 id="项目方案选型（参考了ZLG的相关文档）"><a href="#项目方案选型（参考了ZLG的相关文档）" class="headerlink" title="项目方案选型（参考了ZLG的相关文档）"></a>项目方案选型（参考了ZLG的相关文档）</h2><h3 id="1-基于CPLD-SRAM的方案。"><a href="#1-基于CPLD-SRAM的方案。" class="headerlink" title="1. 基于CPLD + SRAM的方案。"></a><strong>1. 基于CPLD + SRAM的方案。</strong></h3><p>该方案采用性价比较高的CPLD(如EMP240、A3P030 nano)和SRAM来实现，不仅成本低，而且灵活性非常大，实现的功能丰富，由于采用性价比较低的SRAM，容量有限，适合于低分辨率的TFT屏显示。</p>
<p><img src="/uploads/2015/06/fpga_sram.jpg" alt=""></p>
<p>功能特点：</p>
<ol>
<li>采用altera的EPM240或Microsemi小容量的A3P030以及SRAM来实现，具有成本低的特点。</li>
<li>开发方案简单，工程量小，技术难度低。</li>
<li>接口非常灵活，根据不同的需要可以定制8080并行总线接口、6800并行总线接口等。</li>
<li>并行总线接口的速度最高可达25MHz左右，相当于480×272分辨率的TFT在1秒钟内可以更新191副图片。</li>
<li>支持双缓存的操作，两个缓存都可进行读写的操作。</li>
<li>支持定点和区域更新内容。</li>
<li>支持16位色480×272以及以下分辨率的TFT显示屏，刷新率在60Hz以上。</li>
<li>显示数据来源于MCU，数据可以存放于外部的串行或并行的Flash，可以存放图片、汉字库等，容量大小由用户自行控制。</li>
</ol>
<p>缺点：<strong>由于SRAM成本较高，在高分辨率时整体硬件成本会明显增加</strong></p>
<h3 id="2-基于FPGA-SDRAM的方案"><a href="#2-基于FPGA-SDRAM的方案" class="headerlink" title="2. 基于FPGA + SDRAM的方案"></a><strong>2. 基于FPGA + SDRAM的方案</strong></h3><p>该方案采用Lattice LCMXO2-1200（或Microsemi的A3P060）和SDRAM的方式实现，同样成本低，由于Microsemi资源较为丰富，并且内部带有PLL，所以可以实现高分率的TFT显示，最高可达1024×768。<br><img src="/uploads/2015/06/fpga_sdr.jpg" alt=""><br>功能特点：</p>
<ol>
<li>采用Lattice的Lattice LCMXO2-1200（或Microsemi的A3P060）以及SDRAM来实现，具有成本低的特点。</li>
<li>接口非常灵活，根据不同的需要可以定制8080并行总线接口、6800并行总线接口等。</li>
<li>并行总线接口的速度最高可达50MHz左右，相当于800×600分辨率的TFT在1秒钟内可以更新100副图片</li>
<li>支持8页缓存（可采用更大容量的SDRAM来实现更多的缓存页）的操作，8个缓存都可进行读写的操作。</li>
<li>支持定点和区域更新内容</li>
<li>支持16位色1024×768以及以下分辨率的TFT显示屏，刷新率在60Hz以上</li>
<li>显示数据来源于MCU，数据可以存放于外部的串行或并行的Flash，可以存放图片、汉字库等，容量大小由用户自行控制。</li>
</ol>
<p>缺点：<strong>SDRAM存储器由于其自身特性时序相对较为复制，开发技术难度大</strong>。</p>
<h2 id="控制器总体设计"><a href="#控制器总体设计" class="headerlink" title="控制器总体设计"></a>控制器总体设计</h2><h3 id="TFT控制器接口设计及PIN定义说明"><a href="#TFT控制器接口设计及PIN定义说明" class="headerlink" title="TFT控制器接口设计及PIN定义说明"></a>TFT控制器接口设计及PIN定义说明</h3><p><img src="/uploads/2015/06/tftCtrTop.png" alt=""></p>
<p>TFT控制器的电气符号如上图，该接口各个PIN定义如下：<br><strong>clk</strong> —— 输入，控制器时钟，频率10M</p>
<p><strong>nRst</strong> —— 输入，控制器外部复位，低电平有效</p>
<p><strong>dataUsr[15..0]</strong> —— 三态双向IO，8080总线数据线</p>
<p><strong>cs</strong> —— 输入，8080总线片选，低电平有效</p>
<p><strong>rs</strong> —— 输入，8080总线寄存器地址与寄存器数据选择，rs为低表示数据线上呈现的是寄存器地址，rs为高表示数据线上呈现的是寄存器数据</p>
<p><strong>wr</strong> —— 输入，8080总线写使能，低电平有效</p>
<p><strong>rd</strong> —— 输入， 8080总线读使能，低电平有效</p>
<p><strong>clkTft</strong> —— 输出，TFT模组的时钟</p>
<p><strong>vs</strong> —— 输出，TFT模组的场信号</p>
<p><strong>hs</strong> —— 输出，TFT模组的行信号</p>
<p><strong>de</strong> —— 输出，TFT模组的时钟信号</p>
<p><strong>rDataTft[4..0]</strong> —— 输出，TFT模组的R通道信号，5位</p>
<p><strong>gDataTft[5..0]</strong> —— 输出， TFT模组的G通信信号，6位</p>
<p><strong>bDataTft[4..0]</strong> —— 输出， TFT模组的B通信信号，5位</p>
<p><strong>lrTft</strong> —— 输出，TFT模组水平扫描方向信号</p>
<p><strong>udTft</strong> —— 输出，TFT模组垂直扫描方向信号</p>
<p><strong>modeTft</strong> —— 输出，TFT模组行场模式、DE模式选择信号</p>
<p><strong>ledTft</strong> —— 输出，TFT模组背光PWM控制信号</p>
<p><strong>clkSdr</strong> —— 输出，SDRAM时钟信号</p>
<p><strong>ckeSdr</strong> —— 输出， SDRAM时钟使能信号</p>
<p><strong>nCsSdr</strong> —— 输出，SDRAM片选信号</p>
<p><strong>nCasSdr</strong> —— 输出，SDRAM列地址有效信号</p>
<p><strong>nRasSdr</strong> —— 输出， SDRAM行地址有效信号</p>
<p><strong>dqmSdr[1..0]</strong> —— 输出，SDRAM掩码信号</p>
<p><strong>baSdr[1..0]</strong> —— 输出，SDRAM的BANK地址信号</p>
<p><strong>addrSdr[12..00]</strong> —— 输出，SDRAM的地址线</p>
<p><strong>dataSdr[15..0]</strong> —— 三态双向IO，SDRAM的数据线</p>
<p>###控制器总体设计框图</p>
<p>整体设计框图如下,图中各模块功能分别如为：</p>
<ul>
<li><strong>MCU_FPGA总线接口模块</strong>——实现用户数据的同步和用户命令的解析。</li>
<li><strong>SDRAM控制器</strong>——实现SDRAM的初始化、自动刷新，自动预充电，数据读写操作相关时序。</li>
<li><strong>TFT_CTRL控制核心模块</strong>——实现用户读写SDRAM、TFT时序控制器读取SDRAM的协同，对SDRAM的总带宽进行分配。</li>
<li><strong>TFT时序控制器</strong>——实现TFT显示模组的行场或DE同步刷新时序，并将显示数据呈现到TFT显示模组上。</li>
<li><strong>TFT背光PWM控制模块</strong>——实现TFT模组LED背光亮度的控制。</li>
<li><strong>时钟生成与系统复位控制模块</strong>——实现各个模块所需时钟的生成，以及产生稳定可靠的复位信号</li>
</ul>
<p><img src="/uploads/2015/06/all.png" alt=""></p>
<h2 id="控制器模块详细设计说明"><a href="#控制器模块详细设计说明" class="headerlink" title="控制器模块详细设计说明"></a>控制器模块详细设计说明</h2><h3 id="MCU-FPGA总线接口模块"><a href="#MCU-FPGA总线接口模块" class="headerlink" title="MCU_FPGA总线接口模块"></a>MCU_FPGA总线接口模块</h3><p><img src="/uploads/2015/06/usrBus.png" alt=""></p>
<h3 id="SDRAM控制器（参考了ALTERA《SDR-SDRAM-Controller》白皮书）"><a href="#SDRAM控制器（参考了ALTERA《SDR-SDRAM-Controller》白皮书）" class="headerlink" title="SDRAM控制器（参考了ALTERA《SDR SDRAM Controller》白皮书）"></a>SDRAM控制器（参考了ALTERA《SDR SDRAM Controller》白皮书）</h3><h4 id="SDRAM架构框图及原理"><a href="#SDRAM架构框图及原理" class="headerlink" title="SDRAM架构框图及原理"></a>SDRAM架构框图及原理</h4><p><img src="/uploads/2015/06/sdrBlock.png" alt=""></p>
<p>关于SDRAM原理详情，请参见<a href="http://wenku.baidu.com/view/63c8f94f767f5acfa1c7cde5.html" target="_blank" rel="external">《高手进阶，终极内存技术指南》</a>一文。</p>
<h4 id="SDRAM时序"><a href="#SDRAM时序" class="headerlink" title="SDRAM时序"></a>SDRAM时序</h4><ul>
<li><strong>SDRAM初始化时序</strong></li>
</ul>
<p><img src="/uploads/2015/06/sdr_init.png" alt=""></p>
<p>在SDRAM初始化阶段，主要用于配置SDRAM的突发模式，突发顺序，潜伏期等参数。</p>
<ul>
<li><strong>SDRAM掉电模式时序</strong></li>
</ul>
<p><img src="/uploads/2015/06/sdrPwrDown.png" alt=""></p>
<p>在掉电模式下SDRAM将进入低功耗状态，但处在该模式下的时长不能超过64ms的刷新周期，否则数据将丢失。</p>
<ul>
<li><strong>SDRAM时钟挂起模式时序</strong></li>
</ul>
<p><img src="/uploads/2015/06/sdr_clkSuspend.png" alt=""></p>
<p>在时钟挂起模式下，将会关闭SDRAM内部的时步逻辑，SDRAM不再响应任何组合命令，SDRAM数据线上的数据也将被屏蔽。</p>
<ul>
<li><strong>SDRAM自动刷新时序</strong></li>
</ul>
<p><img src="/uploads/2015/06/sdr_autoRef.png" alt=""></p>
<p>因为SDRAM内部的BANK是电容式的，最大只能保持64ms，因此每行存储单元必须在64ms内执行一次自动刷新。</p>
<ul>
<li><strong>SDRAM自刷新模式时序</strong></li>
</ul>
<p><img src="/uploads/2015/06/sdrSelfRef.png" alt=""></p>
<p>Self Refresh。这种mode的功耗在1mA以下。在这种状态下，SDRAM芯片自己完成refresh的操作，不需要SDRAM controller的干涉（Auto refresh需要）。既然有刷新，SDRAM中的数据是自然可以保持住的。SDRAM进入self refresh后，SDRAM controller也会disable输出到SDRAM的clock，从而整体的功耗都降低下来。</p>
<ul>
<li><strong>SDRAM无自动预充电突发读时序</strong></li>
</ul>
<p><img src="/uploads/2015/06/sdrReadWithout.png" alt=""></p>
<p>上图是需要由外部控制器发送预充电命令的突发读操作。</p>
<ul>
<li><strong>SDRAM自动预充电突发读时序</strong></li>
</ul>
<p><img src="/uploads/2015/06/sdrRead.png" alt=""></p>
<p>上图的读操作，不需要外部的SDRAM控制器发送预充电命令，在每个读操作结束后SDRAM内部会自动产生一个预充电操作。</p>
<ul>
<li><strong>SDRAM无自动预充电单操作读时序</strong></li>
</ul>
<p><img src="/uploads/2015/06/sdrSReadWithout.png" alt=""></p>
<p>上图是需要由外部控制器发送预充电命令的Single读操作。</p>
<ul>
<li><strong>SDRAM自动预充电单操作读时序</strong></li>
</ul>
<p><img src="/uploads/2015/06/sdrSRead.png" alt=""><br>上图的Single读操作，不需要外部的SDRAM控制器发送预充电命令，在每个读操作结束后SDRAM内部会自动产生一个预充电操作。</p>
<ul>
<li><strong>SDRAM变换BANK读访问时序</strong></li>
</ul>
<p><img src="/uploads/2015/06/sdrAlteraBankR.png" alt=""></p>
<p>上图是改变BANK的读操作时序</p>
<ul>
<li><strong>SDRAM读时DQM操作时序</strong></li>
</ul>
<p>上图是SDRAM在进行读操作时的DQM信号的时序图</p>
<p><img src="/uploads/2015/06/sdrReadDQM.png" alt=""></p>
<ul>
<li><strong>SDRAM页突发读时序</strong></li>
</ul>
<p><img src="/uploads/2015/06/sdrReadPage.png" alt=""></p>
<p>上图是SDRAM进行页突发读的操作时序，突发长度为一页。</p>
<ul>
<li><strong>SDRAM无自动预充电突发写时序</strong></li>
</ul>
<p>上图是需要由外部控制器发送预充电命令的突发写操作。</p>
<p><img src="/uploads/2015/06/sdrWriteWithout.png" alt=""></p>
<ul>
<li><strong>SDRAM自动预充电突发写时序</strong></li>
</ul>
<p>上图的写操作，不需要外部的SDRAM控制器发送预充电命令，在每个写操作结束后SDRAM内部会自动产生一个预充电操作。</p>
<p><img src="/uploads/2015/06/sdrWrite.png" alt=""></p>
<ul>
<li><strong>SDRAM无自动预充电单操作写时序</strong></li>
</ul>
<p>上图是需要由外部控制器发送预充电命令的Single写操作。</p>
<p><img src="/uploads/2015/06/sdrSWriteWithout.png" alt=""></p>
<ul>
<li><strong>SDRAM自动预充电单操作写时序</strong></li>
</ul>
<p>上图的Single写操作，不需要外部的SDRAM控制器发送预充电命令，在每个读操作结束后SDRAM内部会自动产生一个预充电操作。</p>
<p><img src="/uploads/2015/06/sdrSWrite.png" alt=""></p>
<ul>
<li><strong>SDRAM变换BANK写访问时序</strong></li>
</ul>
<p><img src="/uploads/2015/06/sdrAlteraBankW.png" alt=""></p>
<p>上图是改变BANK的写操作时序</p>
<ul>
<li><strong>SDRAM读时DQM操作时序</strong></li>
</ul>
<p><img src="/uploads/2015/06/sdrWriteDQM.png" alt=""></p>
<p>上图是SDRAM在进行写操作时的DQM信号的时序图</p>
<ul>
<li><strong>SDRAM页突发写时序</strong></li>
</ul>
<p><img src="/uploads/2015/06/sdrWritePage.png" alt=""></p>
<p>上图是SDRAM进行页突发写的操作时序，突发长度为一页。</p>
<h4 id="SDRAM控制器接口定义"><a href="#SDRAM控制器接口定义" class="headerlink" title="SDRAM控制器接口定义"></a>SDRAM控制器接口定义</h4><p>SDRAM控制器提供如下接口</p>
<p><img src="/uploads/2015/06/sdr_interface.png" alt=""></p>
<p>其接口PIN定义如下</p>
<p><img src="/uploads/2015/06/sdr_pinDef.png" alt=""></p>
<h4 id="SDRAM控制器设计"><a href="#SDRAM控制器设计" class="headerlink" title="SDRAM控制器设计"></a>SDRAM控制器设计</h4><p><strong>SDRAM控制器框图</strong></p>
<p><img src="/uploads/2015/06/sdr_block.png" alt=""></p>
<p>SDRAM控制器框图如上图，主要由以下三个模块构成：</p>
<ul>
<li><strong>Control Interface Module（控制接口模块）</strong></li>
</ul>
<p>控制接口模块对主机发出的命令解码并寄存，传送已经解码的NOP, WRITEA, READA,<br>REFRESH, PRECHARGE 和 LOAD_MODE 命令和 ADDR给命令模块， LOAD_REG1 和<br>LOAD_REG2 命令解码后， 同ADDR一起装入内部的REG1和REG2寄存器。下图给出了控制接口<br>模块的框图。</p>
<p><img src="/uploads/2015/06/sdr_ctrlInterface.png" alt=""></p>
<p>控制接口模块也含有一个16位的减法计数器， 和用于给命令模块产生周期刷新命令的电路，<br>16位的减法计数器装入REG2中的数值， 并递减到0， 但计数器为0时， 执行REFRESH_REQ输出<br>给命令模块，该命令一致输出直到命令模块响应该刷新请求。收到命令模块的刷新请求后，减<br>法计数器重新装入REG2中的数值，重复以上过程。 REG2是一个表示SDR SDRAM控制其发出<br>的REFRESH（刷新）命令之间的时间间隔周期，数值等于refresh_period/clock_period 的整数。</p>
<ul>
<li><strong>Command Module（命令模块）</strong></li>
</ul>
<p>“命令模块” 接收“控制接口模块” 输出的已经解码的命令，和周期性输出的刷新请求，<br>并产生合适的命令给SDRAM器件， 模块含有一个简易的仲裁电路用于仲裁主机的命令和刷新控<br>制逻辑所产生的刷新请求。从刷新控制逻辑电路发出的刷新请求比主机接口的命令的优先级别<br>高。如果主机命令和隐含的刷新操作同时出现，仲裁电路在刷新操作完成之前就不发出<br>CMDACK应答。 如果主机操作在进行中， 收到了刷新命令， 刷新操作将延时到主机操作完成后<br>执行，下图给出了命令模块的框图。</p>
<p><img src="/uploads/2015/06/sdr_ctrCmd.png" alt=""></p>
<p>在仲裁电路已经接受主机命令后， 命令被送到模块的命令发生器部分， 命令模块使用3个移<br>位寄存器来产生命令之间的时序，一个移位寄存器用于控制ACTIVATE命令；第二个用于控制<br>READA or WRITEA命令发出的时间；第三个用于对命令的持续时间定时，这样仲裁其就可以<br>判断最近请求的操作是否已经完成。<br>命令模块也实现SDRAM的地址复用，地址的行部分在ACTIVATE(RAS) 命令时复用到<br>SDRAM输出的A[11:0], 地址的列部分在READA(CAS) 或 WRITEA命令时复用到SDRAM地址<br>线上,<br>控制模块所产生的输出信号OE用于控制数据通路模块的DATAIN 通路的三态缓冲。</p>
<ul>
<li><strong>Data Path Module（数据通路模块）</strong></li>
</ul>
<p>数据通路模块提供了SDRAM和主机之间的数据接口， 主机在 WRITEA 时从 DATAIN 上输入<br>数据，在 READA 命令时 从 DATAOUT 上取出数据。图10给出了数据通路模块的方块图，<br>DATAIN通路由 2段通路组成，以和对应的 CMDACK和送往SDRAM的命令的时序对齐，<br>DATAOUT也由2段通路构成，用于在READA 命令期间寄存SDRAM的输出数据， DATAOUT<br>的通路延时能够减少到1次或者不寄存，唯一的影响的是DATAIUT和CMKACK的关系会改变。</p>
<p><img src="/uploads/2015/06/sdrCtrlData.png" alt=""></p>
<p>注：<em>在本项目设计中由于时序上的原因，该模块已被裁剪掉，但为了更好地完整说明SDRAM控制器的设计，所以仍在文档中保留了该模块的描述</em></p>
<h3 id="TFT-CTRL控制核心模块"><a href="#TFT-CTRL控制核心模块" class="headerlink" title="TFT_CTRL控制核心模块"></a>TFT_CTRL控制核心模块</h3><p><img src="/uploads/2015/06/tftCtrl.png" alt=""></p>
<p>核心控制器模块的主要组成部分及功能设计说明:<br><strong>用户显存坐标=》SDRAM地址转换</strong> ——完成用户像素逻辑坐标到SDRAM地址的映射，省去了用户在上位机由坐标计算SDRAM地址的麻烦。同时该功能块还用于用户写显存时X、Y坐标在指定矩形操作区内的的自动增长维护。</p>
<p><strong>SDRAM带宽仲裁</strong> ——由于SDRAM的接口并不是并行，在TFT模块从SDRAM读取数据刷新屏模式，用户的不能SDRAM进行读写操作，因此需要一个SDRAM带宽仲裁模块来对SDRAM的操作带宽进行合理分配。本设计中包含有三个FIFO模块，其中FIFO_RD_TFT是用于缓存TFT从SDRAM读取的数据，FIFO_WR_USR用于缓存用户写写和数据，FIFO_RD_USR用于缓存用户从SDRAM读取的数据。在TFT读取SDRAM数据时，若有用户往控制器写入数据，将会被缓存在FIFO_WR_USR中，在本设计中由于仲裁器留给用户的SDRAM平均写入带宽远大于用户通过8080接口写入的带宽，因此FIFO不会溢出，用户也不会感觉到数据被缓存；当用户往控制器发送读数据命令时，若此时SDRAM处于TFT读操作中，该命令将会暂缓执行，直至TFT读取SDRAM数据操作结束，在本设中于TFT读取SDRAM操作的周期很短，仲裁器留给SDRAM的用户平均读取操作远大于用户通过8080接口读取的带宽，因此用户不会感觉到数据的平连续。</p>
<p><strong>TFT_CTRL控制状态机</strong> —— 这是TFT控制核心模块的核心，该状态机用于控制TFT_CTRL模块内部的状态切换，实现一种类似CPU的流程化控制。</p>
<p><strong>TFT像素坐标=》SDRAM地址转换</strong> —— 实现TFT像素坐标到SDRAM地址的转换，同时控制TFT刷新时X、Y坐标的自动增长控制。</p>
<h4 id="TFT-CTRL控制核心状态机"><a href="#TFT-CTRL控制核心状态机" class="headerlink" title="TFT_CTRL控制核心状态机"></a>TFT_CTRL控制核心状态机</h4><p><img src="/uploads/2015/06/tftCtrlState.png" alt=""><br>状态机各状态含义：<br><strong>WAITE_SDR_INIT</strong> ——等待SDRAM初始化完成</p>
<p><strong>AUTO_REF_SDR</strong> —— 执行SDRAM自动刷新</p>
<p><strong>RD_SDR_TFT</strong> —— 执行从SDRAM读取TFT刷屏数据</p>
<p><strong>RD_SDR_USR</strong> —— 执行用户读显存操作</p>
<p><strong>WR_SDR_USR</strong> —— 执行用户写显存操作</p>
<p><strong>NONE_OP_TFT</strong> —— TFT无数据请求</p>
<p><strong>NONE_OP_USR</strong> —— 无外部用户请求</p>
<p>在控制器上电后，首先控制器内部的<strong>多路时钟生成与系统复位控制模块</strong>会延时一段时间，以等待FPGA稳定，之后内部PLL产生一个CLK&#95;LOCK信号，这个CLK&#95;LOCK信号表明PLL已能稳定输出时钟，此时产生一个复位信号用于作为整个控制器的内部复位信号。内部复位完成之后，开始进行SDRAM的初始化工作，经过一系统的SDRAM控制命令之后，SDRAM的内部MODE寄存器成功加载数据，此时即完成了SDRAM的初始化，在这之前状态机始终处理WAITE&#95;SDR&#95;INIT，TFT时序发生器一直处于复位状态。WAITE&#95;SDR&#95;INIT结束后，进入到AUTO&#95;REF&#95;SDR状态，进行SDRAM非初始化阶段的首次自动刷新操作。AUTO&#95;REF&#95;SDR状态同时会结束TFT时序发生器的复位。直至SDRAM自动刷新命令成功完成，状态机始终处理AUTO&#95;REF&#95;SDR。自动刷新命令完成后，若此时TFT模块请求读取SDRAM那么将会进入RD&#95;SDR&#95;TFT状态，反之则进入NONE&#95;OP&#95;TFT状态。在进入RD&#95;SDR&#95;TFT状态后，状态机将始终处于RD&#95;SDR&#95;TFT状态直至数据读取完成。在RD&#95;SDR&#95;TFT或NONE&#95;OP&#95;TFT状态结束之后，若有用户操作请求则进入WR&#95;SDR&#95;USR或RD&#95;SDR&#95;USR状态或NONE&#95;OP&#95;USR状态。若FINISH&#95;OP&#95;SDR状态之后wrUsrFlag标志置位则进入RD&#95;SDR&#95;USR状态，若rdUsrFlag标志置位则进入WR&#95;SDR&#95;USR状态，若二者都未置位则进入NONE&#95;OP&#95;USR状态。进入WR&#95;SDR&#95;USR状态后，直至完成用户数据向SDRAM写入状态机都将始终处于WR&#95;SDR&#95;USR状态。结束WR&#95;SDR&#95;USR状态后，若autoRefFlag置位则进入到AUTO&#95;REF&#95;SDR状态。RD&#95;SDR&#95;USR、NONE&#95;OP&#95;USR状态的跳转逻辑与WR&#95;SDR&#95;USR相同。至此，整个状态机周而复始重复以上过程。</p>
<h3 id="TFT时序控制器"><a href="#TFT时序控制器" class="headerlink" title="TFT时序控制器"></a>TFT时序控制器</h3><h4 id="TFT行场模式时序"><a href="#TFT行场模式时序" class="headerlink" title="TFT行场模式时序"></a>TFT行场模式时序</h4><p><img src="/uploads/2015/06/tft_hv.png" alt=""></p>
<p>在TFT行场模式下，HS行信号在VS场信号的t_W时段有效，DCLK像素时钟信号在HS行信号的t_HV段内有效，在t_HV时段内，每个DCLK下降沿TFT采样一个数据。在t_HV时段内，TFT完成一行图像的刷新，在t_W时段内TFT完成一幅图像的刷新。</p>
<h4 id="TFT-DE模式时序"><a href="#TFT-DE模式时序" class="headerlink" title="TFT DE模式时序"></a>TFT DE模式时序</h4><p><img src="/uploads/2015/06/tft_de.png" alt=""></p>
<p>在DE模式下，在DE有效的情况下，每个DCLK下降沿TFT采样一个数据，直至完成一幅图像的刷新。</p>
<h4 id="TFT时序控制器设计"><a href="#TFT时序控制器设计" class="headerlink" title="TFT时序控制器设计"></a>TFT时序控制器设计</h4><p><img src="/uploads/2015/06/tft_drv.png" alt=""></p>
<p><strong>行同步计数器</strong> —— 计数DCLK，用于产生行同步信号</p>
<p><strong>场同步计数器</strong> —— 计数行同步计数器的翻转次数，用于产生场同步信号</p>
<p><strong>行信号生成逻辑</strong> —— 产生行同步脉冲时序</p>
<p><strong>场信号生成逻辑</strong> —— 产生场同步脉冲时序</p>
<p><strong>DE信号生成逻辑</strong> —— 产生DE同步脉冲时序</p>
<p><strong>数据请求生成逻辑</strong> —— 产生数据请求信号，请求TFT_CTRL模块从SDRAM读取显存数据</p>
<p>###TFT背光PWM控制模块</p>
<p><img src="/uploads/2015/06/led_pwm.png" alt=""></p>
<p><strong>背光寄存器</strong> —— 用于寄存用户写入的背光值，该值由TFT_CTRL输出</p>
<p><strong>PWM计数比较器</strong> —— 计数背光模块时钟，并与背光寄存器中的值进行比较，输出PWM波</p>
<p>###多路时钟生成，与系统复位控制模块</p>
<p><img src="/uploads/2015/06/clk_rst.png" alt=""></p>
<p><strong>PLL/DLL锁相环</strong> —— 器件内置的PLL或DLL硬核IP，用于倍频和分频产生系统内部所需的25M，100M，与源时钟有一定相移的100M时钟。</p>
<p><strong>内部系统延时复位模块</strong> —— 用于等待上电后外部时钟，同步控制器外部的复位信号，同时等待内部PLL时钟锁定，综合以上信号生成用于系统内部的最终复位信号。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/FPGA/">FPGA</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/6/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/8/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2016 shawge
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/luuman/hexo-theme-spfk" target="_blank">spfk</a> by luuman
            </div>
        </div>
        
    </div>
</footer>

    </div>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 17;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>