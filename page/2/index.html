<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>hex55</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="hex55">
<meta property="og:url" content="http://hex55.com/page/2/index.html">
<meta property="og:site_name" content="hex55">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="hex55">
  
    <link rel="alternative" href="/atom.xml" title="hex55" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
     
      <meta name="baidu-site-verification" content="REhAN7ff6A" />
    
     
      <meta name="google-site-verification" content="DkSZxpxvGJb9xs1yDxUluN2sMm08TKCvmxStju10NpU" />
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: false,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img src="/img/head.jpg" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/">shawge</a></h1>
        </hgroup>

        
        <p class="header-subtitle">shawge的电子技术分享</p>
        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">博客首页</a></li>
                        
                            <li><a href="/categories/MCU-ARM/">MCU/ARM</a></li>
                        
                            <li><a href="/categories/FPGA/">FPGA</a></li>
                        
                            <li><a href="/categories/windows-linux/">WINDOWS/LINUX</a></li>
                        
                            <li><a href="/categories/硬件设计/">硬件设计</a></li>
                        
                            <li><a href="/archives/">文章归档</a></li>
                        
                            <li><a href="/about/">留言给我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail" target="_blank" href="http://hex55@qq.com" title="mail">mail</a>
                            
                                <a class="fl github" target="_blank" href="https://github.com/hex55" title="github">github</a>
                            
                                <a class="fl rss" target="_blank" href="/atom.xml" title="rss">rss</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/github-提速/" style="font-size: 10px;">github 提速</a>
                    </div>
                </section>
                
                
                

                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">没想好。。。</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">shawge</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img src="/img/head.jpg" class="js-avatar" style="width: 100%; height: 100%; opacity: 1;">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">shawge</a></h1>
            </hgroup>
            
            <p class="header-subtitle">shawge的电子技术分享</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">博客首页</a></li>
                
                    <li><a href="/categories/MCU-ARM/">MCU/ARM</a></li>
                
                    <li><a href="/categories/FPGA/">FPGA</a></li>
                
                    <li><a href="/categories/windows-linux/">WINDOWS/LINUX</a></li>
                
                    <li><a href="/categories/硬件设计/">硬件设计</a></li>
                
                    <li><a href="/archives/">文章归档</a></li>
                
                    <li><a href="/about/">留言给我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="http://hex55@qq.com" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/hex55" title="github">github</a>
                    
                        <a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-pid-e5-88-9d-e5-ad-a6-e8-80-85-e6-8c-87-e5-8d-97" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/25/pid-e5-88-9d-e5-ad-a6-e8-80-85-e6-8c-87-e5-8d-97/" class="article-date">
      <time datetime="2016-01-25T06:25:22.000Z" itemprop="datePublished">2016-01-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/25/pid-e5-88-9d-e5-ad-a6-e8-80-85-e6-8c-87-e5-8d-97/">PID初学者指南</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>文中所提的PID算法是一个Ardunio的PDI库，原作者为了让使用者理解这个库中的代码，专门写了一篇指南<a href="http://brettbeauregard.com/blog/2011/04/improving-the-beginner%E2%80%99s-pid-derivative-kick/" target="_blank" rel="external">Improving the Beginner’s PID – Derivative Kick</a>，Ardunio的网站上还有一个与这个PID库相对应的PID参数自整定库<a href="http://playground.arduino.cc/Code/PIDAutotuneLibrary" target="_blank" rel="external">PID Autotune Library</a>，我还没来得及去找它的相关文章。话说这篇指南是从一个很实用的角度对PID进行了深入浅出的讲解，文章没有拘泥于数学论证（咱们的目的只是应用，不是论证理论的正确性或者对PID进行学术研究），而是直接从公式写出最简单的十几行PID算法代码，然后针对这十几行代码结合实际问题让这个算法一步一步变得更稳定实用。</p>
<hr>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在发布新的Arduino PID库的时候我决定发布一系列与它相关的文章。上一版本的库，稳定，但是没有提供任何代码相关的解释。这次我计划详细地解释一下代码为什么这么写。我希望对这两类人是有用的：</p>
<ul>
<li>给想知道Arduino PID内部是怎么工作感兴趣的人提供详解。</li>
<li>让任何想自己写PID算法的人知道我是怎么做的，给他们提供借鉴。</li>
</ul>
<p>这将是一个艰难的跋涉，但我想我找到了一个不太痛苦的方式来解释我的代码。我将一个被称为“初学者PID”的代码开始。然后我将一步步改进它直到我们得到一个高效的键壮的PID算法。</p>
<h4 id="初学者PID"><a href="#初学者PID" class="headerlink" title="初学者PID"></a>初学者PID</h4><p>这是众所周知的PID公式：</p>
<p><img src="/uploads/2016/01/pidalgorithm.png" alt=""></p>
<p>这导致大多数人写出了下面这样的PID控制器代码：</p>
<p><img src="/uploads/2016/01/PID2016-01-25_134231.png" alt=""></p>
<p>Compute() 被规则或者不规则地调用，并且它运行得不错。虽然本系列不是关于“运行得不错”的文章。如果我们打算把代码写得像某些工业PID控制器一样，我们得考虑下面这些问题：</p>
<ol>
<li>彩样时间 —— PID算法最好是规则等间隔地进行评估。如果算法中这个是等间隔的，会简化一些内部数学运算。</li>
<li>微分冲击 —— 不是一个了不起的点子，很容易做到这一点，那么让我们做到这一点吧。</li>
<li>在线修改参数 —— 一个好的PID算法是在运行时改变参数而不会产生抖动的算法。</li>
<li>积分饱和 —— 我们会知道什么是积分饱和，并且能够给出一个对此有益的解决方案。</li>
<li>开关（自动/手动）—— 在大多数应用中，都会有在某些时候需要关闭PID的需求，并且手动判定输出，不需要控制器的干涉。</li>
<li>初始化 —— 当控制器被打开的时候，我们不想转换产生抖动。我们不希望输出突然变成一个新的值。</li>
<li>控制方向 —— 最后一个不是一个与稳定性相关的改动。它是被设计成确保用户输入的参数符号正确。</li>
</ol>
<p>一理我们考虑并处理了这些，我们将会有一个稳定的PID算法。不是巧合，我们将会得到一个与最新版Arduino PID 库相同的代码。因此不管你是否打算去写你自己的算法，或者试着去理解PID库的内部，我希望你这能帮到你。让我们开始吧。</p>
<p>更新： 在所的示例代码中我用了双精度。在Ardunio，双精度等同于单精度浮点。对于PID算法而言使用真正的双精度是杀鸡用牛刀。如果你用的语言支持真正的双精度，我建议你将所有的双精度改为单精度浮点。</p>
<hr>
<h3 id="采样时间"><a href="#采样时间" class="headerlink" title="采样时间"></a>采样时间</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>初学者的PID被设计为不定期调用。这将会导致两个问题：</p>
<ul>
<li>你不会得到一个行为稳定的PID，因为有的时候你规则地调用它，而有的时候却不是。</li>
<li>你需要一个精确地计算微分和积分，因为他们每时每刻都在改变。</li>
</ul>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>确保PID在是被有规则的间隔调用。我决定采用的方法是在每个周期都去运行计算函数。基于一个预定义的采样时间，PID决定是否需要计算还是立即返回。</p>
<p>一旦我们知道PID是被以一个常量间隔进行定计算，那么微分和积分处理起来就简单了。福利！</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><img src="/uploads/2016/01/PID2016-01-25_134526.png" alt=""></p>
<p>在10和11行，算法现在决定计算时间是否到了。同样，因为我们知道每次采样时间都是相同的，我们不需要去乘以这个常数。我们只需要将Ki和Kd进行适当的合并，在数学上结果等同，但是更有效率。</p>
<p>不过还有一点问题。如果用户决定在操作期间更改采样时间，Ki和Kd都将需要重新计算以让新修改生效。39——42行就是处理这个问题的。</p>
<p>也要注意我将采样进间进行了转换在第29行。严格地讲这是不需要的，但是这允许用户输入Ki和Kd是以秒为单位（s），而不是毫秒(mS)。</p>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>以上的改变为我们做了三件事：</p>
<ol>
<li>不管以什么频率调用Compute（）函数，PID算法都将会以一个规则的间隔进行评估。</li>
<li>因为计算时间用了简法（行10），mills()回到0的时候将会有问题。每55天将会发生一次，但是要记得预防这种问题。</li>
<li>在我们再也不需要每个时间间隔都要进行乘法和除法。因为它是一个常量，我们能够把它从计算代码（行15 + 行16）移除，并将它以一个常数整定进参数中。数学上等效，但是它在每次PID进行评估的时候节省了乘法和除法运算。</li>
</ol>
<h4 id="关于中断的附注"><a href="#关于中断的附注" class="headerlink" title="关于中断的附注"></a>关于中断的附注</h4><p>如果PID用在一个微控制器中，非常好的一个争论就是是否在中断中使用它。让采样时间等于中断频率，每当时间到的时候进行计算。这样就不需要第9——12、23和24行。如果你计划这样实现你的PID，那么就这样干吧！但还是经计完这一系列。你仍然有希望对你后面的修改从中受益。这有几个我们为什么不用中断的原因：</p>
<ol>
<li>对于本系列而言，并不是每个人都会用到中断。</li>
<li>如果你想在同一时间实现多个PID控制器，在中断中实际会让这变得很麻烦。</li>
<li>说实话我没有想到这一点。当我校对我这个系列的时候Jimmie Rodgers建议我这么做。在将来的PID库中我可能会这么做。</li>
</ol>
<hr>
<h3 id="微分冲击"><a href="#微分冲击" class="headerlink" title="微分冲击"></a>微分冲击</h3><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>这次的修正主要是争对微分项进行改进，我们的目标是消除微分冲击。</p>
<p><img src="/uploads/2016/01/PID2016-01-25_134630.png" alt=""></p>
<p>上图展示了这个问题。因为error = Setpoint - Input,任何Setpoint（译者注：Setpoint就是你要稳定达到的预设值）的改变都会立即导致error的改变。这种改变会导致微分冲击（实际上，因为dt不是0所以这只会是一个很大而非无限大的数字）。这个数字反馈回PID方程，将会导致输出产生意想不到的毛刺。幸运的是这一点非常容易解决。</p>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p><img src="/uploads/2016/01/DonMExplain.png" alt=""></p>
<p>由于Setpoint是一个常数，所以由1式推出dError / dt = - dInput /dt。推导出Error的微份等于负的微分输入，只有当Setpoint改变时才不成立。<br>这就给出了一个完美的解决方案。我们用减去 Kd <em> 输出的微分 代替 加上 Kd </em> 误差的微分。这就是常说的“在测量上进行微分”。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p><img src="/uploads/2016/01/PID2016-01-25_140154.png" alt=""></p>
<p>修改代码就非常简单了，我们用+dError代替 -dInput。用存储lastInput代替存储lastError。</p>
<h4 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h4><p><img src="/uploads/2016/01/PID2016-01-25_140237.png" alt=""></p>
<p>上面就是修正后我们得到的结果。注意输入看起来是一样的。我们获得了同样能，但是我们没有在每次Setpoint改变的时候导致一个巨大的毛刺。</p>
<p>这是否是一个好主意，完全取决于你的应用对输出毛刺有多敏感。办法看起来行得通，它没有为解决问题做任何更多的工作，因此为什么不这么干呢？</p>
<hr>
<h3 id="修改参数"><a href="#修改参数" class="headerlink" title="修改参数"></a>修改参数</h3><h4 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h4><p>对于任何一个还算可以的PID算法都必须让系统有在线调试参数的能力。</p>
<p><img src="/uploads/2016/01/PID2016-01-25_140336.png" alt=""></p>
<p>当你在线调整参数的时候初学者写的PID动作起来像疯了似的。让我们看看这是为什么。下面是初学者PID参数改变前后的状态：</p>
<p><img src="/uploads/2016/01/PID2016-01-25_140448.png" alt=""></p>
<p>我们很快就能将这种震荡归因于积分项（或者 “I项”）。当参数改变时积分项是唯一大幅改变的项。为什么会这样？这得去看看初学者是怎么处理积分项的。</p>
<p><img src="/uploads/2016/01/PIDE2016-01-25_140516.png" alt=""></p>
<p>直到Ki被改变前积分项都工作得很好。然后，突然之间，你将这个新的Ki乘以了全部error的累加和。这不是我们想要的！我们只是想影响将来发生的事（过去的误差不应被乘以这个Ki）。</p>
<h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><p>处理这个问题我有几个办法。在最新的库里面我用的方法是重新调整errSum.乘以Ki?将errSum减半。那样让I项远离震荡，工作良好。尽管这是一种笨拙的办法，还好我找到了更优雅的办法（没办法我一开始并没有想到这一点，但是我还是自己想到了它。真该列！）。</p>
<p>解决方案要求一点基础的代数知识（或微积分）</p>
<p><img src="/uploads/2016/01/PID2016-01-25_140710.png" alt=""></p>
<p>我们将Ki移到积分号的里面代替原先Ki在积分号外面的情况。看起来我们什么也没干，但是我们将会明白实际上这里有一个巨大的改变。</p>
<p>现在，我们依据是否在那个时间乘以Ki。我们然后我们存储那个和。当Ki改变的时候，不会有震荡产生，因为老的Ki仍在起作用。我们得到了一个平滑的输出，而且没有其它的附加数学运算。它可能让我看起来像一个极客，但是我认为这非常的屌！</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><p><img src="/uploads/2016/01/PID2016-01-25_140729.png" alt=""></p>
<p>那么我们将errSum变量用一个复合的ITerm变量代替（第4行）。它等于Ki * error的累加和,而不只是error(第15行)。还有，因为Ki现在被包含在了了ITerm中，所以必须从主的PID算式中移除（第19行）。</p>
<h4 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h4><p><img src="/uploads/2016/01/PID2016-01-25_140820.png" alt=""></p>
<p>那么这个问题得到了很好的修复。当Ki被改变时，重新计算了整个的erro和；仅针我们遇到的每一个error值。在这个代码中，之前的error不变，新的Ki仅针对从这一刻起的error,这正是我们想要的。</p>
<hr>
<h3 id="积分饱和"><a href="#积分饱和" class="headerlink" title="积分饱和"></a>积分饱和</h3><h4 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h4><p><img src="/uploads/2016/01/PID2016-01-25_140942.png" alt=""></p>
<p>积分饱和是一个比其它问题让初学者更需要认真对待的陷阱。它发生在PID认为自己能做点什么但实际上它不能那么做的时候。举个例子，Arduino能够接受的PWM输出是0——255。默认情况下PID并不知道这一点。如果它认为300——400——500都能够工作，那么它将会去尝试这些我们不希望采用的值。因为现实中值将被钳位在255，仅需要保持不去尝试越来越高的值即可。</p>
<p>这个问题以怪异的滞后表现自己。如上，我们看到输出饱和了远远高于外部限制。当setpoint下降的时候，输出必须在抵达255这条线前逐渐减小。</p>
<h4 id="解决方案第1步"><a href="#解决方案第1步" class="headerlink" title="解决方案第1步"></a>解决方案第1步</h4><p>有几种办法可以缓解饱和，我选择的办法如下：告诉PID输出限制是多少。在下面的代码中你将会看到现在有一个SetOutputLimits函数。一旦抵达限制，PID将会停止求和（积分）。它知道没什么事可做，因为输出已经饱和了，当setpoing下降到一定范围内我们可以做点什么时我们将立即得到响应。</p>
<p><img src="/uploads/2016/01/PID2016-01-25_141021.png" alt=""></p>
<h4 id="解决方案第2步"><a href="#解决方案第2步" class="headerlink" title="解决方案第2步"></a>解决方案第2步</h4><p>注意上图，当我们摆脱了积分滞后性之后，我们并没有将这条路走完。在PID认为它在发送的和实际上发送的之间仍有差异。为什么？因为比例项和（程度较小）微公项的原因。</p>
<p>尽管积分项已经被安全的钳位了，P和D仍然在发挥他们的两个影响，得到的结果将比输出限制要高。这对我来说是不可接受的。如果用户调用了函数SetOutputLimits，那么他们是假定输出必须在这个值以内。因此，第二步是我们作了一个有效的假设。除了钳位积分项，我们还钳位了输出值让它待在我们期望的范围内。</p>
<p>（注意，你可能问为什么我去要两个都钳位。我们在任何情况下都钳位了输出，为什么还要钳位积分项？如果我们所做的只有钳位输出，那么积分项将会一直增长。尽管在饱和时输出看起来非常漂亮，但是我们将会看到下降滞后了（译者注：意思大概就是说如果没有钳位积分项，那么在输出本该下降的时候却因为一直在增长的积分项的值很大而导致输出滞后了）。）</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><p><img src="/uploads/2016/01/PID2016-01-25_141121.png" alt=""></p>
<p>加入了一个允许用户约束输出的新函数（52行-63行）。这些限制被加在积分项（17——18行）和输出上（23——24行）。</p>
<h4 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h4><p><img src="/uploads/2016/01/PID2016-01-25_141157.png" alt=""></p>
<p>如我们所看到的，饱和被消除了。此外输出也落在了我们所希望的地方。这意味着我们不需在外部钳位输出。如果你想让输出落在23——167的范围内，你可以将它们设为出输限制值。</p>
<hr>
<h3 id="开关机"><a href="#开关机" class="headerlink" title="开关机"></a>开关机</h3><h4 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h4><p>PID控制器看起来很不错，有时候你都不必关心它想说什么。</p>
<p><img src="/uploads/2016/01/PID2016-01-25_141228.png" alt=""></p>
<p>比方说，在你程序的有些地方你想强制输出为一个定值（比如0），你当然可以像下面这个函数这样做：</p>
<pre><code>void loop()
{
Compute();
Output=0;
}
</code></pre><p>这种方式，不关心PID想说什么，你仅仅是覆盖它的值。然而在实践中这是一个可怕的主意。PID控制器将会非常困惑：“我持续地输出，但是它妈的什么都没有发生？该怎么搞？还是让我再多输出一些吧。”结果，当你停止覆盖PID的输出，并且切换到PID，你将会在输出值上得到一个巨大的瞬变。</p>
<h4 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h4><p>解决这个问题的办法就是明确地告诉PID开或者关。称呼这两个状态常用的术语是“手动”（我将会自己手动去判断这个值）和“自动”（PID将会自动的判定输出）。让我们看看在代码中该怎么做：</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><p><img src="/uploads/2016/01/PID2016-01-25_141325.png" alt=""></p>
<p>一个相当简单的解决方法。如果你不是在自动模式，立即停止Compute函数，不需在考虑输出或是任何的内部变量。</p>
<h4 id="结果-4"><a href="#结果-4" class="headerlink" title="结果"></a>结果</h4><p><img src="/uploads/2016/01/PID2016-01-25_141402.png" alt=""></p>
<p>显然你可以获得一个类似的作用，只要在不在调用函数里面不调用Compute函数即可，但是这个方案会保留PID内部的工作参数，这正是我们想要的方法。通过保持内部的工作参数，我们可以确认我们处在什么模式下，并且更重要的是当模式改变时我们也会知道。那么让我们开始下一节吧……….</p>
<hr>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在上一节里面，我们实现了对PID的开关。我们关了它，但是让我们看看当然们再次打开它的时候会发生什么：</p>
<p><img src="/uploads/2016/01/PID2016-01-25_141440.png" alt=""></p>
<p>哎呀！PID控制器只是跳回到上次它输出的值那里，然后从那里开始进行判断。结果导致Input产生了一个我们不希望有的坎。</p>
<h4 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h4><p>有一个简单漂亮的办法去修复这个部题。因为我们知道什么时候我们会打开（从手动切到自动），我们只要为平滑过渡初始化一些参数。那意味着需要存储两个工作变量（ITerm和lastInput）去让输出远离那个坎。</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><p><img src="/uploads/2016/01/PID2016-01-25_141607.png" alt=""></p>
<p>我们修改了SetMode(…)函数，让它可以检测从手动到自动的转变，并且我们增加了一个初始化函数。它让ITerm = Output,而不关心内部的积分项，并且lastInput = Input让输出平滑。比例项不依赖过去的任何信息，因此它不需要任何的初始化。</p>
<h4 id="结果-5"><a href="#结果-5" class="headerlink" title="结果"></a>结果</h4><p><img src="/uploads/2016/01/PID2016-01-25_141723.png" alt=""></p>
<p>从上图我们看到正确的初始化会让从手动切换到自动时没有波动：正是我们希望的。</p>
<h4 id="更新：为什么不是ITerm-0"><a href="#更新：为什么不是ITerm-0" class="headerlink" title="更新：为什么不是ITerm = 0?"></a>更新：为什么不是ITerm = 0?</h4><p>最近收到很多人问我为什么不让ITerm = 0 作为初始化。答案是，我将会问你考虑一下以下的情景：PID在手动模式，然后用户让输出值为50。过了一会，该过程持续稳定地输出，对应输入为75.2。用户将Setpoint设为75.2并且开启了PID，将会发生什么？</p>
<p>我认为在切换到自动模式后，输出将仍然会是50。因为P和D项都将为0，这种情况出现的唯一办法就是将ITerm初始化为Output。</p>
<p>如果你的方案中需要将输出初始化为0，不要在上面代码的后面这么干。只要将PID从手动切换为自动前在你的调用函数中将Output = 0 。</p>
<hr>
<h3 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h3><h4 id="问题-5"><a href="#问题-5" class="headerlink" title="问题"></a>问题</h4><p>PID控制器需要有两种处理过程：正向和反向。所有我给你看的例子都还是正向的。就是，输出的增加会导致输入的增加。反向过程正好相反。例如在冰箱中，增加制冷会使温度更进一步下降。让初学者PID控制器能够在反向时依然能工作，埯机将Kp, Ki 和Kd全部取为负数。</p>
<p>这本身并不是一个问题，但用户必须选择正确的符号，并确保所有的参数符号相同。</p>
<h4 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h4><p>为了让过程更简单一点，我要求所有的Kp, Ki 和Kd 都 &gt;= 0。如果用户想要连接一个反向过程，他们需要单独调用SetControllerDirection函数。这将确保所有的参数有相同的符号，希望这能让事情得更直观。</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><p><img src="/uploads/2016/01/PID2016-01-25_141827.png" alt=""></p>
<h4 id="PID结束语"><a href="#PID结束语" class="headerlink" title="PID结束语"></a>PID结束语</h4><p>将上面讲的所有这些组合起来，我们就能将初学者PID控制器转变成一个能用在目前就我所知的大多数机器人控制器中。对于那些希望了解PID库细节的读者，我希望你们来对了地方。对于那些希望自己写PID的读者，我希望你能从我这里得到一些点子而少走一点弯路。</p>
<p>最后注意两点：</p>
<ol>
<li><p>如果在这个系列里面有什么错误请告知我。我可能忘记了什么，或者解释得不够清楚。总之让我知道吧。</p>
</li>
<li><p>这只是一个基本的PID。正如其名为了简单还有很多问题我特意没有处理。浮现在我脑海里的有这么几个：前馈，reset tiebacks（怎么译？），整数运算，差分PID形式，用增量式代替位置式。如果希望我对这些展开请告诉我。</p>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/MCU-ARM/">MCU/ARM</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e8-bf-90-e6-94-be-e5-a4-8d-e4-b9-a0-e7-ac-94-e8-ae-b0" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/18/e8-bf-90-e6-94-be-e5-a4-8d-e4-b9-a0-e7-ac-94-e8-ae-b0/" class="article-date">
      <time datetime="2016-01-18T07:38:00.000Z" itemprop="datePublished">2016-01-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/18/e8-bf-90-e6-94-be-e5-a4-8d-e4-b9-a0-e7-ac-94-e8-ae-b0/">运放复习笔记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>好久没搞过运放了，今天复习一下。</p>
<p>对于运放最简单的理想分析无非两点：虚短和虚断。在说虚短和虚短之前我们得先知道仅仅当运放处于线性区时才能利用虚短和虚断进行分析，那么如何知道运放是否工作在线性区？就我个人经验，无非两种方式：</p>
<ol>
<li><strong>理论型：</strong>假定其工作在线性区，然后通过计算确认运放的输出VO是否会大于运放的供电电压VDD。</li>
<li><strong>实践型：</strong>用仪表测得+P和-P的电压如果大于1mV（该数值与具体器件相关），运放可能工作在饱和区，当然它也可以坏掉了。</li>
</ol>
<p>那么下面再来说说企么是虚短和虚断：</p>
<ul>
<li><strong>虚短</strong>——运放的+P和-P之间的电位相等（实际上是有很小的电位差，比如小于1mV）。</li>
<li><strong>虚断</strong>——运放的+P和-P之间的电流为零(实际是有很微弱的电流，如果二者之间的电压差是1mV,而运放本身的阻抗通常都是兆欧，你自己算算这电流有多小)。</li>
</ul>
<p>这就是能常所说的虚短和虚断，感觉两句话好像是一个意思，显得很废话。我倒是更喜欢老外的直白。《the art of electronics》中有以下说法：</p>
<blockquote>
<p>1、The output attempts to do whatever is necessary to make the voltage difference between the inputs zero.<br>  2、The inputs draw no current.<br>  One important note of explanation: Golden rule I doesn’t mean that the opamp acturally changes the voltage at its inputs.It can’t do that.(How could it,and be consistent with golden rule Ⅱ?) What it does is “look” at its input terminals and swing its output terminal around so that the external feedback network brings the input differential to zero (if possible)</p>
</blockquote>
<p>上面标出的第一二两点显得更实用：<br>1、运放的两个输入端总会趋于相等（这应该是由引入负反馈产生的一个动态调整的过程）。<br>2、运放的输入端可以认为没有电流输入，因为阻抗很大，相比于外部电路其电流可以忽略（记得在分析三极管电路时我们也认为Ib几乎为0）。</p>
<p>有了上面两点，分析起来就好说了，拿常用的运放电路图进行分析：</p>
<p><a href="/uploads/2016/01/op-amplify1.jpg"><img src="/uploads/2016/01/op-amplify1-300x229.jpg" alt="op amplify1"></a></p>
<p>图1中由于V-等于V+所以V-可以认为是地，而-P这一端没有电流输入那么R1和R2上的电流大小是一样的，但流向相反，所以VI和Vout相对于V-（GND）点的电压就是与R1和R2成正比。所以VO = - Vi &#42; R2/R1 。</p>
<p><a href="/uploads/2016/01/op-amplify2.jpg"><img src="/uploads/2016/01/op-amplify2-255x300.jpg" alt="op amplify2"></a></p>
<p>图2中一样的道理，R2与R1中间这一点的电压等于Vi，所以VOUT = Vi &#42; (R1+R2) / R2。</p>
<p><a href="/uploads/2016/01/op-amplify3.jpg"><img src="/uploads/2016/01/op-amplify3-300x227.jpg" alt="op amplify3"></a></p>
<p>图3假定R1、R2、R3电阻相同，那么V-=V+=GND，由R3流入GND的电流大小等于由R1和R2流入电流之和，方向相反，而R1、R2、R3相等，那么R3的电压必然是-(V1+V2)。</p>
<p><a href="/uploads/2016/01/op-amplify4.jpg"><img src="/uploads/2016/01/op-amplify4-300x203.jpg" alt="op amplify4"></a></p>
<p>图4中假定R1=R2,R4=43。既然没和电流注入+P，那么V+点的电压为（V1+V2）/2。同理V-点的电压也为（V1+V2）/2，那么Vo显然只能等于V1+V2了。</p>
<p><a href="/uploads/2016/01/op-amplify5.jpg"><img src="/uploads/2016/01/op-amplify5-300x274.jpg" alt="op amplify5"></a></p>
<p>图5假定R1=R2,R4=43。既然没有电流注入+P，那么V+ = V2/2，V-也为V2/2。而同时V-=（V1+Vout）/2，所以VOUT= V2 - V1。</p>
<p><a href="/uploads/2016/01/op-amplify6.jpg"><img src="/uploads/2016/01/op-amplify6-300x217.jpg" alt="op amplify6"></a></p>
<p>图6就是将输出在C1上进行积分。</p>
<p><a href="/uploads/2016/01/op-amplify7.jpg"><img src="/uploads/2016/01/op-amplify7-300x206.jpg" alt="op amplify7"></a></p>
<p>图7就是将输入在C1上进行微分。</p>
<p><a href="/uploads/2016/01/op-amplify8.jpg"><img src="/uploads/2016/01/op-amplify8-300x266.jpg" alt="op amplify8"></a></p>
<p>图8咱们先看从R4和R6这里开始，即视Vo1和Vo2，图的右边是不是跟图5一样，是个减法器Vout = Vo2 - Vo1。那么再看Vo2 - Vo1等于多少？显然Vx = V1, Vy = V2,Vo1-Vo2=I*(R1+R2+R3) = (Vx-Vy)(R1+R2+R3)/R2 = (V1-V2) (R1+R2+R3)/R2。</p>
<p><a href="/uploads/2016/01/op-amplify9.jpg"><img src="/uploads/2016/01/op-amplify9-300x186.jpg" alt="op amplify9"></a></p>
<p>图9，V1-Vx = (R2/R4) （Vx - Vo）, V2 - Vy = (R3/R5) Vy, 式中Vx = Vy, R2/R4 = R3/R5， 那么 Vo = (R4/42)/(V2-V1),而V2-V1上的电压即为R1上的差分电压。</p>
<p><a href="/uploads/2016/01/op-amplify10.jpg"><img src="/uploads/2016/01/op-amplify10-300x212.jpg" alt="op amplify10"></a></p>
<p>图10，假定RL远小于 100K的话，由于没有电流注入运放，那么V1=Vi/2,而V2=V3/2，而V1=V2，那么V3 = Vi,由于RL远小于100K，那么R7上流过的电流正比于Vi。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/硬件设计/">硬件设计</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-qmodbus-e5-9c-a8visual-studio-e4-b8-ad-e7-9a-84-e7-bc-96-e8-af-91-e3-80-82" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/12/qmodbus-e5-9c-a8visual-studio-e4-b8-ad-e7-9a-84-e7-bc-96-e8-af-91-e3-80-82/" class="article-date">
      <time datetime="2016-01-12T01:58:46.000Z" itemprop="datePublished">2016-01-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/12/qmodbus-e5-9c-a8visual-studio-e4-b8-ad-e7-9a-84-e7-bc-96-e8-af-91-e3-80-82/">qmodbus在visual studio中的编译。</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>MINGW的编译我没弄过，直接上VISUAL STUDIO。原本对QT也不熟。费了些时间整出来，记下来。</p>
<p>1.修改C为变量定义在函数首，不知道如何在QT中启用C99。<br>2.pro文件中    QT += widgets 修改为QT += webkitwidgets,参考《Porting C++ Applications to Qt 5》<br><a href="/uploads/2016/01/qmodbus_visualstdio.png"><img src="/uploads/2016/01/qmodbus_visualstdio-300x164.png" alt="qmodbus_visualstdio"></a><br>3.工程中所有的#include <qtwebkit>替换为#include <qtwebkitwidgets>，参考《Porting C++ Applications to Qt 5》<br>4.工程中所有的#include &lt;qwineventnotifier_p.h&gt;替换为#include &lt;qwineventnotifier.h&gt;<br>5.在qextserialenumerator_win.cpp中添加 #pragma comment(lib,”user32”)，#pragma comment(lib,”Advapi32.lib”)。<br><a href="/uploads/2016/01/qmodbus_visualstdio2.png"><img src="/uploads/2016/01/qmodbus_visualstdio2-300x123.png" alt="qmodbus_visualstdio2"></a></qtwebkitwidgets></qtwebkit></p>
<p>最后看一看生成的程序。<strong>从sourceforge上下载的QMODBUS的可执行程序和我编译生成的QMODBUS是一不一样的，我编译生成这个功能更强大，包含MODBUS RTU、MODBUS TCP、MODBUS ASCII，可能由于我用的源码是较新版本的原因。</strong></p>
<p><a href="/uploads/2016/01/2016-01-13_094752.png"><img src="/uploads/2016/01/2016-01-13_094752-300x184.png" alt="2016-01-13_094752"></a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/windows-linux/">windows\linux</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e8-b6-85-e9-ab-98-e9-80-9f-e9-ab-98-e7-b2-be-e5-ba-a6-e7-ba-a2-e5-a4-96-e6-b5-8b-e5-be-84-e4-bb-aa-e7-ac-ac-e4-b8-89-e7-89-88" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/10/e8-b6-85-e9-ab-98-e9-80-9f-e9-ab-98-e7-b2-be-e5-ba-a6-e7-ba-a2-e5-a4-96-e6-b5-8b-e5-be-84-e4-bb-aa-e7-ac-ac-e4-b8-89-e7-89-88/" class="article-date">
      <time datetime="2016-01-10T03:43:29.000Z" itemprop="datePublished">2016-01-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/10/e8-b6-85-e9-ab-98-e9-80-9f-e9-ab-98-e7-b2-be-e5-ba-a6-e7-ba-a2-e5-a4-96-e6-b5-8b-e5-be-84-e4-bb-aa-e7-ac-ac-e4-b8-89-e7-89-88/">超高速高精度红外测径仪第三版</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>真是生命不息，改版不止啊。</p>
<p><a href="/uploads/2016/01/2016-01-10_114150.png"><img src="/uploads/2016/01/2016-01-10_114150-300x121.png" alt="2016-01-10_114150"></a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/硬件设计/">硬件设计</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e5-a6-82-e4-bd-95-e8-af-bb-e6-87-82git-e7-9a-84diff-e4-bf-a1-e6-81-af" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/08/e5-a6-82-e4-bd-95-e8-af-bb-e6-87-82git-e7-9a-84diff-e4-bf-a1-e6-81-af/" class="article-date">
      <time datetime="2016-01-08T02:17:06.000Z" itemprop="datePublished">2016-01-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/08/e5-a6-82-e4-bd-95-e8-af-bb-e6-87-82git-e7-9a-84diff-e4-bf-a1-e6-81-af/">如何读懂GIT的DIFF信息</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><a href="/uploads/2016/01/git_diff.png"><img src="/uploads/2016/01/git_diff-300x184.png" alt="git_diff"></a></p>
<p>输入git diff后就会显示DIFF信息，由于GIT的DIFF信息并不是标准的UNIX信息，而是一种合并DIFF信息的变体。以下例进行说明。</p>
<pre><code>diff --git a/readme.txt b/readme.txt
index 00388d0..055c47b 100644
--- a/readme.txt
+++ b/readme.txt
@@ -1 +1,2 @@
-git learn.
\ No newline at end of file
+git learn.
+asdfasdf
\ No newline at end of file
</code></pre><ul>
<li><p><code>diff --git a/readme.txt b/readme.txt</code> 中diff –git表示这是GIT版本的DIFF信息，a/readme.txt b/readme.txt这个就表示版本要比较的a\b版本都是readme.txt文件。</p>
</li>
<li><p><code>index 00388d0..055c47b 100644</code>中00388d0..055c47b表示文件的哈希值，即要比较的文件的哈希开头分别是00388d0和055c47b ， 644表示普通权限，这一条信息通常我并不怎么关注。</p>
</li>
<li><p>— a/readme.txt中—表示a的原版本文件是readme.txt。</p>
</li>
<li><p>+++ b/readme.txt中+++给示新产生的b版本文件也是readme.txt。</p>
</li>
<li>@@ -1 +1,2 @@这一行，-1给示原文件的第1行变动了（-表示原文件）， +1，2表示新文件从第一行开始共2行变动了（+表示变动后的文件）。</li>
<li>-git learn.表示原文件的git learn这一行被删除了，-表示删除。</li>
<li>+git learn.以及+asdfasdf表示b版本中新增了这两行，+表示增加。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/windows-linux/">windows-linux</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-freemodbus-e6-ba-90-e7-a0-81-e5-88-86-e6-9e-90-e8-af-a6-e8-a7-a3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/06/freemodbus-e6-ba-90-e7-a0-81-e5-88-86-e6-9e-90-e8-af-a6-e8-a7-a3/" class="article-date">
      <time datetime="2016-01-06T07:37:47.000Z" itemprop="datePublished">2016-01-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/06/freemodbus-e6-ba-90-e7-a0-81-e5-88-86-e6-9e-90-e8-af-a6-e8-a7-a3/">freemodbus源码分析详解</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>我这里为了方便代码浏览，用了VS2013，DEMO自然用WIN32的，选用哪个DEMO进行分析也并不影响我们对FREEMODBUS的解剖。</p>
<h3 id="代码组织结构"><a href="#代码组织结构" class="headerlink" title="代码组织结构"></a>代码组织结构</h3><p><img src="/uploads/2016/01/freemodbus_source_analysis.png" alt="freemodbus_source_analysis"></p>
<p>首先是modbus这个大文件下的文件：</p>
<ul>
<li><strong>ascii</strong>目录的文件是用于实现MODBUS ASCII模式的，这个在modbus里是可选实现代码比较简单，看完RTU的分析我相信你对比着自己也就看明白ASCII模式了，这将不是本文的重点。</li>
<li><strong>funcions</strong>是与RTU的执行功能码相关的代码，主要就是读、写寄存器开关线圈之类的，根据你自己的需要在去实现里面回调，按照相应参数去执行相应功能。</li>
<li><strong>include</strong>是freemodbus的一些定义，这里先不作分析，在看源代码的时候我们再去看每个数据结构的相关定义。</li>
<li><strong>rtu</strong>这个文件夹就是RTU模式的实现了，本文分析重点之一。</li>
<li><strong>port这个是移植相关</strong>，port.h是移植需要的函数声明。portevent.c这个是事件队列的实现，freemodbus只是用了一个消息作为队列简单赋值处理，portother.c是一相从字节里取位等与MODBUS没多大关系的函数，portserial.c是串口移植相关函数，porttimer.c是定时器相关移植（由于RTU方式依赖时间来判断帧头帧尾），移植相关可以参见我的另一篇博文(译自官方文档)<a href="http://www.hex55.com/2016/01/05/freemodbus-rtuascii-%E5%AE%98%E6%96%B9%E7%A7%BB%E6%A4%8D%E6%96%87%E6%A1%A3/" target="_blank" rel="external">freemodbus RTU/ASCII 官方移植文档</a>。</li>
<li><p><strong>mb.c</strong>这个就是modbus的应用层实现，本文分析重点之一。</p>
<p>Source Files目录中的demo.cpp是例程，stdafx.cpp是WIN32的预编译文件与modbusfree无关。</p><p></p>
</li>
</ul>
<h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><h4 id="win32的main（）分析，不感兴趣直接跳到mb-c一节"><a href="#win32的main（）分析，不感兴趣直接跳到mb-c一节" class="headerlink" title="win32的main（）分析，不感兴趣直接跳到mb.c一节"></a>win32的main（）分析，不感兴趣直接跳到<em>mb.c</em>一节</h4><p></p><p>一切还是从main开始吧。</p>
<pre><code>int
_tmain( int argc, _TCHAR * argv[] )
{
    int             iExitCode;
    TCHAR           cCh;
    BOOL            bDoExit;

    const UCHAR     ucSlaveID[] = { 0xAA, 0xBB, 0xCC };

    if( eMBInit( MB_RTU, 0x01, 1, 115200, MB_PAR_EVEN ) != MB_ENOERR )
    {
        _ftprintf( stderr, _T( &quot;%s: can&apos;t initialize modbus stack!\r\n&quot; ), PROG );
        iExitCode = EXIT_FAILURE;
    }
    else if( eMBSetSlaveID( 0x34, TRUE, ucSlaveID, 3 ) != MB_ENOERR )
    {
        _ftprintf( stderr, _T( &quot;%s: can&apos;t set slave id!\r\n&quot; ), PROG );
        iExitCode = EXIT_FAILURE;
    }
    else
    {
        /* Create synchronization primitives and set the current state
         * of the thread to STOPPED.
         */
        InitializeCriticalSection( &amp;amp;hPollLock );
        eSetPollingThreadState( STOPPED );

        /* CLI interface. */
        _tprintf( _T( &quot;Type &apos;q&apos; for quit or &apos;h&apos; for help!\r\n&quot; ) );
        bDoExit = FALSE;
        do
        {
            _tprintf( _T( &quot;&amp;gt; &quot; ) );
            cCh = _gettchar(  );
            switch ( cCh )
            {
            case _TCHAR( &apos;q&apos; ):
                bDoExit = TRUE;
                break;
            case _TCHAR( &apos;d&apos; ):
                eSetPollingThreadState( SHUTDOWN );
                break;
            case _TCHAR( &apos;e&apos; ):
                if( bCreatePollingThread(  ) != TRUE )
                {
                    _tprintf( _T( &quot;Can&apos;t start protocol stack! Already running?\r\n&quot; ) );
                }
                break;
            case _TCHAR( &apos;s&apos; ):
                switch ( eGetPollingThreadState(  ) )
                {
                case RUNNING:
                    _tprintf( _T( &quot;Protocol stack is running.\r\n&quot; ) );
                    break;
                case STOPPED:
                    _tprintf( _T( &quot;Protocol stack is stopped.\r\n&quot; ) );
                    break;
                case SHUTDOWN:
                    _tprintf( _T( &quot;Protocol stack is shuting down.\r\n&quot; ) );
                    break;
                }
                break;
            case _TCHAR( &apos;h&apos; ):
                _tprintf( _T( &quot;FreeModbus demo application help:\r\n&quot; ) );
                _tprintf( _T( &quot;  &apos;d&apos; ... disable protocol stack.\r\n&quot; ) );
                _tprintf( _T( &quot;  &apos;e&apos; ... enabled the protocol stack\r\n&quot; ) );
                _tprintf( _T( &quot;  &apos;s&apos; ... show current status\r\n&quot; ) );
                _tprintf( _T( &quot;  &apos;q&apos; ... quit applicationr\r\n&quot; ) );
                _tprintf( _T( &quot;  &apos;h&apos; ... this information\r\n&quot; ) );
                _tprintf( _T( &quot;\r\n&quot; ) );
                _tprintf( _T( &quot;Copyright 2006 Christian Walter &amp;lt;wolti@sil.at&amp;gt;\r\n&quot; ) );
                break;
            default:
                if( cCh != _TCHAR(&apos;\n&apos;) )
                {
                    _tprintf( _T( &quot;illegal command &apos;%c&apos;!\r\n&quot; ), cCh );
                }
                break;
            }

            /* eat up everything untill return character. */
            while( cCh != &apos;\n&apos; )
            {
                cCh = _gettchar(  );
            }
        }
        while( !bDoExit );

        /* Release hardware resources. */
        ( void )eMBClose(  );
        iExitCode = EXIT_SUCCESS;
    }
    return iExitCode;
}

`&lt;/pre&gt;

eMBInit( MB_RTU, 0x01, 1, 115200, MB_PAR_EVEN ) != MB_ENOERR 初始化modbus协议栈，如果实始化失败则打印错误信息并退出，否则打印命令提示符，要求输入指令。

&lt;pre&gt;`
       do
        {
            _tprintf( _T( &quot;&amp;gt; &quot; ) );
            cCh = _gettchar(  );
            switch ( cCh )
            {
            case _TCHAR( &apos;q&apos; ):
                bDoExit = TRUE;
                break;
            case _TCHAR( &apos;d&apos; ):
                eSetPollingThreadState( SHUTDOWN );
                break;
            case _TCHAR( &apos;e&apos; ):
                if( bCreatePollingThread(  ) != TRUE )
                {
                    _tprintf( _T( &quot;Can&apos;t start protocol stack! Already running?\r\n&quot; ) );
                }
                break;
            case _TCHAR( &apos;s&apos; ):
                switch ( eGetPollingThreadState(  ) )
                {
                case RUNNING:
                    _tprintf( _T( &quot;Protocol stack is running.\r\n&quot; ) );
                    break;
                case STOPPED:
                    _tprintf( _T( &quot;Protocol stack is stopped.\r\n&quot; ) );
                    break;
                case SHUTDOWN:
                    _tprintf( _T( &quot;Protocol stack is shuting down.\r\n&quot; ) );
                    break;
                }
                break;
            case _TCHAR( &apos;h&apos; ):
                _tprintf( _T( &quot;FreeModbus demo application help:\r\n&quot; ) );
                _tprintf( _T( &quot;  &apos;d&apos; ... disable protocol stack.\r\n&quot; ) );
                _tprintf( _T( &quot;  &apos;e&apos; ... enabled the protocol stack\r\n&quot; ) );
                _tprintf( _T( &quot;  &apos;s&apos; ... show current status\r\n&quot; ) );
                _tprintf( _T( &quot;  &apos;q&apos; ... quit applicationr\r\n&quot; ) );
                _tprintf( _T( &quot;  &apos;h&apos; ... this information\r\n&quot; ) );
                _tprintf( _T( &quot;\r\n&quot; ) );
                _tprintf( _T( &quot;Copyright 2006 Christian Walter &amp;lt;wolti@sil.at&amp;gt;\r\n&quot; ) );
                break;
            default:
                if( cCh != _TCHAR(&apos;\n&apos;) )
                {
                    _tprintf( _T( &quot;illegal command &apos;%c&apos;!\r\n&quot; ), cCh );
                }
                break;
            }

            /* eat up everything untill return character. */
            while( cCh != &apos;\n&apos; )
            {
                cCh = _gettchar(  );
            }
        }
        while( !bDoExit );

`&lt;/pre&gt;

如果用户输入e,则会调用bCreatePollingThread(  )启动协议栈线程。那么我们跟进bCreatePollingThread(  )去看看。

&lt;pre&gt;`
BOOL
bCreatePollingThread( void )
{
    BOOL            bResult;

    if( eGetPollingThreadState(  ) == STOPPED )
    {
        if( ( hPollThread = CreateThread( NULL, 0, dwPollingThread, NULL, 0, NULL ) ) == NULL )
        {
            /* Can&apos;t create the polling thread. */
            bResult = FALSE;
        }
        else
        {
            bResult = TRUE;
        }
    }
    else
    {
        bResult = FALSE;
    }

    return bResult;
}

`&lt;/pre&gt;

先是确认一下线程状态，然后创建并启动线程函数dwPollingThread（），

&lt;pre&gt;`
DWORD           WINAPI
dwPollingThread( LPVOID lpParameter )
{
    eSetPollingThreadState( RUNNING );

    if( eMBEnable(  ) == MB_ENOERR )
    {
        do
        {
            if( eMBPoll(  ) != MB_ENOERR )
                break;
        }
        while( eGetPollingThreadState(  ) != SHUTDOWN );
    }

    ( void )eMBDisable(  );

    eSetPollingThreadState( STOPPED );

    return 0;
}

`&lt;/pre&gt;

从这里就跟MCU\ARM上应用freemodbus一样一样的了，无法是先使能协议栈，然后循环调用eMBPoll(  )，同时用eGetPollingThreadState（）检测线程状态。eMBPoll( void )就是我们的重点咯，我们现在已经进入mb.c这个文件啦，这个是freemodbus实现的modbus应用层，虽然代码里面对数据链路层以及应用层分的不是很清晰，但这个mb.c是完完全全的应用层了。

#### mb.c

&lt;pre&gt;`
eMBErrorCode
eMBPoll( void )
{
    static UCHAR   *ucMBFrame;
    static UCHAR    ucRcvAddress;
    static UCHAR    ucFunctionCode;
    static USHORT   usLength;
    static eMBException eException;

    int             i;
    eMBErrorCode    eStatus = MB_ENOERR;
    eMBEventType    eEvent;

    /* Check if the protocol stack is ready. */
    if( eMBState != STATE_ENABLED )
    {
        return MB_EILLSTATE;
    }

    /* Check if there is a event available. If not return control to caller.
     * Otherwise we will handle the event. */
    if( xMBPortEventGet( &amp;amp;eEvent ) == TRUE )
    {
        switch ( eEvent )
        {
        case EV_READY:
            break;

        case EV_FRAME_RECEIVED:
            eStatus = peMBFrameReceiveCur( &amp;amp;ucRcvAddress, &amp;amp;ucMBFrame, &amp;amp;usLength );
            if( eStatus == MB_ENOERR )
            {
                /* Check if the frame is for us. If not ignore the frame. */
                if( ( ucRcvAddress == ucMBAddress ) || ( ucRcvAddress == MB_ADDRESS_BROADCAST ) )
                {
                    ( void )xMBPortEventPost( EV_EXECUTE );
                }
            }
            break;

        case EV_EXECUTE:
            ucFunctionCode = ucMBFrame[MB_PDU_FUNC_OFF];
            eException = MB_EX_ILLEGAL_FUNCTION;
            for( i = 0; i &amp;lt; MB_FUNC_HANDLERS_MAX; i++ )
            {
                /* No more function handlers registered. Abort. */
                if( xFuncHandlers[i].ucFunctionCode == 0 )
                {
                    break;
                }
                else if( xFuncHandlers[i].ucFunctionCode == ucFunctionCode )
                {
                    eException = xFuncHandlers[i].pxHandler( ucMBFrame, &amp;amp;usLength );
                    break;
                }
            }

            /* If the request was not sent to the broadcast address we
             * return a reply. */
            if( ucRcvAddress != MB_ADDRESS_BROADCAST )
            {
                if( eException != MB_EX_NONE )
                {
                    /* An exception occured. Build an error frame. */
                    usLength = 0;
                    ucMBFrame[usLength++] = ( UCHAR )( ucFunctionCode | MB_FUNC_ERROR );
                    ucMBFrame[usLength++] = eException;
                }
                if( ( eMBCurrentMode == MB_ASCII ) &amp;amp;&amp;amp; MB_ASCII_TIMEOUT_WAIT_BEFORE_SEND_MS )
                {
                    vMBPortTimersDelay( MB_ASCII_TIMEOUT_WAIT_BEFORE_SEND_MS );
                }                
                eStatus = peMBFrameSendCur( ucMBAddress, ucMBFrame, usLength );
            }
            break;

        case EV_FRAME_SENT:
            break;
        }
    }
    return MB_ENOERR;
}

`&lt;/pre&gt;

eMBPoll（）就是一个状态机。它只有下面四种状态：

&lt;pre&gt;`
typedef enum
{
    EV_READY,                   /*!&amp;lt; Startup finished. */
    EV_FRAME_RECEIVED,          /*!&amp;lt; Frame received. */
    EV_EXECUTE,                 /*!&amp;lt; Execute function. */
    EV_FRAME_SENT               /*!&amp;lt; Frame sent. */
} eMBEventType;

`&lt;/pre&gt;

从注释中可以看出，分别是启动完成，帧接收完成，执行功能码，执行帧发送。

这个状态机通过xMBPortEventGet( &amp;amp;eEvent ) 获取事件状态，而事件状态的投递方是谁呢？这里我们先不关注（咱们自上向下分析吧）。我们先分析一下这个状态机的流程。

由于我在写这篇文章之前做过功课，所以比较清楚，这里大家过一下就可以了。

在整个协议栈运行的最初肯定是EV_READY态，然后过了一个3.5T（这个就是modbus的帧头帧尾确认时间啦，不清楚？去翻翻协议吧，我当然不建议你去读国人写的那些“modbus协议整理”之类的葵花宝典，而是建议你去modbus官网下载。找不到下载链接？看这里[Modbus Specifications and Implementation Guides](http://www.modbus.org/specs.php),点那个I Accept就可以进去啦。）如果这个时候接收到一个完整的帧那么就会进入EV_FRAME_RECEIVED态，至于是谁负责去接收和检验帧我们后面再去理，你要记住我们还在应用层里打转转。

&lt;pre&gt;`
                /* Check if the frame is for us. If not ignore the frame. */
                if( ( ucRcvAddress == ucMBAddress ) || ( ucRcvAddress == MB_ADDRESS_BROADCAST ) )
                {
                    ( void )xMBPortEventPost( EV_EXECUTE );
                }

`&lt;/pre&gt;

在EV_READY态如果检测收到的地址跟从机地址（freemodbus的开源版本只支持从机，如果你想要主机的可以参考一下[FreeModbus_Slave-Master-RTT-STM32](https://github.com/armink/FreeModbus_Slave-Master-RTT-STM32)）匹配，或是广播地址就自己给自己投递一个EV_EXECUTE 事件。

&lt;pre&gt;`
        case EV_EXECUTE:
            ucFunctionCode = ucMBFrame[MB_PDU_FUNC_OFF];
            eException = MB_EX_ILLEGAL_FUNCTION;
            for( i = 0; i &amp;lt; MB_FUNC_HANDLERS_MAX; i++ )
            {
                /* No more function handlers registered. Abort. */
                if( xFuncHandlers[i].ucFunctionCode == 0 )
                {
                    break;
                }
                else if( xFuncHandlers[i].ucFunctionCode == ucFunctionCode )
                {
                    eException = xFuncHandlers[i].pxHandler( ucMBFrame, &amp;amp;usLength );
                    break;
                }
            }

            /* If the request was not sent to the broadcast address we
             * return a reply. */
            if( ucRcvAddress != MB_ADDRESS_BROADCAST )
            {
                if( eException != MB_EX_NONE )
                {
                    /* An exception occured. Build an error frame. */
                    usLength = 0;
                    ucMBFrame[usLength++] = ( UCHAR )( ucFunctionCode | MB_FUNC_ERROR );
                    ucMBFrame[usLength++] = eException;
                }
                if( ( eMBCurrentMode == MB_ASCII ) &amp;amp;&amp;amp; MB_ASCII_TIMEOUT_WAIT_BEFORE_SEND_MS )
                {
                    vMBPortTimersDelay( MB_ASCII_TIMEOUT_WAIT_BEFORE_SEND_MS );
                }                
                eStatus = peMBFrameSendCur( ucMBAddress, ucMBFrame, usLength );
            }
            break;

`&lt;/pre&gt;

在EV_EXECUTE的第一段就是执行相应的功能码回调，也就是读写寄存器或者是打开线圈什么的，实现上就是执行mbfunctions里面的代码，因为在协议栈初始化的时候这些文件里面的函数都被值给了xFuncHandlers[]，去看看xFuncHandlers[]的定义吧。

&lt;pre&gt;`
/* An array of Modbus functions handlers which associates Modbus function
 * codes with implementing functions.
 */
static xMBFunctionHandler xFuncHandlers[MB_FUNC_HANDLERS_MAX] = {
#if MB_FUNC_OTHER_REP_SLAVEID_ENABLED &amp;gt; 0
    {MB_FUNC_OTHER_REPORT_SLAVEID, eMBFuncReportSlaveID},
#endif
#if MB_FUNC_READ_INPUT_ENABLED &amp;gt; 0
    {MB_FUNC_READ_INPUT_REGISTER, eMBFuncReadInputRegister},
#endif
#if MB_FUNC_READ_HOLDING_ENABLED &amp;gt; 0
    {MB_FUNC_READ_HOLDING_REGISTER, eMBFuncReadHoldingRegister},
#endif
#if MB_FUNC_WRITE_MULTIPLE_HOLDING_ENABLED &amp;gt; 0
    {MB_FUNC_WRITE_MULTIPLE_REGISTERS, eMBFuncWriteMultipleHoldingRegister},
#endif
#if MB_FUNC_WRITE_HOLDING_ENABLED &amp;gt; 0
    {MB_FUNC_WRITE_REGISTER, eMBFuncWriteHoldingRegister},
#endif
#if MB_FUNC_READWRITE_HOLDING_ENABLED &amp;gt; 0
    {MB_FUNC_READWRITE_MULTIPLE_REGISTERS, eMBFuncReadWriteMultipleHoldingRegister},
#endif
#if MB_FUNC_READ_COILS_ENABLED &amp;gt; 0
    {MB_FUNC_READ_COILS, eMBFuncReadCoils},
#endif
#if MB_FUNC_WRITE_COIL_ENABLED &amp;gt; 0
    {MB_FUNC_WRITE_SINGLE_COIL, eMBFuncWriteCoil},
#endif
#if MB_FUNC_WRITE_MULTIPLE_COILS_ENABLED &amp;gt; 0
    {MB_FUNC_WRITE_MULTIPLE_COILS, eMBFuncWriteMultipleCoils},
#endif
#if MB_FUNC_READ_DISCRETE_INPUTS_ENABLED &amp;gt; 0
    {MB_FUNC_READ_DISCRETE_INPUTS, eMBFuncReadDiscreteInputs},
#endif
};

`&lt;/pre&gt;

看到这里你就明白了xFuncHandlers不过是一个功能码和功能回调函数的对应表，eMBFuncWriteHoldingRegister（）就是写保持寄存器回调。我们还是接着看EV_EXECUTE，第一段里面需要注意`if( xFuncHandlers[i].ucFunctionCode == 0 )`这一句是用来在结束遍历表, freemodbus提供了一个eMBRegisterCB（）eMBRegisterCB函数专门用来注册功能码和与之相应的回调，但是对于不响应的功能码freemodbus通过`xFuncHandlers[i].ucFunctionCode = 0;`将其直接置0。

EV_EXECUTE第二段就是对主机作出回应。讲到这里接收处理就讲完了。在mb.c中我们可以看到这一层并不对EV_FRAME_SENT作处理。

#### mbrtu.c分析

在mb.c里面我们留了一个疑惑，是谁在投递事件？或者说是谁在改变mb.c里面状态机的状态？

如果是RTU模式，那么就是这mbrtu.c里面的这个函数了

&lt;pre&gt;`
BOOL
xMBRTUTimerT35Expired( void )
{
    BOOL            xNeedPoll = FALSE;

    switch ( eRcvState )
    {
        /* Timer t35 expired. Startup phase is finished. */
    case STATE_RX_INIT:
        xNeedPoll = xMBPortEventPost( EV_READY );
        break;

        /* A frame was received and t35 expired. Notify the listener that
         * a new frame was received. */
    case STATE_RX_RCV:
        xNeedPoll = xMBPortEventPost( EV_FRAME_RECEIVED );
        break;

        /* An error occured while receiving the frame. */
    case STATE_RX_ERROR:
        break;

        /* Function called in an illegal state. */
    default:
        assert( ( eRcvState == STATE_RX_INIT ) ||
                ( eRcvState == STATE_RX_RCV ) || ( eRcvState == STATE_RX_ERROR ) );
    }

    vMBPortTimersDisable(  );
    eRcvState = STATE_RX_IDLE;

    return xNeedPoll;
}

`&lt;/pre&gt;

这个函数是被vMBPortTimerPoll（）被调用的，vMBPortTimerPoll（）又是被xMBPortEventGet（）调用的，这里我们看一下vMBPortTimerPoll（）是在什么情况下调用xMBRTUTimerT35Expired：

&lt;pre&gt;`
void
    vMBPortTimerPoll(  )
{

    /* Timers are called from the serial layer because we have no high
    * res timer in Win32\. */
    if( bTimeoutEnable )
    {
        DWORD           dwTimeCurrent = GetTickCount(  );

        if( ( dwTimeCurrent - dwTimeLast ) &amp;gt; dwTimeOut )
        {
            bTimeoutEnable = FALSE;
            ( void )pxMBPortCBTimerExpired(  );
        }
    }
}

`&lt;/pre&gt;

可以看到就当系统的tickCount间隔达到一定时间时就调用xMBRTUTimerT35Expired（）（pxMBPortCBTimerExpired在eMBInit()中被赋值为xMBRTUTimerT35Expired），简单点说吧，就相当于单片机定时器中断函数，定时执行xMBRTUTimerT35Expired()函数。

回到mbrtu.c中来吧，跟踪的第一要点是不能迷路，方向感要好！

xMBRTUTimerT35Expired就是根据eRcvState的不同状态来投递不同的事件给mb.c中的eMBPoll（）这个状态机。而eRcvState又是怎么来的呢？在xMBRTUReceiveFSM（）中我们看到了它。

&lt;pre&gt;`
BOOL
xMBRTUReceiveFSM( void )
{
    BOOL            xTaskNeedSwitch = FALSE;
    UCHAR           ucByte;

    assert( eSndState == STATE_TX_IDLE );

    /* Always read the character. */
    ( void )xMBPortSerialGetByte( ( CHAR * ) &amp;amp; ucByte );

    switch ( eRcvState )
    {
        /* If we have received a character in the init state we have to
         * wait until the frame is finished.
         */
    case STATE_RX_INIT:
        vMBPortTimersEnable(  );
        break;

        /* In the error state we wait until all characters in the
         * damaged frame are transmitted.
         */
    case STATE_RX_ERROR:
        vMBPortTimersEnable(  );
        break;

        /* In the idle state we wait for a new character. If a character
         * is received the t1.5 and t3.5 timers are started and the
         * receiver is in the state STATE_RX_RECEIVCE.
         */
    case STATE_RX_IDLE:
        usRcvBufferPos = 0;
        ucRTUBuf[usRcvBufferPos++] = ucByte;
        eRcvState = STATE_RX_RCV;

        /* Enable t3.5 timers. */
        vMBPortTimersEnable(  );
        break;

        /* We are currently receiving a frame. Reset the timer after
         * every character received. If more than the maximum possible
         * number of bytes in a modbus frame is received the frame is
         * ignored.
         */
    case STATE_RX_RCV:
        if( usRcvBufferPos &amp;lt; MB_SER_PDU_SIZE_MAX )
        {
            ucRTUBuf[usRcvBufferPos++] = ucByte;
        }
        else
        {
            eRcvState = STATE_RX_ERROR;
        }
        vMBPortTimersEnable(  );
        break;
    }
    return xTaskNeedSwitch;
}

`&lt;/pre&gt;

这里不兜圈子，直接告诉你xMBRTUReceiveFSM会在串口接收函数中被调用（虽然在这个WIN32例程中并没有中断例程）。我们这里主要分析一下xMBRTUReceiveFSM的流程。

首先xMBRTUReceiveFSM会进入STATE_RX_INIT态，这个时候它调用vMBPortTimersEnable开启定时器，当达到3.5T时间后xMBRTUTimerT35Expired会让  eRcvState = STATE_RX_IDLE，这样xMBRTUReceiveFSM会进入STATE_RX_IDLE态，在STATE_RX_IDLE态一旦通过xMBPortSerialGetByte收到了一个字符，那么就会 进入STATE_RX_RCV态，在这里就是持续的接收字符同时进行两种检测，一种是如果接收的字符超过了MB_SER_PDU_SIZE_MAX（RTU帧的最大值）就会进入STATE_RX_ERROR态，另一种就是检测是否超时，vMBPortTimersEnable(  )就是用来清零定时器的。如果超时则会由xMBRTUTimerT35Expired向mb.c状态机投递一个EV_FRAME_RECEIVED帧结束事件，这个时候帧数据就会被交给mb.c中的状态机去处理。在xMBRTUTimerT35Expired退出前会再次将xMBRTUReceiveFSM的状态置为STATE_RX_IDLE空闲态。

至此从上到下整个接收流程都理清楚了。那么我再看一看发送流程吧，这个比较轻松。

&lt;pre&gt;`
BOOL
xMBRTUTransmitFSM( void )
{
    BOOL            xNeedPoll = FALSE;

    assert( eRcvState == STATE_RX_IDLE );

    switch ( eSndState )
    {
        /* We should not get a transmitter event if the transmitter is in
         * idle state.  */
    case STATE_TX_IDLE:
        /* enable receiver/disable transmitter. */
        vMBPortSerialEnable( TRUE, FALSE );
        break;

    case STATE_TX_XMIT:
        /* check if we are finished. */
        if( usSndBufferCount != 0 )
        {
            xMBPortSerialPutByte( ( CHAR )*pucSndBufferCur );
            pucSndBufferCur++;  /* next byte in sendbuffer. */
            usSndBufferCount--;
        }
        else
        {
            xNeedPoll = xMBPortEventPost( EV_FRAME_SENT );
            /* Disable transmitter. This prevents another transmit buffer
             * empty interrupt. */
            vMBPortSerialEnable( TRUE, FALSE );
            eSndState = STATE_TX_IDLE;
        }
        break;
    }

    return xNeedPoll;
}

`&lt;/pre&gt;

xMBRTUTransmitFSM在eMBInit（）中被赋值给了pxMBFrameCBTransmitterEmpty，而pxMBFrameCBTransmitterEmpty又被xMBPortSerialPoll调用，最后xMBPortSerialPoll被xMBPortEventGet中被调用。

xMBRTUTransmitFSM只有两个状态。

&lt;pre&gt;`
typedef enum
{
    STATE_TX_IDLE,              /*!&amp;lt; Transmitter is in idle state. */
    STATE_TX_XMIT               /*!&amp;lt; Transmitter is in transfer state. */
} eMBSndState;

`&lt;/pre&gt;

在没有发送任务的时候，它是处理STATE_TX_IDLE态，在modbus协议栈初始化的时候它就是这个态，而这个STATE_TX_XMIT发送态则是用来将要发送的数据推送到发送缓冲的（这里你可以用你的串口中断来做，但我觉得用DMA会更好一些），发送完数据后又返回到STATE_TX_IDLE态，但是STATE_TX_XMIT是谁让它进入的呢？

&lt;pre&gt;`
eMBErrorCode
eMBRTUSend( UCHAR ucSlaveAddress, const UCHAR * pucFrame, USHORT usLength )
{
    eMBErrorCode    eStatus = MB_ENOERR;
    USHORT          usCRC16;

    ENTER_CRITICAL_SECTION(  );

    /* Check if the receiver is still in idle state. If not we where to
     * slow with processing the received frame and the master sent another
     * frame on the network. We have to abort sending the frame.
     */
    if( eRcvState == STATE_RX_IDLE )
    {
        /* First byte before the Modbus-PDU is the slave address. */
        pucSndBufferCur = ( UCHAR * ) pucFrame - 1;
        usSndBufferCount = 1;

        /* Now copy the Modbus-PDU into the Modbus-Serial-Line-PDU. */
        pucSndBufferCur[MB_SER_PDU_ADDR_OFF] = ucSlaveAddress;
        usSndBufferCount += usLength;

        /* Calculate CRC16 checksum for Modbus-Serial-Line-PDU. */
        usCRC16 = usMBCRC16( ( UCHAR * ) pucSndBufferCur, usSndBufferCount );
        ucRTUBuf[usSndBufferCount++] = ( UCHAR )( usCRC16 &amp;amp; 0xFF );
        ucRTUBuf[usSndBufferCount++] = ( UCHAR )( usCRC16 &amp;gt;&amp;gt; 8 );

        /* Activate the transmitter. */
        eSndState = STATE_TX_XMIT;
        vMBPortSerialEnable( FALSE, TRUE );
    }
    else
    {
        eStatus = MB_EIO;
    }
    EXIT_CRITICAL_SECTION(  );
    return eStatus;
}

`&lt;/pre&gt;

这个eMBRTUSend就是用来将xMBRTUTransmitFSM置为STATE_TX_XMIT的函数，同时它还使能串口发送功能。eMBRTUSend本身却是在eMBPoll（）的EV_EXECUTE状态的第二段被调用的，就是当收到功能码时我们回应给主机的这一部分。

&lt;pre&gt;`
            /* If the request was not sent to the broadcast address we
             * return a reply. */
            if( ucRcvAddress != MB_ADDRESS_BROADCAST )
            {
                if( eException != MB_EX_NONE )
                {
                    /* An exception occured. Build an error frame. */
                    usLength = 0;
                    ucMBFrame[usLength++] = ( UCHAR )( ucFunctionCode | MB_FUNC_ERROR );
                    ucMBFrame[usLength++] = eException;
                }
                if( ( eMBCurrentMode == MB_ASCII ) &amp;amp;&amp;amp; MB_ASCII_TIMEOUT_WAIT_BEFORE_SEND_MS )
                {
                    vMBPortTimersDelay( MB_ASCII_TIMEOUT_WAIT_BEFORE_SEND_MS );
                }                
                eStatus = peMBFrameSendCur( ucMBAddress, ucMBFrame, usLength );
            }
            break;

`&lt;/pre&gt;

其中的peMBFrameSendCur（）就是eMBRTUSend（），在eMBInit我们将eMBRTUSend赋值给了peMBFrameSendCur（）。 现在咱们终于绕出来了，发送流程也介绍清楚了。

写到这里，我估计你可能会有一些疑惑，在这个例程中真正完成发送和接收串口的代码在哪里？

&lt;pre&gt;`
BOOL
xMBPortEventGet( eMBEventType * eEvent )
{
    BOOL            xEventHappened = FALSE;

    if( xEventInQueue )
    {
        *eEvent = eQueuedEvent;
        xEventInQueue = FALSE;
        xEventHappened = TRUE;
    }
    else
    {        
        /* Poll the serial device. The serial device timeouts if no
         * characters have been received within for t3.5 during an
         * active transmission or if nothing happens within a specified
         * amount of time. Both timeouts are configured from the timer
         * init functions.
         */
        ( void )xMBPortSerialPoll(  );  

        /* Check if any of the timers have expired. */
        vMBPortTimerPoll(  );

    }
    return xEventHappened;
}

`&lt;/pre&gt;

其实它们就在xMBPortSerialPoll里，换句话说，每次当mb.c的状态机调用xMBPortEventGet（）都在进行串口操作，要么是发送要么是接收。

&lt;pre&gt;`
BOOL
xMBPortSerialPoll(  )
{
    BOOL            bStatus = TRUE;
    DWORD           dwBytesRead;
    DWORD           dwBytesWritten;
    DWORD           i;

    while( bRxEnabled )
    {
        /* buffer wrap around. */
        if( uiRxBufferPos &amp;gt;= BUF_SIZE )
            uiRxBufferPos = 0;

        if( ReadFile( g_hSerial, &amp;amp;ucBuffer[uiRxBufferPos],
                      BUF_SIZE - uiRxBufferPos, &amp;amp;dwBytesRead, NULL ) )
        {
            if( dwBytesRead == 0 )
            {
                /* timeout with no bytes. */
                break;
            }
            else if( dwBytesRead &amp;gt; 0 )
            {
                vMBPortLog( MB_LOG_DEBUG, _T( &quot;SER-POLL&quot; ),
                            _T( &quot;detected end of frame (t3.5 expired.)\r\n&quot; ) );
                for( i = 0; i &amp;lt; dwBytesRead; i++ )
                {
                    /* Call the modbus stack and let him fill the buffers. */
                    ( void )pxMBFrameCBByteReceived(  );
                }
            }
        }
        else
        {
            vMBPortLog( MB_LOG_ERROR, _T( &quot;SER-POLL&quot; ), _T( &quot;I/O error on serial device: %s&quot; ),
                        Error2String( GetLastError ( ) ) );
            bStatus = FALSE;
        }
    }
    if( bTxEnabled )
    {
        while( bTxEnabled )
        {
            ( void )pxMBFrameCBTransmitterEmpty(  );
            /* Call the modbus stack to let him fill the buffer. */
        }
        dwBytesWritten = 0;
        if( !WriteFile
            ( g_hSerial, &amp;amp;ucBuffer[0], uiTxBufferPos, &amp;amp;dwBytesWritten, NULL )
            || ( dwBytesWritten != uiTxBufferPos ) )
        {
            vMBPortLog( MB_LOG_ERROR, _T( &quot;SER-POLL&quot; ), _T( &quot;I/O error on serial device: %s&quot; ),
                        Error2String( GetLastError ( ) ) );
            bStatus = FALSE;
        }
    }

    return bStatus;
}

`&lt;/pre&gt;

xMBPortSerialPoll依据bRxEnabled 和 bTxEnabled 来区分到底是发送还是接收。

**我看到有些人说freemodbus只能通过阻塞方式发送和接收串口数据很显然是错误的，它可以用普通串口中断或者是串口DMA来做。**

写第一版的时候忘了分析一下事件队列，虽然说是叫事件队列，其实就是很简单的对一个变量进行了封装,提供了抽象接口，代码也只有这么几行：

&lt;pre&gt;`
/* ----------------------- Variables ----------------------------------------*/
static eMBEventType eQueuedEvent;
static BOOL     xEventInQueue;

/* ----------------------- Start implementation -----------------------------*/
BOOL
xMBPortEventInit( void )
{
    xEventInQueue = FALSE;
    return TRUE;
}

BOOL
xMBPortEventPost( eMBEventType eEvent )
{
    xEventInQueue = TRUE;
    eQueuedEvent = eEvent;
    return TRUE;
}

BOOL
xMBPortEventGet( eMBEventType * eEvent )
{
    BOOL            xEventHappened = FALSE;

    if( xEventInQueue )
    {
        *eEvent = eQueuedEvent;
        xEventInQueue = FALSE;
        xEventHappened = TRUE;
    }
    else
    {        
        /* Poll the serial device. The serial device timeouts if no
         * characters have been received within for t3.5 during an
         * active transmission or if nothing happens within a specified
         * amount of time. Both timeouts are configured from the timer
         * init functions.
         */
        ( void )xMBPortSerialPoll(  );  

        /* Check if any of the timers have expired. */
        vMBPortTimerPoll(  );

    }
    return xEventHappened;
}

`&lt;/pre&gt;

xMBPortEventPost这个投递事件的函数只是将事件枚举赋值给这个模块的变量，同时将xEventInQueue置为真表示队列中有数据，xMBPortEventGet的逻辑稍微复杂一点，它会在eMBPoll状态机中被反复调用，它首先将xEventInQueue置为FALSE，然后如果队列中有数据将就队列中的数字赋给eMBPoll传入的指针，没有事件的话就进行一下串口的接收和发送处理。

**注意**：freemodbus并没有用到T1.5（同一帧内两个字符之间的最大时间间隔）检测，你可以去看源代码里面xMBRTUTimerT15Expired这个函数仅仅只是声明了，我个人猜测是因为T1.5这个时间粒度太小（波特率为19200，按协议t1.5取为750us），一般的MCU根本没精力去做这个检测。

* * *

最后提一下asc模式，在eMBInit()函数中我们看到如果你的初时化时候的选择MB_ASCII作为参数，与modbus协议相关的回调和状态都会被替换成maasiic中的内容，顺着这条藤去摸一下ASC模式的瓜应该不难。

&lt;pre&gt;`
#if MB_RTU_ENABLED &amp;gt; 0
        case MB_RTU:
            pvMBFrameStartCur = eMBRTUStart;
            pvMBFrameStopCur = eMBRTUStop;
            peMBFrameSendCur = eMBRTUSend;
            peMBFrameReceiveCur = eMBRTUReceive;
            pvMBFrameCloseCur = MB_PORT_HAS_CLOSE ? vMBPortClose : NULL;
            pxMBFrameCBByteReceived = xMBRTUReceiveFSM;
            pxMBFrameCBTransmitterEmpty = xMBRTUTransmitFSM;
            pxMBPortCBTimerExpired = xMBRTUTimerT35Expired;

            eStatus = eMBRTUInit( ucMBAddress, ucPort, ulBaudRate, eParity );
            break;
#endif
#if MB_ASCII_ENABLED &amp;gt; 0
        case MB_ASCII:
            pvMBFrameStartCur = eMBASCIIStart;
            pvMBFrameStopCur = eMBASCIIStop;
            peMBFrameSendCur = eMBASCIISend;
            peMBFrameReceiveCur = eMBASCIIReceive;
            pvMBFrameCloseCur = MB_PORT_HAS_CLOSE ? vMBPortClose : NULL;
            pxMBFrameCBByteReceived = xMBASCIIReceiveFSM;
            pxMBFrameCBTransmitterEmpty = xMBASCIITransmitFSM;
            pxMBPortCBTimerExpired = xMBASCIITimerT1SExpired;

            eStatus = eMBASCIIInit( ucMBAddress, ucPort, ulBaudRate, eParity );
            break;
#endif
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/MCU-ARM/">MCU/ARM</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-freemodbus-rtuascii-e5-ae-98-e6-96-b9-e7-a7-bb-e6-a4-8d-e6-96-87-e6-a1-a3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/05/freemodbus-rtuascii-e5-ae-98-e6-96-b9-e7-a7-bb-e6-a4-8d-e6-96-87-e6-a1-a3/" class="article-date">
      <time datetime="2016-01-05T13:12:40.000Z" itemprop="datePublished">2016-01-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/05/freemodbus-rtuascii-e5-ae-98-e6-96-b9-e7-a7-bb-e6-a4-8d-e6-96-87-e6-a1-a3/">freemodbus RTU/ASCII 官方移植文档</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><a href="/uploads/2016/01/freeModbus.jpg"><img src="/uploads/2016/01/freeModbus-300x167.jpg" alt="freeModbus"></a></p>
<p>原文：<a href="http://www.freemodbus.org/api/index.html" target="_blank" rel="external">Porting for RTU/ASCII</a></p>
<p>第一步你应该先创建一个移植目录，例如创建一个demo/PLATFORM的目录，里面包含应用程序和工程文件，然后再创建一个子目录专门用来放置移植相关文件。</p>
<blockquote>
<p>demo/PLATFORM/Makefile<br>  demo/PLATFORM/main.c<br>  demo/PLATFORM/port/portserial.c<br>  demo/PLATFORM/port/porttimer.c<br>  demo/PLATFORM/port/portother.c<br>  demo/PLATFORM/port/port.h</p>
</blockquote>
<p>你也可以将demo/BARE作为开始，复制它然后重命名它。</p>
<h3 id="移植约定（port-h）"><a href="#移植约定（port-h）" class="headerlink" title="移植约定（port.h）"></a>移植约定（port.h）</h3><p>首先看一下port.h文件，看看是不是已经有了适合你的平台的例子。你至少应该定义一下使能中断ENTER_CRITICAL_SECTION和禁能中断EXIT_CRITICAL_SECTION的宏。</p>
<h3 id="实现定时函器函数（porttimer-c）"><a href="#实现定时函器函数（porttimer-c）" class="headerlink" title="实现定时函器函数（porttimer.c）"></a>实现定时函器函数（porttimer.c）</h3><p>Modbus协议栈需要一个定时器用于检测帧结束。定时器的分辨率必须是串口参数的一半。举个例子，假定波特率是38400一个11bit字符那么大概是280us，。这样对于协议栈来说最小的超时时间是3.5倍的单个字符传输时间。</p>
<p>从实现xMBPortTimersInit( USHORT usTim1Timerout50us )和 vMBPortTimersEnable( )开始。可以用下面的代码进行测试</p>
<pre><code>xMBPortTimersInit( 20 );
vMBPortTimersEnable( );
for( ;; );

`&lt;/pre&gt;

在中断处理函数中下一个断点或者每次调用pxMBPortCBTimerExpired时闪烁一下LED，在调用vMBPortTimersEnable()一个毫秒后中断服务将会触发。你也要检查一下 vMBPortTimersDisable( )是否按预期工作。

**注意**：

_如果你用ASCII模式的Modbus，定时计的范围是以秒计的，因为那里的超时非常大。确保你的usTim1Timerout50us能处理输入值为2000的情况，超时为1秒时。参见mbconfig.h中MB_ASCII_TIMEOUT_SEC的定义。_

### 移植RTU/ASCII模式。

串口移植层必须初始化串口，禁能或者使能接收器和发送器，以及在接收或者发送一个字符的时候回调函数能够执行。通过实现xMBPortSerialInit( UCHAR ucPORT, ULONG ulBaudRate, UCHAR ucDataBits, eMBParity eParity ) 和 vMBPortSerialEnable( BOOL xRxEnable, BOOL xTxEnable )开始。另外你还需要为你的通讯器件创建两个中断服务函数。从接收中断开始将会非常简单。

创建一个接收中断处理函数，设置一个断点用来检查xMBPortSerialGetByte( CHAR * pucByte )是否能正确地返回一个字符。能通过以下的代码进行测试。

&lt;pre&gt;`
/* Initialize COM device 0 with 38400 baud, 8 data bits and no parity. */
if( xMBPortSerialInit( 0, 38400, 8, MB_PAR_NONE ) == FALSE )
{
  fprintf(stderr, &quot;error: com init failed&quot;);
}
else
{
  /* Enable the receiver. */ 
  vMBPortSerialEnable( TRUE, FALSE );
  /* Now block. Any character received should cause an interrupt now. */
  for( ;; );
}

`&lt;/pre&gt;

你的串口接收中断函数看起来应该是这样子的：

&lt;pre&gt;`
static void prvvUARTTxReadyISR( void )
{
    CHAR cByte;
    ( void )xMBPortSerialGetByte( &amp;amp;cByte );
    /* Now cByte should contain the character received. */
}

`&lt;/pre&gt;

下一步你应该测试一下发送部分是否如预期的那样正常工作。打开一终端程序，然后在空的发送中断函数中简单地调用一下 xMBPortSerialPutByte( &apos;a&apos; ) 。如果你用下面这个简单代码来测试应该准确地收到10个字符。

&lt;pre&gt;`
/* Initialize COM device 0 with 38400 baud, 8 data bits and no parity. */
if( xMBPortSerialInit( 0, 38400, 8, MB_PAR_NONE ) == FALSE )
{
  fprintf(stderr, &quot;error: com init failed&quot;);
}
else
{
  /* Enable the transmitter. */ 
  vMBPortSerialEnable( FALSE, TRUE );
  /* Now block. Any character received should cause an interrupt now. */
  for( ;; );
}

`&lt;/pre&gt;

你的发送中断函数看起来应该是这样子的：

&lt;pre&gt;`
static unsigned int uiCnt = 0;

void prvvUARTTxReadyISR( void )
{
    if( uiCnt++ &amp;lt; 10 )
    {
        ( void )xMBPortSerialPutByte( &apos;a&apos; );
    }
    else
    {
        vMBPortSerialEnable( FALSE, FALSE );
    }
}

`&lt;/pre&gt;

如果你确定上面的都正常工作了，那么改一下portserial.c的中断函数。

### 实现事件队列(portevent.c)

如果你没有用操作系统那么移植到此就结束了，并且例程会如预期地正常工作。如果你刚好要在一个操作系统中用FreeModbus作为协议本，那么方法有些不同：
</code></pre><ul>
<li><p>在启动的时候创建另一个任务循环调用eMBPoll()。像这样：</p>
<p><pre>`<br>If you in the luck of having an operating system usage of the FreeModbus protocol stack differs in the following way</pre></p>
</li>
<li><p>修改用于向队列中投递事件的xMBPortEventPost函数。注意这个函数会在中断服务函数里面被调用，因此看看你的RTOS文档。</p><p></p>
</li>
<li>修改用于从队列中接收事件的xMBPortEventGet函数。eMBPoll将会周期性地调用这个函数。这个函数将会是阻塞的直到队列中已被投递了一个事件。</li>
</ul>
<p></p><p>另外对串口和定时器中断函数进行修正。每当协议处理回调pxMBFrameCBByteReceived, pxMBFrameCBTransmitterEmpty 和 pxMBPortCBTimerExpired 返回TRUE 时应该在退出ISR后进行一次上下文切换，因为一个事件已经被投递到队列中。如果忘记了做这一步，将会导致协议本的性能低下。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/MCU-ARM/">MCU/ARM</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-chipscope-e8-bf-9e-e6-8e-a5platform-cable-usb-jtag-e5-a4-b1-e8-b4-a5-e5-8e-9f-e5-9b-a0-e5-8f-8a-e8-a7-a3-e5-86-b3-e5-8a-9e-e6-b3-95" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/02/chipscope-e8-bf-9e-e6-8e-a5platform-cable-usb-jtag-e5-a4-b1-e8-b4-a5-e5-8e-9f-e5-9b-a0-e5-8f-8a-e8-a7-a3-e5-86-b3-e5-8a-9e-e6-b3-95/" class="article-date">
      <time datetime="2016-01-02T04:11:14.000Z" itemprop="datePublished">2016-01-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/02/chipscope-e8-bf-9e-e6-8e-a5platform-cable-usb-jtag-e5-a4-b1-e8-b4-a5-e5-8e-9f-e5-9b-a0-e5-8f-8a-e8-a7-a3-e5-86-b3-e5-8a-9e-e6-b3-95/">chipscope 连接platform cable usb JTAG失败原因及解决办法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>报以下错误：</p>
<blockquote>
<p>Number of bytes peeked does not match number of bytes requested.  Corrupted file?</p>
</blockquote>
<p>经搜索找到<a href="http://www.xilinx.com/support/answers/32912.html，得知原因是由系统的UAC导致（VISTA以上系统出于安全考虑默认都有这个玩意，就是你双击一个EXE的时候会先弹出一个对话框问你是否确认运行，如果你装的是原版一般都是默认开启的，如果是其它一些修改版本这个功能可能被删掉了）。既然找到原因，那就好办了。" target="_blank" rel="external">http://www.xilinx.com/support/answers/32912.html，得知原因是由系统的UAC导致（VISTA以上系统出于安全考虑默认都有这个玩意，就是你双击一个EXE的时候会先弹出一个对话框问你是否确认运行，如果你装的是原版一般都是默认开启的，如果是其它一些修改版本这个功能可能被删掉了）。既然找到原因，那就好办了。</a></p>
<p>找到chipsope所成的位置，通常在ISE按装目录下的</p>
<p><a href="/uploads/2016/01/2016-01-02_134030.png"><img src="/uploads/2016/01/2016-01-02_134030-300x177.png" alt="2016-01-02_134030"></a></p>
<p>然后右键</p>
<p><a href="/uploads/2016/01/2016-01-02_133428.png"><img src="/uploads/2016/01/2016-01-02_133428-260x300.png" alt="2016-01-02_133428"></a></p>
<p>勾上以管理员权限运行此程序。</p>
<p>或者关闭UAC，<a href="http://technet2.microsoft.com/WindowsVista/en/library/0d75f774-8514-4c9e-ac08-4c21f5c6c2d91033.mspx?mfr=true。" target="_blank" rel="external">http://technet2.microsoft.com/WindowsVista/en/library/0d75f774-8514-4c9e-ac08-4c21f5c6c2d91033.mspx?mfr=true。</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/FPGA/">FPGA</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-altium-designer-e8-87-aa-e5-8a-a8-e6-b7-bb-e5-8a-a0-e6-88-90-e7-89-87-e7-9a-84-e6-8b-bc-e6-8e-a5-e5-ad-94-ef-bc-88-e7-bc-9d-e5-90-88-e5-ad-94-ef-bc-89" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/24/altium-designer-e8-87-aa-e5-8a-a8-e6-b7-bb-e5-8a-a0-e6-88-90-e7-89-87-e7-9a-84-e6-8b-bc-e6-8e-a5-e5-ad-94-ef-bc-88-e7-bc-9d-e5-90-88-e5-ad-94-ef-bc-89/" class="article-date">
      <time datetime="2015-12-24T13:26:48.000Z" itemprop="datePublished">2015-12-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/24/altium-designer-e8-87-aa-e5-8a-a8-e6-b7-bb-e5-8a-a0-e6-88-90-e7-89-87-e7-9a-84-e6-8b-bc-e6-8e-a5-e5-ad-94-ef-bc-88-e7-bc-9d-e5-90-88-e5-ad-94-ef-bc-89/">altium-designer自动添加成片的拼接孔（缝合孔）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>通常为了降低对地阻抗(当然也可以是针对其它非地网络)，我们会在板子上空闲的地方打上连接过孔（Via Stitching）。</p>
<p><a href="/uploads/2015/12/Via-Stitching.png"><img src="/uploads/2015/12/Via-Stitching-300x195.png" alt="Via Stitching"></a></p>
<p>之前都是手动粘贴复制，在edit菜单下选择特殊粘贴</p>
<p><a href="/uploads/2015/12/2015-12-24_172817.png"><img src="/uploads/2015/12/2015-12-24_172817.png" alt="2015-12-24_172817"></a></p>
<p>勾上保持网络名复选框</p>
<p><a href="/uploads/2015/12/2015-12-24_172826.png"><img src="/uploads/2015/12/2015-12-24_172826.png" alt="2015-12-24_172826"></a></p>
<p>然后选择组粘贴，设置好粘贴数量和坐标增长方式（也即间距）</p>
<p><a href="/uploads/2015/12/2015-12-24_172833.png"><img src="/uploads/2015/12/2015-12-24_172833-300x200.png" alt="2015-12-24_172833"></a></p>
<p>现在不用了，可以直接采用Tools » Via Stitching » Add Stitch Net命令来完成。</p>
<p><a href="/uploads/2015/12/2015-12-24_211133.png"><img src="/uploads/2015/12/2015-12-24_211133-300x235.png" alt="2015-12-24_211133"></a></p>
<p>左边的属性分别是区域设置，当选上constrain area区域约束后就会出现十字光标让你选取要打孔的区域。左下面分别是过孔间距、过孔或焊盘安全距离，距板边的安全距离等。左边则是先取过孔相关参数。如果你不勾选constrain area复选框，则会自动在整块板子上打缝合孔。</p>
<p><strong>注意，打孔之前必须是板子先覆实铜，不覆铜或覆网络都会显示不能找到打孔的可适区域</strong></p>
<p>在选完区域后点鼠标右键则会再次回到上面的属性界面框，此时constrain area复选框已打上勾。点击OK后就会自动运行打孔了，效果如下：</p>
<p><a href="/uploads/2015/12/2015-12-24_212632.png"><img src="/uploads/2015/12/2015-12-24_212632-300x238.png" alt="2015-12-24_212632"></a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/硬件设计/">硬件设计</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e9-ab-98-e9-80-9f-e9-ab-98-e7-b2-be-e5-ba-a6-e6-b5-8b-e5-be-84-e4-bb-aa-e4-b8-bb-e6-9d-bf-e7-ac-ac-e4-ba-8c-e7-89-88-e5-ae-8c-e5-b7-a5" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/22/e9-ab-98-e9-80-9f-e9-ab-98-e7-b2-be-e5-ba-a6-e6-b5-8b-e5-be-84-e4-bb-aa-e4-b8-bb-e6-9d-bf-e7-ac-ac-e4-ba-8c-e7-89-88-e5-ae-8c-e5-b7-a5/" class="article-date">
      <time datetime="2015-12-22T14:55:05.000Z" itemprop="datePublished">2015-12-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/22/e9-ab-98-e9-80-9f-e9-ab-98-e7-b2-be-e5-ba-a6-e6-b5-8b-e5-be-84-e4-bb-aa-e4-b8-bb-e6-9d-bf-e7-ac-ac-e4-ba-8c-e7-89-88-e5-ae-8c-e5-b7-a5/">高速高精度测径仪主板第二版完工</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>不知不觉11点了，打完收工，好好休息。</p>
<p><a href="/uploads/2015/12/2015-12-29_104721.png"><img src="/uploads/2015/12/2015-12-29_104721-300x225.png" alt="高速高精度直径测量仪主板"></a></p>
<p><a href="/uploads/2015/12/高速高精度直径测量仪主板.png"><img src="/uploads/2015/12/高速高精度直径测量仪主板-300x225.png" alt="高速高精度直径测量仪主板"></a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/硬件设计/">硬件设计</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2016 shawge
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/luuman/hexo-theme-spfk" target="_blank">spfk</a> by luuman
            </div>
        </div>
        
    </div>
</footer>

    </div>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 17;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>