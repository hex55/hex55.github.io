<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>hex55</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="hex55">
<meta property="og:url" content="http://hex55.com/page/8/index.html">
<meta property="og:site_name" content="hex55">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="hex55">
  
    <link rel="alternative" href="/atom.xml" title="hex55" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: false,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img src="/img/head.jpg" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/">shawge</a></h1>
        </hgroup>

        
        <p class="header-subtitle">shawge的电子技术分享</p>
        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">博客首页</a></li>
                        
                            <li><a href="/categories/MCU-ARM/">MCU/ARM</a></li>
                        
                            <li><a href="/categories/FPGA/">FPGA</a></li>
                        
                            <li><a href="/categories/windows-linux/">WINDOWS/LINUX</a></li>
                        
                            <li><a href="/categories/硬件设计/">硬件设计</a></li>
                        
                            <li><a href="/archives/">归档</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=27O_o_7um6qq9bi0tg" title="mail">mail</a>
                            
                                <a class="fl github" target="_blank" href="https://github.com/hex55" title="github">github</a>
                            
                                <a class="fl rss" target="_blank" href="/atom.xml" title="rss">rss</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/github-提速/" style="font-size: 10px;">github 提速</a>
                    </div>
                </section>
                
                
                

                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">没想好。。。</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">shawge</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img src="/img/head.jpg" class="js-avatar" style="width: 100%; height: 100%; opacity: 1;">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">shawge</a></h1>
            </hgroup>
            
            <p class="header-subtitle">shawge的电子技术分享</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">博客首页</a></li>
                
                    <li><a href="/categories/MCU-ARM/">MCU/ARM</a></li>
                
                    <li><a href="/categories/FPGA/">FPGA</a></li>
                
                    <li><a href="/categories/windows-linux/">WINDOWS/LINUX</a></li>
                
                    <li><a href="/categories/硬件设计/">硬件设计</a></li>
                
                    <li><a href="/archives/">归档</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=27O_o_7um6qq9bi0tg" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/hex55" title="github">github</a>
                    
                        <a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-iap-ewarm-stl-e5-a0-86-e7-a9-ba-e9-97-b4-e4-b8-8d-e5-a4-9f-e8-a7-a3-e5-86-b3-e5-8a-9e-e6-b3-95" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/01/iap-ewarm-stl-e5-a0-86-e7-a9-ba-e9-97-b4-e4-b8-8d-e5-a4-9f-e8-a7-a3-e5-86-b3-e5-8a-9e-e6-b3-95/" class="article-date">
      <time datetime="2015-08-01T12:18:50.000Z" itemprop="datePublished">2015-08-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/01/iap-ewarm-stl-e5-a0-86-e7-a9-ba-e9-97-b4-e4-b8-8d-e5-a4-9f-e8-a7-a3-e5-86-b3-e5-8a-9e-e6-b3-95/">IAP EWARM STL 堆栈空间不够解决办法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <hr>
<p>debug log框提示</p>
<blockquote>
<p>Tue Jul 28, 2015 15:19:22: Program exit reached.</p>
</blockquote>
<p>调用堆栈提示</p>
<pre><code>[__exit + 0xb]
[abort + 0x7]
[__iar_dlmalloc + 0x1c3]
[__Znwj + 0xf]
Allocator&amp;lt;void&amp;gt;::allocate(unsigned int)
allocator&amp;lt;unsigned int&amp;gt;::allocate(unsigned int)

`&lt;/pre&gt;

![](
</code></pre><p>/uploads/2015/07/2015-07-28_151947.png)</p>
<pre><code>我按IAR的各种手册找根本找不以在哪设置。

![](
</code></pre><p>/uploads/2015/07/2015-07-29_161514.png)</p>
<pre><code>上面这三种设置就没有一个对的。。。。。。

最后在这个地方找着了，

![](
</code></pre><p>/uploads/2015/07/2015-07-29_160817.png)</p>
<pre><code>另外它的.s启动文件中我也没找到在哪设置堆的大小，哪位知道烦请告知。(**后查明IAR的.s文件中不需管，MDK的.s文件需要管，见下图。另外发现IAR设置的HEAP和STACK好像没什么作用。**)

## ![](
</code></pre><p>/uploads/2015/08/2015-08-01_220638.png)</p>
<pre><code>**PS:** 查看IAR中堆大小写的方法

调用以下函数

&lt;pre&gt;`#include &quot;iar_dlmalloc.h&quot;
__iar_dlmallinfo();
__iar_dlmalloc_stats();
</code></pre><p>运行调试在Terminal I/O窗口中可以看到:</p>
<p><img src="/uploads/2015/08/2015-07-29_190642.png" alt=""></p>
<hr>
<p><strong>PS++：</strong> IAR中查看栈的使用情况，包括分析最长的栈调用路径。</p>
<p><img src="/uploads/2015/08/2015-07-29_191838.png" alt=""></p>
<p><img src="/uploads/2015/08/2015-07-29_191934.png" alt=""></p>
<p>我工程中最长的调用链如下：<br><img src="/uploads/2015/08/2015-07-29_192019.png" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/MCU-ARM/">MCU/ARM</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e9-80-bb-e8-be-91-e5-88-86-e6-9e-90-e4-bb-aa-e3-80-81quad-spi-flash-e8-bd-ac-e6-9d-bf-e5-87-ba-e7-82-89" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/30/e9-80-bb-e8-be-91-e5-88-86-e6-9e-90-e4-bb-aa-e3-80-81quad-spi-flash-e8-bd-ac-e6-9d-bf-e5-87-ba-e7-82-89/" class="article-date">
      <time datetime="2015-07-30T13:21:40.000Z" itemprop="datePublished">2015-07-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/30/e9-80-bb-e8-be-91-e5-88-86-e6-9e-90-e4-bb-aa-e3-80-81quad-spi-flash-e8-bd-ac-e6-9d-bf-e5-87-ba-e7-82-89/">逻辑分析仪、QUAD SPI FLASH转板出炉</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>JLC打板完，焊接完，上电测试正常，CY7C68013正常完成枚举。</p>
<p><a href="/uploads/2015/07/2015-07-27-17.38.21.jpg"><img src="/uploads/2015/07/2015-07-27-17.38.21-300x225.jpg" alt="2015-07-27 17.38.21"></a></p>
<p><a href="/uploads/2015/07/2015-07-28-21.24.57.jpg"><img src="/uploads/2015/07/2015-07-28-21.24.57-300x225.jpg" alt="2015-07-28 21.24.57"></a></p>
<p><a href="/uploads/2015/07/2015-07-27-17.38.33.jpg"><img src="/uploads/2015/07/2015-07-27-17.38.33-300x225.jpg" alt="2015-07-27 17.38.33"></a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/FPGA/">FPGA</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-altium-designer-e5-9c-a8-e5-90-8c-e4-b8-80-e4-b8-aa-e5-b7-a5-e7-a8-8b-e4-b8-ad-e7-bb-98-e5-88-b6-e5-a4-9a-e5-9d-97pcb" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/29/altium-designer-e5-9c-a8-e5-90-8c-e4-b8-80-e4-b8-aa-e5-b7-a5-e7-a8-8b-e4-b8-ad-e7-bb-98-e5-88-b6-e5-a4-9a-e5-9d-97pcb/" class="article-date">
      <time datetime="2015-07-29T12:30:05.000Z" itemprop="datePublished">2015-07-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/29/altium-designer-e5-9c-a8-e5-90-8c-e4-b8-80-e4-b8-aa-e5-b7-a5-e7-a8-8b-e4-b8-ad-e7-bb-98-e5-88-b6-e5-a4-9a-e5-9d-97pcb/">altium designer在同一个工程中绘制多块PCB</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <hr>
<p>往往在一个工程中我们会有多块PCB板，比如电源板、控制板、人机交互板、数据采集板等等，为了便于管理我们通常希望能将其放在同一个工程中，而之前本人用的都是建多个工程这种蠢办法。现记录如下：</p>
<p><strong>Project菜单</strong></p>
<p><img src="/uploads/2015/07/2015-07-28_153044.png" alt=""></p>
<p><strong>Show Differences…选项</strong></p>
<p><img src="/uploads/2015/07/2015-07-28_153113.png" alt=""></p>
<p><strong>勾选“Advanced Mode”</strong><br><img src="/uploads/2015/07/2015-07-28_153249.png" alt=""></p>
<p><strong>同步关联原理图和PCB图纸</strong></p>
<p>图中即是将我的主板原理图和主板PCB图纸进行关联。</p>
<p><img src="/uploads/2015/07/2015-07-28_153407.png" alt=""></p>
<p><strong>点击OK后将会显示关联信息</strong></p>
<p><img src="/uploads/2015/07/2015-07-28_153557.png" alt=""></p>
<p><strong>右键选择弹出,选择所需要的选项，我们这里选择”Update All in &gt;&gt; PCB …”</strong></p>
<p><img src="/uploads/2015/07/2015-07-28_153628.png" alt=""></p>
<p><strong>此时左下角按钮变为可用</strong></p>
<p><img src="/uploads/2015/07/2015-07-28_153824.png" alt=""></p>
<p><strong>点击”Create Enginerring Change Order…”，接下来就是检查错误和执行导入功能了</strong></p>
<p><img src="/uploads/2015/07/2015-07-28_153919.png" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/硬件设计/">硬件设计</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-alitum-designer-e7-bb-99-e4-b8-80-e4-b8-aa-e5-85-83-e4-bb-b6-e6-b7-bb-e5-8a-a0-e5-a4-9a-e4-b8-aapart" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/28/alitum-designer-e7-bb-99-e4-b8-80-e4-b8-aa-e5-85-83-e4-bb-b6-e6-b7-bb-e5-8a-a0-e5-a4-9a-e4-b8-aapart/" class="article-date">
      <time datetime="2015-07-28T12:14:46.000Z" itemprop="datePublished">2015-07-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/28/alitum-designer-e7-bb-99-e4-b8-80-e4-b8-aa-e5-85-83-e4-bb-b6-e6-b7-bb-e5-8a-a0-e5-a4-9a-e4-b8-aapart/">alitum designer给一个元件添加多个part</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <hr>
<p>有些原件，比如运放、总线驱动器、FPGA、ARM等芯片由于内部有多个功能模块，比如FPGA内部有从组IO BANK， 而ARM等又有多个PORT等，为便于进行原理图绘制，在绘制元件模型时，往往需要将其分为多个part，记录如下：</p>
<p><img src="/uploads/2015/07/2015-07-25_135326.png" alt=""></p>
<p><img src="/uploads/2015/07/2015-07-25_135447.png" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/硬件设计/">硬件设计</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-fpga-e6-93-8d-e4-bd-9c-e5-9b-9b-e7-ba-bf-e5-88-b6spi-flash-ef-bc-88quad-spi-flash-ef-bc-89-ef-bc-882-ef-bc-89" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/27/fpga-e6-93-8d-e4-bd-9c-e5-9b-9b-e7-ba-bf-e5-88-b6spi-flash-ef-bc-88quad-spi-flash-ef-bc-89-ef-bc-882-ef-bc-89/" class="article-date">
      <time datetime="2015-07-27T12:41:45.000Z" itemprop="datePublished">2015-07-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/27/fpga-e6-93-8d-e4-bd-9c-e5-9b-9b-e7-ba-bf-e5-88-b6spi-flash-ef-bc-88quad-spi-flash-ef-bc-89-ef-bc-882-ef-bc-89/">FPGA操作四线制SPI FLASH（Quad SPI Flash） （2）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <hr>
<p><a href="http://www.hex55.com/2015/07/26/fpga%E6%93%8D%E4%BD%9C%E5%9B%9B%E7%BA%BF%E5%88%B6spi-flash%EF%BC%88quad-spi-flash%EF%BC%89-%EF%BC%881%EF%BC%89/" target="_blank" rel="external">FPGA操作四线制SPI FLASH（Quad SPI Flash） （1）</a></p>
<p><a href="http://www.hex55.com/2015/08/04/fpga%E6%93%8D%E4%BD%9C%E5%9B%9B%E7%BA%BF%E5%88%B6spi-flash%EF%BC%88quad-spi-flash%EF%BC%89-%EF%BC%883%EF%BC%89/" target="_blank" rel="external">FPGA操作四线制SPI FLASH（Quad SPI Flash） （3）</a></p>
<p>本文准备以SPANSION公司的S25FL128S 和 S25FL256S的datasheet为例 来说明四线SPI FLASH的操作要点。</p>
<p><img src="/uploads/2015/07/2015-07-10_174542.png" alt=""></p>
<hr>
<h2 id="SDR时序"><a href="#SDR时序" class="headerlink" title="SDR时序"></a>SDR时序</h2><p><strong>AC参数</strong></p>
<p><img src="/uploads/2015/07/2015-07-12_113800.png" alt=""></p>
<p><strong>时钟时序</strong></p>
<p><img src="/uploads/2015/07/2015-07-12_113911.png" alt=""></p>
<p><strong>输入输出时序</strong></p>
<p><img src="/uploads/2015/07/2015-07-12_114232.png" alt=""></p>
<h2 id="DDR时序"><a href="#DDR时序" class="headerlink" title="DDR时序"></a>DDR时序</h2><p><strong>AC参数</strong></p>
<p><img src="/uploads/2015/07/2015-07-12_114403.png" alt=""></p>
<p><strong>输入输出时序</strong></p>
<p><img src="/uploads/2015/07/2015-07-12_114510.png" alt=""></p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><h3 id="状态寄存器"><a href="#状态寄存器" class="headerlink" title="状态寄存器"></a>状态寄存器</h3><p><img src="/uploads/2015/07/2015-07-12_114829.png" alt=""></p>
<p>SRWD——当该寄存器位设为1的时候，如果WP#为低那么将进入硬件保护模式。在这个模式下,状态寄存器的SRWD，BP2,BP1和BP0位都将是只读的，并且写寄存器（WRR）命令将不会被接收和执行。如果WP#为高，WRWD位和BP位可以通过WRR命令进行修变。如果SRWD是0，WP#没有作用，并且可以通过WRR命令对SRWD和BP进行修改。SRWD位和主闪存阵列具有一样的非易失性耐力。</p>
<p>P&#95;EER——编程错误位，用来指示编程操作的成败。当该位置为1时指示在上一次编程中出现了错误。当用户试图去修改受保护的主存储扇区或者是OTP区域时该位也会置位。当该位置1时，可以通过清除状态寄存器（CLSR）命令来复位为0。这是一个只读位，WWR命令对它不起作用。</p>
<p>E&#95;ERR——擦除错误位，用来指示擦除操作的成败。当该位置为1时指示在上一次擦除操作中产生了错误。当用户试图去擦除无效的受保护主存储扇区时该位也会置位。当执行块擦除(Bulk_Erase)指令时如果发现扇区是受保护的，那么该位将不会置位。当该位置位为1时可以通过CLSR来复位为0.这是一个只读位，WRR命令对它不起作用。</p>
<p>BP2,BP1,BP0——这些位定义了主闪存中反编程和擦除的块。这些位与保护块的映射关系如下：</p>
<p><img src="/uploads/2015/07/2015-07-12_120647.png" alt=""></p>
<p>WEL——写使能位，该位置位为1则使能编程、写入或者是擦除操作。</p>
<p>WIP——指示器件是否正在编程、写入、擦除或者是其它操作中，在此期间新命令将会被忽略。</p>
<h3 id="配置寄存器1"><a href="#配置寄存器1" class="headerlink" title="配置寄存器1"></a>配置寄存器1</h3><p><img src="/uploads/2015/07/2015-07-12_120914.png" alt=""></p>
<p>LC——这些位用来选择SPI模式和地址与读出数据之间的潜伏期。具体如下表。</p>
<p><img src="/uploads/2015/07/2015-07-12_121052.png" alt=""></p>
<p><img src="/uploads/2015/07/2015-07-12_121133.png" alt=""></p>
<p>TBPROT——这一位用来定义状态寄存器BP2、BP1和BP0所代表的操作。</p>
<p>CR1[4]——保留，以备将来。</p>
<p>BPNV——这一位定义BP2-0是易失还是非易失。</p>
<p>TBPARM——这一位定义块参数的定位逻辑。该位为1时表示是从地址顶空间开始，为0表示从地址底部空间开始。</p>
<p>QUAD——设为1时，将数据位宽定义为4bit。</p>
<p>FREEZE——设位1时，锁定状态寄存器中的BP2-0，配置寄存器中的TBPROT、TBPRAM，还有OTP地址。</p>
<h3 id="状态寄存器2"><a href="#状态寄存器2" class="headerlink" title="状态寄存器2"></a>状态寄存器2</h3><p><img src="/uploads/2015/07/2015-07-12_121847.png" alt=""></p>
<p>ES——擦除挂起位。</p>
<p>PS——编程挂起位。</p>
<h3 id="自动引导存器"><a href="#自动引导存器" class="headerlink" title="自动引导存器"></a>自动引导存器</h3><p><img src="/uploads/2015/07/2015-07-12_124232.png" alt=""></p>
<p>自动引导寄存器提供了一种在上电复位、硬件复位或者软件复位时自动读出启动代码的手段。</p>
<h3 id="Bank地址寄存器"><a href="#Bank地址寄存器" class="headerlink" title="Bank地址寄存器"></a>Bank地址寄存器</h3><p><img src="/uploads/2015/07/2015-07-12_124422.png" alt=""></p>
<p>Bank寄存器为为只支持24位地址的命令提供附加的高位地址。当EXTADD=0时，Bank地址用作A23（共计3字节地址0）以上的地址。当EXTADD=1时，不使用Bank地址,传统的支持3字节地址的命令由支持4字节地址的命令替代。</p>
<h3 id="ASP寄存器"><a href="#ASP寄存器" class="headerlink" title="ASP寄存器"></a>ASP寄存器</h3><p><img src="/uploads/2015/07/2015-07-12_125209.png" alt=""></p>
<p>ASP是一个16位的OTP存储器，用来配置高级扇区保护（ASP）资源。</p>
<h3 id="密码寄存器"><a href="#密码寄存器" class="headerlink" title="密码寄存器"></a>密码寄存器</h3><p><img src="/uploads/2015/07/2015-07-12_125404.png" alt=""></p>
<h3 id="PPB锁定寄存器"><a href="#PPB锁定寄存器" class="headerlink" title="PPB锁定寄存器"></a>PPB锁定寄存器</h3><p><img src="/uploads/2015/07/2015-07-12_125500.png" alt=""></p>
<h3 id="PPB访问寄存器"><a href="#PPB访问寄存器" class="headerlink" title="PPB访问寄存器"></a>PPB访问寄存器</h3><p><img src="/uploads/2015/07/2015-07-12_125521.png" alt=""></p>
<h3 id="DYB访问寄存器"><a href="#DYB访问寄存器" class="headerlink" title="DYB访问寄存器"></a>DYB访问寄存器</h3><p><img src="/uploads/2015/07/2015-07-12_125600.png" alt=""></p>
<h3 id="SPI-DDR-数据学习寄存器"><a href="#SPI-DDR-数据学习寄存器" class="headerlink" title="SPI DDR 数据学习寄存器"></a>SPI DDR 数据学习寄存器</h3><p><img src="/uploads/2015/07/2015-07-12_125714.png" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/FPGA/">FPGA</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-fpga-e6-93-8d-e4-bd-9c-e5-9b-9b-e7-ba-bf-e5-88-b6spi-flash-ef-bc-88quad-spi-flash-ef-bc-89-ef-bc-881-ef-bc-89" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/26/fpga-e6-93-8d-e4-bd-9c-e5-9b-9b-e7-ba-bf-e5-88-b6spi-flash-ef-bc-88quad-spi-flash-ef-bc-89-ef-bc-881-ef-bc-89/" class="article-date">
      <time datetime="2015-07-26T02:45:52.000Z" itemprop="datePublished">2015-07-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/26/fpga-e6-93-8d-e4-bd-9c-e5-9b-9b-e7-ba-bf-e5-88-b6spi-flash-ef-bc-88quad-spi-flash-ef-bc-89-ef-bc-881-ef-bc-89/">FPGA操作四线制SPI FLASH（Quad SPI Flash） （1）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <hr>
<p><a href="http://www.hex55.com/2015/07/27/fpga%E6%93%8D%E4%BD%9C%E5%9B%9B%E7%BA%BF%E5%88%B6spi-flash%EF%BC%88quad-spi-flash%EF%BC%89-%EF%BC%882%EF%BC%89/" target="_blank" rel="external">FPGA操作四线制SPI FLASH（Quad SPI Flash） （2）</a></p>
<p><a href="http://www.hex55.com/2015/08/04/fpga%E6%93%8D%E4%BD%9C%E5%9B%9B%E7%BA%BF%E5%88%B6spi-flash%EF%BC%88quad-spi-flash%EF%BC%89-%EF%BC%883%EF%BC%89/" target="_blank" rel="external">FPGA操作四线制SPI FLASH（Quad SPI Flash） （3）</a></p>
<p>本文准备以SPANSION公司的S25FL128S 和 S25FL256S的datasheet为例 来说明四线SPI FLASH的操作要点。</p>
<p><img src="/uploads/2015/07/2015-07-10_174542.png" alt=""></p>
<hr>
<h2 id="器件的特性"><a href="#器件的特性" class="headerlink" title="器件的特性"></a>器件的特性</h2><h3 id="操作速率"><a href="#操作速率" class="headerlink" title="操作速率"></a>操作速率</h3><p><img src="/uploads/2015/07/2015-07-10_174646.png" alt=""></p>
<p>在四线DDR时读取速度可以达到66Mbytes/s，基本上与常见的NAND FLASH速度持平。编程和擦除虽仍然都比较慢，还好我的应用只在乎它的读取速度。</p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>命令—— 当CS为低的一个周期内，所有在主机和存储器之间进行传输的信息。这包括指令（有时候被称作操作码（operation code）或者opcode）和某个请求地址，模式位，潜伏期，或数据。</p>
<p>指令—— 通过一个命令传递的8bit的用于指示所要执行功能的码（有时候被称作操作码（operation code）或者opcode）。在任何命令中，指令总是从主机发往存储器的第一个8bit。</p>
<p>页—— 512字节或者254字节对齐的一组数据。页的对齐大小取决于订货型号。</p>
<p>SDR—— 输入在SCK的上升沿，输出在SCK的下降沿。</p>
<p>扇区—— 擦除的最小单位；取决于器件模型，扇区有可能是4k字节、64k字节或者256字节。</p>
<p>写入—— 任何改变易失或非易失寄存器以及非易失存储器里面数据的操作。当改变非易失数据时，擦除以及重写任何未改变的非易失数据是整个写操作的一部分，因此非易失数据是被写操作改写，同样易失数据也被改写——作为一个单操作。出现在主机系统里的非易失数据被单个写操作更新，不需要进行擦除和对扇区内的其它未受影响的数据进行重编程，</p>
<h2 id="引脚定义"><a href="#引脚定义" class="headerlink" title="引脚定义"></a>引脚定义</h2><p><img src="/uploads/2015/07/2015-07-10_193136.png" alt=""></p>
<p>注意其中的SI、SO、WP、HOLD引脚在双线或者四线模式时的复用。</p>
<ul>
<li>REST——复位</li>
<li>SCK——串行时钟</li>
<li>CS#——片选</li>
<li>SI/IO0——串行输入或者IO0</li>
<li>SO/IO1——串行输出或者IO1</li>
<li>WP#——写保护</li>
<li>HOLD/IO3——暂停串行传输或者IO3</li>
</ul>
<p><strong>地址和数据配置</strong></p>
<p>从主机到存储器以单比特宽命令传递的信息只现在SI线上。传回主机的串行数据在SO线上。</p>
<p>由主机发往存储器的以双线或者四线输出命令发送的信息只会出在现在SI线上。传回主机的串行数据在IO0和IO1（对应于双线制）上或者IO0、IO1、IO2、IO3（对应于四线制）。</p>
<p>由主机发往存储器的以双线或者四线IO（输出输入）命令发送的信息将出在现在IO0和IO1（对应于双线制）上或者IO0、IO1、IO2、IO3（对应于四线制）。传回主机的串行数据在IO0和IO1（对应于双线制）上或者IO0、IO1、IO2、IO3（对应于四线制）。</p>
<h2 id="连线框图"><a href="#连线框图" class="headerlink" title="连线框图"></a>连线框图</h2><p><strong>单线制</strong></p>
<p><img src="/uploads/2015/07/2015-07-10_194408.png" alt=""></p>
<p><strong>双线制</strong></p>
<p><img src="/uploads/2015/07/2015-07-10_194443.png" alt=""></p>
<p><strong>四线制</strong></p>
<p><img src="/uploads/2015/07/2015-07-10_194507.png" alt=""></p>
<h2 id="信号协议"><a href="#信号协议" class="headerlink" title="信号协议"></a>信号协议</h2><h3 id="时钟模式"><a href="#时钟模式" class="headerlink" title="时钟模式"></a>时钟模式</h3><h4 id="单倍数据速率（SDR）"><a href="#单倍数据速率（SDR）" class="headerlink" title="单倍数据速率（SDR）"></a>单倍数据速率（SDR）</h4><p>S25FL128S 和 S25FL256S 器件能够被微控制器以两种时钟模式驱动。</p>
<ul>
<li>MODE0， CPOL = 0， CPHA = 0</li>
<li>MODE3, CPOL = 1, CPHA = 1</li>
</ul>
<p>对于这两种时钟模式，输入总是在SCK的上沿锁存，输出总是在SCK的下沿锁存。</p>
<p>两者之间的区别是主要在挂起模式下不传输数据时时钟的极性不同。</p>
<ul>
<li>MODE0，时钟极性为0</li>
<li>MODE3，时钟极性为1</li>
</ul>
<p>如下图</p>
<p><img src="/uploads/2015/07/2015-07-10_195135.png" alt=""></p>
<p>SCK周期衡量以两个SCK的下沿为界。在MODE0下命令的第一个SCK周期的起始点是从CS为低的第一个SCK下沿算起，因为在命令开始的时候SCK已经为低。</p>
<h4 id="双倍数据速率（DDR）"><a href="#双倍数据速率（DDR）" class="headerlink" title="双倍数据速率（DDR）"></a>双倍数据速率（DDR）</h4><p>DDR命令同样也支持模式0和模式3。在DDR命令下，指令位总是在进钟的上沿锁存，跟SDR命令相同。然而，紧接着的地址和数据是同时在时钟的上沿和下沿锁存。第一个地址位在SCK的第一个上沿锁存，接下来的下沿是上一个指令位的结束。输出数据的第一位在在潜伏期结束后的第一个下沿输出。</p>
<p>SCK周期的衡量同SDR一样。</p>
<p><img src="/uploads/2015/07/2015-07-10_200117.png" alt=""></p>
<h3 id="命令协议"><a href="#命令协议" class="headerlink" title="命令协议"></a>命令协议</h3><p>所有的协议以一条用来选择传输信息类型或是器件所要执行操作的指令开始。命令可能有地址，指令修正，潜伏期，传输到存储器的数据，或者是从存储器传回的数据。所有在主机和存储器件之间的指令、地址和数据信息都是串行传输的。</p>
<p>所有从主机传往存储器的指令都是以单bit串化在SI线上。</p>
<p>单比特命令可能提供的地址和要传送的数据都只出现在SI线上。传输到主机上的数据出现在SO线上。</p>
<p>双线或者四线输出命令提供的地址和要传送的数据只出现在SI线上。传回主机的的数据串化在IO0、IO1（对应双线制）线上或IO0、IO1、IO2、IO3线上（对应四线制）。</p>
<p>四线输入输出（IO）命令的地址、要发送的数据能主传回的的数据，都串化在在IO0、IO1（对应双线制）线上或IO0、IO1、IO2、IO3线上（对应四线制）。^_^,老外好罗嗦！</p>
<p>命令以以下的方式构成：</p>
<ul>
<li>每条命令以CS低开始，以CS高结束。CS#低有效。</li>
<li>SCK时钟是bit或者bit串的标记。</li>
<li>每条命令以8bit的指令开始。指令总是只会呈现在SI线上，并且在每个SCK的下沿传送到存储器件。</li>
<li>指令可以单独传递，也可以跟随用于定位器件内部地址空间的地址位。指令决定了要用的地址空间。地址可能是24位或者32位的。在SDR模式下地址传输发生在SCK的上沿，在DDR模下传输发生在SCK的每个沿。</li>
<li>紧接着要传输的位宽取决于所传送的指令。接下来的传输可能是单bit只呈现在SI线或者SO线上，也有可能是2bit呈现在IO0和IO1线上，或者是4bit呈现在IO0-IO3上。对于双线或者四线制，最低位呈现在IO0上。更多的位依次轮序呈现在更高的位上。单bit或者并行bit也是先传送最低位。</li>
<li>有些指令会发送一个叫作模式位的指令修正，接下来是地址位，用以指示接下来的命令隐含一条相同的指令。下一条命令将不提供指令类型，只提供新地址和模式修正位。这样减少了重复同类型指令对带宽的占用。模式位在SDR模式下发生在SCK的上沿，在DDR模式下发生在SCK的每一个沿。</li>
<li>寄存器或者模式位可能紧随一个将数据存储到存储器的写入操作或者一个伴随潜伏期的返回数据给主机的读操作。</li>
<li>对SDR，写数据位发生在SCK的上沿；对DDR，写数据位发生在SCK的每一个沿。</li>
<li>SCK在读访问潜伏期会持续翻转。潜伏期会在几个SCK后归零。在读潜伏期结束后，第一位输出数据将会在SCK下沿呈现。接下来的比特位在SDR模式下会在每个SCK上沿传递，而对DDR则在SCK的每个沿传递。</li>
<li>如果命令会返回数据给主机，那么数据会持续发送直到主机将CS#拉高。CS#线可以在任意传输序列被拉高，这样将会终止命令。</li>
<li>命令结束后不会有数据返回，CS#被主机拉高。CS#信号必须在一条独立指令或者是最后一个被传输写入字节的第8拉高。也就是说，CS#信号的拉高必须在CS#被拉低后N*8个时钟周期拉高。如果CS#没有精准地以8 SCK为界，那么这条命令将被拒决而不会被执行。</li>
<li>所有的指令、地址和模式位都是以大端模式移位传输。器件的输出也是以大端模式移位输出。所有的数据都是从低地址开始传输。即地址自增。</li>
<li>所有试图在存储器编程、擦除或者写期间对闪存进行的读操作都将会被忽略。内部正在进行的操作将会继续执行而不会受影响。有一部分非常有限的指令可以在内部操作正在进行时仍能被接受。我们会在命令描述部分单独地讨论。</li>
<li>执行时间取决于命令。读状态信号的命令可以用来判断命令何时完成以及是否成功执行。</li>
</ul>
<h3 id="命令示例"><a href="#命令示例" class="headerlink" title="命令示例"></a>命令示例</h3><p><strong>只含指令的命令</strong></p>
<p><img src="/uploads/2015/07/2015-07-10_214158.png" alt=""></p>
<p><strong>单bit位宽的输入命令</strong></p>
<p><img src="/uploads/2015/07/2015-07-10_214219.png" alt=""></p>
<p><strong>单bit位宽的输出命令</strong></p>
<p><img src="/uploads/2015/07/2015-07-10_214241.png" alt=""></p>
<p><strong>不带潜伏期单bit位宽IO命令</strong></p>
<p><img src="/uploads/2015/07/2015-07-10_214311.png" alt=""></p>
<p><strong>带潜伏期单bit位宽IO命令</strong></p>
<p><img src="/uploads/2015/07/2015-07-10_214339.png" alt=""></p>
<p><strong>双bit位宽输出命令</strong></p>
<p><img src="/uploads/2015/07/2015-07-10_214405.png" alt=""></p>
<p><strong>四bit位宽输出命令</strong></p>
<p><img src="/uploads/2015/07/2015-07-10_214450.png" alt=""></p>
<p><strong>双bit位宽IO命令</strong></p>
<p><img src="/uploads/2015/07/2015-07-10_214505.png" alt=""></p>
<p><strong>四bit位宽IO命令</strong></p>
<p><img src="/uploads/2015/07/2015-07-10_214526.png" alt=""></p>
<p><strong>DDR快速读</strong></p>
<p><img src="/uploads/2015/07/2015-07-10_214542.png" alt=""></p>
<p><strong>DDR双IO读</strong></p>
<p><img src="/uploads/2015/07/2015-07-10_214557.png" alt=""></p>
<p><strong>DDR四IO读</strong></p>
<p><img src="/uploads/2015/07/2015-07-10_214616.png" alt=""></p>
<p><strong>接口状态</strong></p>
<p><img src="/uploads/2015/07/2015-07-10_214654.png" alt=""></p>
<p><img src="/uploads/2015/07/2015-07-10_214719.png" alt=""></p>
<p><img src="/uploads/2015/07/2015-07-10_214736.png" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/FPGA/">FPGA</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-keil-mdk-e5-92-8c-iar-ewarm-ide-e4-b8-adstl-e5-ae-9e-e7-8e-b0-e7-9a-84-e6-af-94-e8-be-83" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/23/keil-mdk-e5-92-8c-iar-ewarm-ide-e4-b8-adstl-e5-ae-9e-e7-8e-b0-e7-9a-84-e6-af-94-e8-be-83/" class="article-date">
      <time datetime="2015-07-23T12:36:35.000Z" itemprop="datePublished">2015-07-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/23/keil-mdk-e5-92-8c-iar-ewarm-ide-e4-b8-adstl-e5-ae-9e-e7-8e-b0-e7-9a-84-e6-af-94-e8-be-83/">KEIL MDK 和 IAR EWARM IDE中STL实现的比较</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <hr>
<p>最近的一个项目用到了C++的STL，芯片是STM32F030F4，目的是为了实现一个多功能定时器，只是用到了vector，结果同样的代码KEIL编译出来要了我15K左右，而IAR只需要9K左右。代码上唯一的区别就是IAR不支持namespace（在IAR中需要将std定义为空<code>#define std</code>）,而KEIL支持<code>using namespace std;</code>。就算在都将优化设为无的情况下IAR和KEIL的代码生成率（仅指源码到固件大小的转化率）有一定差异，但应该也不会大到成倍数关系，从我个人的理解namespace这种东西是编译器处理的，不需要消耗额外的FLASH空间。那么我不得不想到二者STL的实现。</p>
<h3 id="IAR的STL实现"><a href="#IAR的STL实现" class="headerlink" title="IAR的STL实现"></a>IAR的STL实现</h3><p>从注释（在vector文件的最底部）上可知，IAR EWARM用的是P.J. Plauger STL版本的STL，其继承自HP公司。</p>
<pre><code>/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * &quot;as is&quot; without express or implied warranty.
 */

/*
 * Copyright (c) 1992-2009 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.04:0576 */

`&lt;/pre&gt;

P.J. Plauger STL的简介如下：

&gt; P. J. Plauger STL属于个人作品，由P. J. Plauger本人实现，是HP STL的一个继承版本，因此在其所有头文件中都含有HP STL的相关声明，同时还有P. J. Plauger本人的版权声明。P. J. Plauger是标准C中stdio库的早期实现者，现在是C/C++ User&apos;s Journal的主编，与Microsoft保持着良好的关系。P. J. Plauger STL便是被用于Microsoft的Visual C++中的。在Windows平台下的同类版本中，其性能不错，但是queue组件（队列，一种容器）的效率不理想，同时由于Visual C++对C++语言标准的支持不是很好（至少直到VC6.0为止，还是如此），因此一定程度上影响了P. J. Plauger STL的性能。此外，该版本的源代码可读性较差，你可以在VC的Include子目录下找到所有源文件（比如：C:/Program Files/Microsoft Visual Studio/VC98/Include）。因为不是开放源码的（open source），所以这些源代码是不能修改和销售的，目前P.J. Plauger STL由Dinkumware公司提供相关服务，详情请见http://www.dinkumware.com。据称Visual Studio.NET中的Visual C++.NET（即VC7.0），对C++标准的支持有所提高，并且多了以哈希表（hash table）为基础而实现的map容器，multimap容器和set容器。

### KEIL的STL实现

从注释（vector文件的顶部）可以看到，最初都是由HP的STL而来，但KEIL MDK用的是Rouge Wave STL。

&lt;pre&gt;`
/***************************************************************************
 *
 * vector - declarations for the Standard Library vector class
 *
 * $Id: vector 172106 2011-11-02 17:04:12Z statham $
 *
 ***************************************************************************
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided &quot;as is&quot; without express or implied warranty.
 *
 ***************************************************************************
 *
 * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
 *
 * This computer software is owned by Rogue Wave Software, Inc. and is
 * protected by U.S. copyright laws and other laws and by international
 * treaties.  This computer software is furnished by Rogue Wave Software,
 * Inc. pursuant to a written license agreement and may be used, copied,
 * transmitted, and stored only in accordance with the terms of such
 * license and with the inclusion of the above copyright notice.  This
 * computer software or any other copies thereof may not be provided or
 * otherwise made available to any other person.
 *
 * U.S. Government Restricted Rights.  This computer software is provided
 * with Restricted Rights.  Use, duplication, or disclosure by the
 * Government is subject to restrictions as set forth in subparagraph (c)
 * (1) (ii) of The Rights in Technical Data and Computer Software clause
 * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
 * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
 * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
 * Flatiron Parkway, Boulder, Colorado 80301 USA.
 *
 **************************************************************************/
</code></pre><p>关于Rouge Wave STL的简介如下：</p>
<blockquote>
<p>Rouge Wave STL是由Rouge Wave公司实现的，也是HP STL的一个继承版本，除了HP STL的相关声明之外，还有Rouge Wave公司的版权声明。同时，它也不是开放源码的，因此无法修改和销售。该版本被Borland C++ Builder所采用，你可以在C++ Builder的Include子目录下找到所有头文件（比如：C:/Program Files/Borland/Cbuilder5/Include）。尽管Rouge Wave STL的性能不是很好，但由于C++ Builder对C++语言标准的支持还算不错，使其表现在一定程度上得以改善。此外，其源代码的可读性较好。可以从如下网站得到更详细的情况介绍：<a href="http://www.rougewave.com。遗憾的是该版本已有一段时间没有更新且不完全符合标准。因此在Borland" target="_blank" rel="external">http://www.rougewave.com。遗憾的是该版本已有一段时间没有更新且不完全符合标准。因此在Borland</a> C++ Builder 6.0中，它的地位被另一个STL的实现版本–STLport（见后）取代了。但是考虑到与以前版本的兼容，C++ Builder 6.0还是保留了Rouge Wave STL，只是如果你想查看它的源代码的话，需要在别的目录中才能找到（比如：C:/Program Files/Borland/Cbuilder6/Include/oldstl）。</p>
</blockquote>
<p>目前注流的STL版本还包括STLport（俄国人Boris Fomitchev的一个开发项目），SGI STL（原STL作者离开HP后去Silicon Graphics Computer System公司所写）等。</p>
<p>另外我为了减小代码，试图去网上寻找一些专用于嵌入式的STL，发现了这个东西<a href="https://msharov.github.io/ustl/" target="_blank" rel="external">uSTL - the small STL library</a>，折腾半天没编译通过，文档不是太齐，里面的CONF文件也懒得去细究。</p>
<p>最后考虑到我本来只是用到VECOTR，何不自己实现一个，当然先从网上找个参考实现，编译了一下，发现并没任何空间上的优势，奇怪的是这个测试代码我用IAR编译居然要8K，用KEIL编译居然只要2K。等有时间我再去细究吧，目前就先用IAR EWARM自带的STL算了，KEIL MDK的兼容后面再去考虑算了。另外我注意到IAR是支持.h调试的，而KEIL根本不支持。我原本打算把成员函数写到.cpp中去，后来偷懒就用了一些省码字的做法，直接写到类的声明里了。等有空再细究，实现一个不依赖STL的版本，唉码农就是受折腾。</p>
<hr>
<p><strong>原先以为IAR不支持STD的namespace，后来才发现是它的EC++不支持，它的C++是支持的，而且还支持RTTI和异常。</strong></p>
<p><a href="/uploads/2015/07/2015-07-24_083045.png"><img src="/uploads/2015/07/2015-07-24_083045.png" alt="2015-07-24_083045"></a></p>
<p>后来才明白原来我没能正确理解它文档中的这一段话:</p>
<blockquote>
<p>The std namespace is not used in either standard EC++ or in Extended EC++. If you<br>  have code that refers to symbols in the std namespace, simply define std as nothing;<br>  for example:<br>  &#35;define std // Nothing here</p>
</blockquote>
<p><strong>未完待续</strong></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/MCU-ARM/">MCU/ARM</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-altclkctrl-e4-bd-bf-e7-94-a8-e6-b3-a8-e6-84-8f-e4-ba-8b-e9-a1-b9" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/22/altclkctrl-e4-bd-bf-e7-94-a8-e6-b3-a8-e6-84-8f-e4-ba-8b-e9-a1-b9/" class="article-date">
      <time datetime="2015-07-22T08:38:04.000Z" itemprop="datePublished">2015-07-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/22/altclkctrl-e4-bd-bf-e7-94-a8-e6-b3-a8-e6-84-8f-e4-ba-8b-e9-a1-b9/">ALTCLKCTRL使用注意事项</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <hr>
<p>最近项目中因为要模块的输入时钟要在PLL和外部时钟之间进行切换，用到了ALTCLKCTRL（ALTCLKCTRL可以实现时钟的无毛刺切换），本来觉得这玩意直接添加连上线就可以了，后来才发现还有好些地方要注意。</p>
<pre><code>clkCtrlCap u_clkCtrlCap 
(
    .clkselect({~wIsClkExt, 1&apos;b0}),
    .ena(wEnClkCtrl),
    .inclk0x(clkExt),               //glitch-free的功能电路需要目前被选择的时钟在正常运行，
                                        //clkselect[1..0]的缺省输入值是00，所以需要在inclk0x端口有一个初始时钟
    .inclk1x(clkExt2),              //该路时钟不使用
    .inclk2x(clkCap),
    .outclk(_clkCap)
);
</code></pre><p>在第一次用的时候，我懒得去读手册，结果报错：</p>
<blockquote>
<p>Error (15660): inclk[0] port of Clock Control Block “…” is driven by system_ctrl:…wire_pll1_clk[3], but must be driven by a clock pin</p>
</blockquote>
<p>后来一翻《Clock Control Block (ALTCLKCTRL) Megafunction》手册才知道ALTCLKCTRL的inClk对引脚是有限制的，inclk[0]，inclk[1]只能用外部引脚驱动，inclk[2], inclk[3]只能是PLL的输出。而我刚好把PLL的输出放到了inclk[0],尽管我是想让我的设计在默认情况下由PLL输出的时钟驱动（ALTCLKCTRL默认选择inclk[0]作为输出）。</p>
<blockquote>
<p>When the clkselect port is used, the inclk ports of a Clock Control Block must only be driven by clock pins or PLL clock outputs.The inclk[0] and inclk[1] need to be driven by pins and inclk[2] and inclk[3] need to be driven by a PLL output.<br>  <img src="/uploads/2015/06/clockControlBlock.png" alt=""></p>
</blockquote>
<p>修改完之后，结果又报以下错误：</p>
<blockquote>
<p>Error (176365): Can’t place node clkExt2~input at location PIN T9 (CLK12, DIFFCLK_7n) – node uses Clock Control Block inclk port(s) 1 but the location can only use Clock Control Block inclk port(s) 0</p>
<p>  Error (176366): Node “clkExt2~input” uses inclk port 1 of Clock Control Block capSignal:u_capSignal|clkCtrlCap:u_clkCtrlCap|clkCtrlCap_altclkctrl_9gi:clkCtrlCap_altclkctrl_9gi_component|clkctrl1</p>
</blockquote>
<p>引脚锁定有误，我查看了我的设计是采用的专用时钟管脚啊，怎么不行？<br>又换其它时钟引脚，换来换去发现仍然不能解决，只能又去查资料，在《Clock Networks and PLLs in Cyclone IV Devices》中查找到了原因。</p>
<p>如下图,</p>
<p><img src="/uploads/2015/06/atlclkctrl.png" alt=""><br>从图中可以看到我所用的器件有4个全局Clock control block模块，每个模块都是如上图所示的结构，如果采用全局Clock control block模块，则有要求所有的INCLK引脚属于同一个Clock control block模块，否则不能连接。<br>因此我最终将外部输入时钟锁定在了与工程所用PLL处于同一Clock control block的引脚。<br><img src="/uploads/2015/06/altclkpin.png" alt=""><br>我的PLL输入引脚是R9，外部时钟输入引脚分别是T8，R8，编译通过。</p>
<p>最后还有一点要注意，我的原设计中是没有ena信号的，后来我在搜索ALTCLKCTRL资料时看到了ALTERA的官网有如下一段话。<br><img src="/uploads/2015/06/altclkctrl_guide.png" alt=""><br>而我的设计中外部时钟输入引脚被用在了inclk[0]和inclk[1],且不能保证该外部输入引脚一定有时钟，而在默认情况下是使能inclk[0]的，为了实现无毛刺我最依照指导加上了对ena信号的处理。</p>
<p>最最后，补上一篇关于ALTERA器件时钟资源的好文章<a href="http://bbs.ednchina.com/BLOG_ARTICLE_198994.HTM" target="_blank" rel="external">掌控全局时钟网络资源</a>。为避免链接失效，摘录一段，以供搜索。</p>
<blockquote>
<p>由上面的表可以知道，外部时钟管脚可以根据需要连接CLK[0..3]任意一个专用时钟输入脚，具体选择由QuartusII软件自动分配完成。也就是说，在FPGA的一侧连入五个全局时钟时，我们可以根据布线要求任意把时钟连至CLK[0..3]之一，但是每侧最多只能连五个全局时钟，如果我们需要在外部连入两个时钟时，并假设连接在CLK0，CLK1时，它们中的一个将无法占用全局时钟资源，改走普通布线资源，具体哪一个由QuartusII判断决定。由于普通布线资源会造成时钟到达各个寄存器不尽相同，也就是CLK SKEW会很大，时序收敛性能就大大减低，所以，我们需要将CLK0，CLK1中的一个连至下一组时钟专用管脚CLK[4..7]，全部时钟都在全局时钟网络上。</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/FPGA/">FPGA</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e6-98-8e-e6-99-ba-e5-9c-b0-e5-a4-84-e7-90-86-e5-a4-8d-e4-bd-8d-ef-bc-9a-e8-80-83-e8-99-91-e5-b1-80-e9-83-a8-ef-bc-8c-e8-80-8c-e4-b8-8d-e6-98-af-e5-85-a8-e5-b1-80" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/21/e6-98-8e-e6-99-ba-e5-9c-b0-e5-a4-84-e7-90-86-e5-a4-8d-e4-bd-8d-ef-bc-9a-e8-80-83-e8-99-91-e5-b1-80-e9-83-a8-ef-bc-8c-e8-80-8c-e4-b8-8d-e6-98-af-e5-85-a8-e5-b1-80/" class="article-date">
      <time datetime="2015-07-21T10:33:35.000Z" itemprop="datePublished">2015-07-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/21/e6-98-8e-e6-99-ba-e5-9c-b0-e5-a4-84-e7-90-86-e5-a4-8d-e4-bd-8d-ef-bc-9a-e8-80-83-e8-99-91-e5-b1-80-e9-83-a8-ef-bc-8c-e8-80-8c-e4-b8-8d-e6-98-af-e5-85-a8-e5-b1-80/">在FPGA中明智地处理复位：考虑局部，而不是全局</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>原文<a href="http://www.xilinx.com/support/documentation/white_papers/wp272.pdf" target="_blank" rel="external">《Get Smart About Reset: Think Local, Not Global》</a></p>
<p>作者： Ken Chapman</p>
<p>版本：v1.0.1</p>
<p>译者： shawge</p>
<hr>
<p>数字设计界有一条诫律，“你不应该对所有的触发器采用同一个主复位，那样你的测试工程师会喜欢你，而且你的仿真也永远不会出现不确定”。（好绕口，可能是我没能理解他的意思^_^）</p>
<p>因此，有些人会对此感觉到意外——在你的FPGA设计中采用全局复位设计不是一个好主意，并且应该避免这种情况。清楚一点讲，这是一个有争议的问题，来让我们看一看为什么这样一个设计原则应当被遵巡。</p>
<h3 id="全局复位不是关键时序"><a href="#全局复位不是关键时序" class="headerlink" title="全局复位不是关键时序"></a>全局复位不是关键时序</h3><p>一个典型的全局复位驱动是怎样的呢？</p>
<ul>
<li>按压式开关：无疑非常的慢，但是时序不确定。</li>
<li>上电复位：复位一直有效，直到电源到达稳定态。</li>
<li>微控制器驱动：一个较长的脉冲。</li>
</ul>
<p>在以上这些情况下，看起来复位信号都是很慢；因此，看起来假定这不是一个关键时序是足够安全。当对你的FPGA时序进行约束时，这个信号通常会被作为长周期（低频）处理。</p>
<p>然而，严格地讲假定全局复位不是关键时序是不正确的，并且随着时钟速率的提高这会是一个更严重的问题。</p>
<p>尽管在复位期间，复位脉冲相对于时钟周期来讲可能很长，并且能够保证所有的触发器复位，复位信号的释放应被作为一个关键问题加以考虑。</p>
<p>器件内部的全局复位/置位（GSR）的释放也是一个全局复位，并且因为它是硅器件的一部分，它是不可靠的。这也是器件内的一个高扇出网络。而启动顺序能够被一个“用户时钟”同步，它不能被一个设计中的所有时钟同步。器件可能有好几个DLL/CDM/PLL模块，每一个都能产生好几个时钟和时钟相位。<br>如图1，一个复位信号在时钟的边沿失效。然后信号被传播到各个触发器。在每一个触发器，信号都将被失效一个“建立周期”在有效时钟沿前。很明显，随着时钟频率的上升，可用于复位信号的时间将会下降。假定复位认号是一个高扇出网络，要满足失效时序将是一个巨大的挑战。</p>
<p><img src="/uploads/2015/06/Reset_Timing_Diagram1.png" alt=""></p>
<p>如果复位信号相对时钟是异步释放的（通常如此），这将没有办法去保证所有的触发器会在同一个进钟沿释放，即使分配的时问小于一个时钟周期（如图2）。</p>
<p><img src="/uploads/2015/06/Reset_Timing_Diagram2.png" alt=""></p>
<p>在A点接收到复位释放的触发器将会在第一个时钟沿激活，但是在C点接收到复位释放的寄存器将不会被激活，直到最后一个时钟沿。而在B点的触发器不确定，并且可能导致亚稳态。</p>
<p>随着时钟频率的增加以及大器件中潜在的分布倾斜，它将几乎变成一个必然——不是所有的寄存器都能在同一个时钟沿释放（如图3）。</p>
<p><img src="/uploads/2015/06/Reset_Timing_Diagram3.png" alt=""></p>
<h3 id="它真的重要吗？"><a href="#它真的重要吗？" class="headerlink" title="它真的重要吗？"></a>它真的重要吗？</h3><p>好消息是99.99%的时间里，复位释放是不重要的。有了这样的统计数据，大多数电路能正常工作并不惊奇。然而，如果你曾经有过一个第一次工作就不正常的电路，那么你很可能是遇到了这个0.0%的情况，并且你刚好运气比较差在一个错误的时机释放了复位。</p>
<p>在这个情形中复位的释放时序并重要，见图4。</p>
<p><img src="/uploads/2015/06/Reset_Timing_Diagram4.png" alt=""></p>
<p>当一个数据通过一个流水处理时，当主复位被释放这并不重要。在一些周之后，整个流水将会被操作，任何不正确的数据将会被冲到系统外。事实上，有一个小要点在完全复位。尽管仿真将会按配置流程初始化，或者未定义的状态将会被净化出系统因为有效数据输入。</p>
<p>然而，图5展示了一个释放时机序很重要的情形。</p>
<p><img src="/uploads/2015/06/Reset_Timing_Diagram5.png" alt=""></p>
<p>在这个例子中是一个简单的独热码状态机，它有一个明确的潜在失败。如果第一个含有独热状态的触发器比第二触发器早一个时钟周期释放，那么独热状诚将会丢失并且状态机将再也不能运行。往往通过让参与的寄存器更靠近来降低这种问题发生的可能（本地复位网络有着更小的倾斜）。然而除非建立时间有保证，否则它将仍会发生。也有可能编码状态被转换成了一个意外状态，包括非法状态，如果所有触发器不是在同一个时钟沿释放的话。</p>
<p>最终电路包含反馈路径，这将要求非常小心的复位条件。</p>
<p>不包含反馈的电路真的完全不需要复位。在数字信号处理应用中，一个有限脉冲响应滤波器不需要反馈。输出样本没有有效值直到有效数据填充所有的寄存器，所以复位寄存器没有什么用。然而一个无限脉冲响应滤波器含有反馈。如果因为一个不干净的复位导致一个寄生输出样本，那么输出样本将会在一个显著的时间周期内被影响。最坏的情况下，可能因为不稳定导致滤波器彻底失效。</p>
<h3 id="自动覆盖99-99-的情况"><a href="#自动覆盖99-99-的情况" class="headerlink" title="自动覆盖99.99%的情况"></a>自动覆盖99.99%的情况</h3><p>当一个Xilinx FPG被配置或者被重配置，每一个单元都会被初始化（如图6）。这是一个最终的主复位，因为它远远不只包含了简单的触发器(发图6)。</p>
<p><img src="/uploads/2015/06/Reset_Timing_Diagram6.png" alt=""></p>
<p>配置同样有一个全局复位效果，因为它也会初始化RAM单元。当嵌在器件内的可用RAM增加时，这将会一个非常有用的特性。要知道所有的RAM内容是被预定义的，对仿真和操作是是理想的，并且无需由启动顺序来清除。</p>
<p>因为在Xilinx器件内可以嵌入一个硬核或者软核的处理器，所有的程序和数具区域都被定义好了，在处理器执行每一条指令之前。Xilnix器件拥有这样天然的优势，仅仅为了复位寄存器消耗宝贵的可编程资源没有任何意义。仿真器应该能够对这种初始化建模（经常被称作上电复位），这又避免了任何在你设计中要求的复位。</p>
<h3 id="应对0-01-的状况"><a href="#应对0-01-的状况" class="headerlink" title="应对0.01%的状况"></a>应对0.01%的状况</h3><p>在你的设计中有一个掌管复位的策略是最重要的事情，并且这些策略包含在设计评定时器中。在设计中的相关部分必须与相关时域同步释放。一个本地的高效复位网络能够被插入为了控制这些要求本地复位的寄存器。</p>
<p>图7的电路中展示了一个有用的本地网络复位机制。这个电路跟器件的优点在于提供了和器件配置相同的作用，当外部信号施加于它时。</p>
<p><img src="/uploads/2015/06/Reset_Timing_Diagram7.png" alt=""></p>
<p>在器件配置期间一个异步复位信号，所有在这条链上的触发器都会预置为1.几乎同时，这条链上的最后一个触发器驱动了全局复位网络。伴随着GSR或者异步复位信号的释放，移位寄存器链开始在每个时钟周期逐步被填为0态。</p>
<p>在这条链上的触发器的数量决定了被施加到本地网络上的复位脉冲的最小持续时间。最终，最后一个触发器使传输由高变低，并且本地复位伴随时钟被同步释放。寄存可采用同步置位或同步复位来让一个设计完全同步化，并且简化时序约束和分析。</p>
<h3 id="复位的成本比你认为的要多"><a href="#复位的成本比你认为的要多" class="headerlink" title="复位的成本比你认为的要多"></a>复位的成本比你认为的要多</h3><p>在实现一个设计时，HDL代码中的全局复位代价可以被忽略。然而，这些成本是显著的：</p>
<ul>
<li><p>被用掉的器件布线资源。</p>
<pre><code>1.  降低了其它连接的自由度。
</code></pre><ol>
<li>可能潜在的降低系统的性能，从而导致要使用一个更高速度等级的器件。</li>
<li>增加了布线时间。</li>
</ol>
</li>
<li><p>被用掉的逻辑资源。</p>
<pre><code>1.  用掉了专用的复位寄存器。
</code></pre><ol>
<li>复位操作导致在D触发器前增加了门电路或者是专用复位输入。</li>
<li>几乎肯定会影响设计的大小。</li>
<li>增加的逻辑几乎肯定会影响系统的性能。</li>
<li>布加了布局和布线时间。</li>
</ol>
</li>
<li><p>让高效资源不能被使用，比如SRL16E。</p>
<pre><code>1.  SRL16E在每个LUT中实出了16个触发器。
</code></pre><ol>
<li>这些虚拟的触发器不支持复位，并且这会妨碍综合工具发挥这些特性的完整优势，如果在HDL中强制复位的话。</li>
<li>将会产生超过16倍的大小和成本。</li>
<li>增加潜在的大小会降低系统的性能。</li>
<li>增加布局布线的时间。</li>
</ol>
</li>
</ul>
<p>有关复位优先级如何影响资源的利用律的讨论可以参考<a href="http://www.xilinx.com/support/documentation/white_papers/wp275.pdf" target="_blank" rel="external">WP275</a> 《Get your Priorities Right - Make your Design Up to 50% Smaller》。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在Xilnix FPGA的设计实现中不要求插入一个全局复位网络。对于绝大多数设计，RAM配置的触发器初始化流程永远都比逻辑复位更全面。仿真中不要求插入复位，因为没有任何东西是不确定的。自从Xilnix FPGA已经被执行硅片级的全测试，在设计中进行逻辑扫描和运行向量测试都是不必要的。因此，全局复位也是不必要处理的一部分。</p>
<p>插入一个全局复位将会影响开发时间和最终的产品成本，尽管时间和成本不能简单等价。随着向更高时钟和片上系统发展的趋势，可靠性问题必须被更严肃地对待。系统中必须真正复位的关键部分应该在系统启动和操作期被确定释放，并且必须小心地控制同步电路。</p>
<p><strong>在设计创建的每一个环节，请简单地问一句“它真地需要复位吗”？</strong></p>
<hr>
<h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><p>从我接触FPGA开始我就不断的看到讲述复位如何重要的文章,我也试图找一些更为透彻的文章来理解，同时我也不断的在别人的代码中看到所谓的“异步复位同步释放”或者又称“同步化的异步复位”，我也在我的代码中使用这种技巧，但总觉得如梗在喉，即便是在翻译完这篇文章之后仍然如此，今天看到一篇好文章，虽然感觉翻译不是太好，但讲解还是比较给力，推荐之<a href="http://www.eefocus.com/coyoo/blog/13-12/301045_9c39f.html" target="_blank" rel="external"> FPGA复位电路的实现及其时序分析</a>。为避免将来链接失效，特摘录一部分</p>
<blockquote>
<p>异步复位的一个最大优点是，它们没有象同步复位那样插入到数据路径中。因此，异步复位对寄存器之间的数据到达时间不产生任何负面影响。另一个优点是，它们一般都是即刻生效。只要寄存器收到复位脉冲，寄存器将被即刻复位，而不管相对于时钟的时序关系。所以异步复位不象同步复位那样依赖于时钟。<br>           电路使用异步并没有任何问题，只是在复位被释放的时候可能会出现问题，所谓的复位释放（Release）有时候也被称为复位去除（Removal）。当复位撤除时，它必须满足异步微建立时间，即µtSU。这个可以在TimeQuest里使用Recovery时间检查来得到确认。此外，复位撤除时，它也必须要满足微保持时间，即µtH。同样可以在TimeQuest使用Removal时间检查来得到确认。总之，上述两种Check被称为Rcovery/Removal分析。</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/FPGA/">FPGA</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e9-ab-98-e9-80-9f-e7-ba-bf-e9-98-b5ccd-e5-a4-96-e5-be-84-e6-b5-8b-e9-87-8f-e4-bb-aa-e5-8e-9f-e7-90-86-e5-9b-be-e5-ae-8c-e5-b7-a5" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/20/e9-ab-98-e9-80-9f-e7-ba-bf-e9-98-b5ccd-e5-a4-96-e5-be-84-e6-b5-8b-e9-87-8f-e4-bb-aa-e5-8e-9f-e7-90-86-e5-9b-be-e5-ae-8c-e5-b7-a5/" class="article-date">
      <time datetime="2015-07-20T13:18:16.000Z" itemprop="datePublished">2015-07-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/20/e9-ab-98-e9-80-9f-e7-ba-bf-e9-98-b5ccd-e5-a4-96-e5-be-84-e6-b5-8b-e9-87-8f-e4-bb-aa-e5-8e-9f-e7-90-86-e5-9b-be-e5-ae-8c-e5-b7-a5/">高速线阵CCD外径测量仪原理图完工</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>这个事情做了有一段时间了，中间断断续续，一开始对线性CCD的信号处理和时序不太清楚，后面对后端处理电路选型反反复复地考虑、修改，接下来的事就是按部旧搬地画PCB板了。</p>
<p><a href="/uploads/2015/07/2015-07-20_211006.png"><img src="/uploads/2015/07/2015-07-20_211006-300x215.png" alt="2015-07-20_211006"></a></p>
<p><a href="/uploads/2015/07/2015-07-20_211023.png"><img src="/uploads/2015/07/2015-07-20_211023-300x207.png" alt="2015-07-20_211023"></a></p>
<p>这里公开我的线性CCD前端的AD处理部分电路（<strong>点击查看大图</strong>），改天抽空细细地整理一下线阵CCD的相关知识。</p>
<p><a href="/uploads/2015/07/2015-07-20_211725.png"><img src="/uploads/2015/07/2015-07-20_211725-300x192.png" alt="2015-07-20_211725"></a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/硬件设计/">硬件设计</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/7/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/9/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2016 shawge
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/luuman/hexo-theme-spfk" target="_blank">spfk</a> by luuman
            </div>
        </div>
        
    </div>
</footer>

    </div>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 17;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>