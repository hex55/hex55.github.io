<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>hex55</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="hex55">
<meta property="og:url" content="http://hex55.com/page/3/index.html">
<meta property="og:site_name" content="hex55">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="hex55">
  
    <link rel="alternative" href="/atom.xml" title="hex55" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: false,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img src="/img/head.jpg" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/">shawge</a></h1>
        </hgroup>

        
        <p class="header-subtitle">shawge的电子技术分享</p>
        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">博客首页</a></li>
                        
                            <li><a href="/categories/MCU-ARM/">MCU/ARM</a></li>
                        
                            <li><a href="/categories/FPGA/">FPGA</a></li>
                        
                            <li><a href="/categories/windows-linux/">WINDOWS/LINUX</a></li>
                        
                            <li><a href="/categories/硬件设计/">硬件设计</a></li>
                        
                            <li><a href="/archives/">文章归档</a></li>
                        
                            <li><a href="/about/">留言给我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail" target="_blank" href="http://hex55@qq.com" title="mail">mail</a>
                            
                                <a class="fl github" target="_blank" href="https://github.com/hex55" title="github">github</a>
                            
                                <a class="fl rss" target="_blank" href="/atom.xml" title="rss">rss</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/github-提速/" style="font-size: 10px;">github 提速</a>
                    </div>
                </section>
                
                
                

                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">没想好。。。</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">shawge</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img src="/img/head.jpg" class="js-avatar" style="width: 100%; height: 100%; opacity: 1;">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">shawge</a></h1>
            </hgroup>
            
            <p class="header-subtitle">shawge的电子技术分享</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">博客首页</a></li>
                
                    <li><a href="/categories/MCU-ARM/">MCU/ARM</a></li>
                
                    <li><a href="/categories/FPGA/">FPGA</a></li>
                
                    <li><a href="/categories/windows-linux/">WINDOWS/LINUX</a></li>
                
                    <li><a href="/categories/硬件设计/">硬件设计</a></li>
                
                    <li><a href="/archives/">文章归档</a></li>
                
                    <li><a href="/about/">留言给我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="http://hex55@qq.com" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/hex55" title="github">github</a>
                    
                        <a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-altium-designer-e8-87-aa-e5-8a-a8-e6-b7-bb-e5-8a-a0-e5-b1-8f-e8-94-bd-e5-ad-94-ef-bc-88-e5-8c-85-e5-9c-b0-e5-ad-94-ef-bc-89" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/22/altium-designer-e8-87-aa-e5-8a-a8-e6-b7-bb-e5-8a-a0-e5-b1-8f-e8-94-bd-e5-ad-94-ef-bc-88-e5-8c-85-e5-9c-b0-e5-ad-94-ef-bc-89/" class="article-date">
      <time datetime="2015-12-22T09:48:24.000Z" itemprop="datePublished">2015-12-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/22/altium-designer-e8-87-aa-e5-8a-a8-e6-b7-bb-e5-8a-a0-e5-b1-8f-e8-94-bd-e5-ad-94-ef-bc-88-e5-8c-85-e5-9c-b0-e5-ad-94-ef-bc-89/">altium-designer-自动添加屏蔽孔（包地孔）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>通常对时钟线及一些重要的信号线我们需要添加屏蔽过孔（Via Shielding），也即俗称的包地。以前都是一个个自己加过孔，又难看又费力，Altium designer的过孔粘贴功能不是很好用，带网络的粘贴又没有快捷键，每次都提点鼠标操作。现在AD15（具体从哪个版本开始我不清楚，反正我下载的AD15.1.15是有的）有了自动给网络添加包地孔的功能。</p>
<p><a href="/uploads/2015/12/Via-Shielding.png"><img src="/uploads/2015/12/Via-Shielding-300x220.png" alt="Via Shielding"></a></p>
<p>操作很简单，点击Tools » Via Stitching/Shielding » Add Shielding to Net菜单，弹出属性设置框</p>
<p><a href="/uploads/2015/12/Dialog_AddShieldingToNet.png"><img src="/uploads/2015/12/Dialog_AddShieldingToNet-300x207.png" alt="Dialog_AddShieldingToNet"></a></p>
<p>选择网络，设置要屏蔽的网络，以及屏蔽孔所在的网络（通常我们选择地），设置好过孔的孔径等（或者直接从规则中导入即可），点击确认即可自动生成漂亮的屏蔽孔了。</p>
<p><a href="/uploads/2015/12/ShieldedNet.png"><img src="/uploads/2015/12/ShieldedNet-300x124.png" alt="ShieldedNet"></a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/硬件设计/">硬件设计</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-fpga-e6-9e-b6-e6-9e-84-e7-a4-ba-e4-be-8b-ef-bc-9aaes-e5-8a-a0-e5-af-86" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/07/fpga-e6-9e-b6-e6-9e-84-e7-a4-ba-e4-be-8b-ef-bc-9aaes-e5-8a-a0-e5-af-86/" class="article-date">
      <time datetime="2015-12-07T03:31:45.000Z" itemprop="datePublished">2015-12-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/07/fpga-e6-9e-b6-e6-9e-84-e7-a4-ba-e4-be-8b-ef-bc-9aaes-e5-8a-a0-e5-af-86/">FPGA架构示例：AES加密</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>AES（也可以使用其原始名字Rijndael）指定了最新的电子信号保护加密标准。该标准已由美国国家研究院标准与技术研究院（NIST）通过，已公开发表在FIPS PUB197。新标准的动机是为了克服已有的DES加密标准的缺点。除了更安全之外，AES还更适合于在硬件上实现。在这方面，意味着更少的设计错误（更可靠）和更快的速度（简单的组合逻辑）。</p>
<p>本章的内容描述了AES算法，以及如何在设计中实现面积和速度的平衡。</p>
<h3 id="4-1-AES算法"><a href="#4-1-AES算法" class="headerlink" title="4.1 AES算法"></a>4.1 AES算法</h3><p>AES是一个对称加密算法，密钥将128bit的数据块映射成128bit的加密块。密钥的长度可以是128、192和256bit，密钥长度决定了按全等级（越长的密钥 = 越长的密钥空间 = 更安全）。在AES算法中的变换包含的四个不同的模块：子字节（位映射），行移位（交换），列混 合（在GF(2^8)域上的变换），以及循环加密（在GF（2）空间上将循环密钥与每一位相加）。这些变换构成了一轮，轮的次数由密钥大小决定（128bit,10轮；192bit,12轮；256bit，14轮）。注意每一轮上的循环密密都是独一无二的。这些循环密钥原密钥衍生自对原密钥的扩展。密钥扩展是本章的重点，我们将会对其进行详细讨论。关于AES加密的更多细节可以参考美国国家标准与技术研究院发布的联邦信息处理标准197（FIPS 197）文档。</p>
<p><strong>感觉上面关于原理的自己翻译狗屁不通，关于GF变换我也是完全不懂，所以有兴趣的请自行搜索《AES算法图解》之类的科谱文章，想深入的还是得去看看GF变换的数学法则，毕竟我们这里只是想学习探讨FPGA技术。</strong></p>
<p>密钥扩展，在数据路么上是并行运行的，它取出密码密钥然后为每轮变换产生一个唯一的密钥。假定 字长 = 32位，并且 N_k = 密钥大小/字长 （ = 128， 192， 或 256 / 32）。第一个N_k字扩展由密码扩充。后续的每个32位字扩展密钥都与前一个32位字与当前字之前的N_k相异或.对N_k倍字，当前字经过之前的异或运算后，紧接着与一个圆常数（？？？？）相异或。变换包含一个循环置换，伴随一个8字节映射32位字的所有四个字节。圆常数由FIPS 197定义，给出的形式为【x^(i-1), {00}, {00}, {00}】, x^(i-1)是x的权,x在GF（2^8）域表示为{02}。</p>
<p>相对于算法高层的单个密钥自主扩展实现的代码如下：</p>
<pre><code>module KeyExp1Enc(
// updated values to be passed to next iteration
output [3:0] oKeyIter, oKeyIterModNk,
oKeyIterDivNk,
output [32*‘Nk-1:0] oNkKeys,
input iClk, iReset,
// represents total # of iterations and value mod Nk
input [3:0] iKeyIter, iKeyIterModNk,
iKeyIterDivNk,
// The last Nk keys generated in key expansion
input [32*‘Nk-1:0] iNkKeys);
// updated values to be passed to next iteration
reg [3:0] oKeyIter, oKeyIterModNk,
oKeyIterDivNk;
reg [32*‘Nk-1:0] OldKeys;
reg [31:0] InterKey; // intermediate key value
wire [32*‘Nk-1:0] oNkKeys;
wire [31:0] PrevKey, RotWord, SubWord,
NewKeyWord;
wire [31:0] KeyWordNk;
wire [31:0] Rcon;
assign PrevKey = iNkKeys[31:0]; // last word in key
array
assign KeyWordNk = OldKeys[32*‘Nk-1:32*‘Nk-32];
// 1 byte cyclic permutation
assign RotWord = {PrevKey[23:0], PrevKey[31:24]};

// new key calculated in this round
assign NewKeyWord = KeyWordNk ^ InterKey;
// calculate new key set
assign oNkKeys = {OldKeys[32*‘Nk-33:0], NewKeyWord};
// calculate Rcon over GF(2^8)
assign Rcon = iKeyIterDivNk == 8’h1 ? 32’h01000000:
iKeyIterDivNk == 8’h2 ? 32’h02000000:
iKeyIterDivNk == 8’h3 ? 32’h04000000:
iKeyIterDivNk == 8’h4 ? 32’h08000000:
iKeyIterDivNk == 8’h5 ? 32’h10000000:
iKeyIterDivNk == 8’h6 ? 32’h20000000:
iKeyIterDivNk == 8’h7 ? 32’h40000000:
iKeyIterDivNk == 8’h8 ? 32’h80000000:
iKeyIterDivNk == 8’h9 ? 32’h1b000000:
32’h36000000;
SboxEnc SboxEnc0(.iPreMap(RotWord[31:24]),
.oPostMap(SubWord[31:24]));
SboxEnc SboxEnc1(.iPreMap(RotWord[23:16]),
.oPostMap(SubWord[23:16]));
SboxEnc SboxEnc2(.iPreMap(RotWord[15:8]),
.oPostMap(SubWord[15:8]));
SboxEnc SboxEnc3(.iPreMap(RotWord[7:0]),
.oPostMap(SubWord[7:0]));
‘ifdef Nk8
wire [31:0] SubWordNk8;
// Substitution only when Nk = 8
SboxEnc SboxEncNk8_0(.iPreMap(PrevKey[31:24]),
.oPostMap(SubWordNk8[31:24]));
SboxEnc SboxEncNk8_1(.iPreMap(PrevKey[23:16]),
.oPostMap(SubWordNk8[23:16]));
SboxEnc SboxEncNk8_2(.iPreMap(PrevKey[15:8]),
.oPostMap(SubWordNk8[15:8]));
SboxEnc SboxEncNk8_3(.iPreMap(PrevKey[7:0]),
.oPostMap(SubWordNk8[7:0]));
‘endif
always @(posedge iClk)
if(!iReset) begin
oKeyIter &amp;lt;= 0;
oKeyIterModNk &amp;lt;= 0;
InterKey &amp;lt;= 0;
oKeyIterDivNk &amp;lt;= 0;
OldKeys &amp;lt;= 0;
end
else begin
oKeyIter &amp;lt;= iKeyIter + 1;
OldKeys &amp;lt;= iNkKeys;
// update &quot;Key iteration mod Nk&quot; for next iteration
if(iKeyIterModNk + 1 == ‘Nk) begin
oKeyIterModNk &amp;lt;= 0;
oKeyIterDivNk &amp;lt;= iKeyIterDivNk+1;
end
else begin
oKeyIterModNk &amp;lt;= iKeyIterModNk + 1;
oKeyIterDivNk &amp;lt;= iKeyIterDivNk;
end
if(iKeyIterModNk == 0)
InterKey &amp;lt;= SubWord ^ Rcon;
‘ifdef Nk8
// an option only for Nk = 8
else if(iKeyIterModNk == 4)
InterKey &amp;lt;= SubWordNk8;
‘endif
else
InterKey &amp;lt;= PrevKey;
end
endmodule

`&lt;/pre&gt;

同样的，对于数据路径所有的自主操作功能的组合都需要一个如下所实现的轮加密结构。

&lt;pre&gt;`
module RoundEnc(
output [32*‘Nb-1:0] oBlockOut,
output oValid,
input iClk, iReset,
input [32*‘Nb-1:0] iBlockIn, iRoundKey,
input iReady,
input [3:0] iRound);
wire [32*‘Nb-1:0] wSubOut, wShiftOut, wMixOut;
wire wValidSub, wValidShift,
wValidMix;
SubBytesEnc sub( .iClk(iClk), .iReset(iReset),
.iBlockIn(iBlockIn),
.oBlockOut(wSubOut),
.iReady(iReady),
.oValid(wValidSub));
ShiftRowsEnc shift( .iBlockIn(wSubOut), .oBlock
Out(wShiftOut),
.iReady(wValidSub), .oValid
(wValidShift));
MixColumnsEnc mixcolumn( .iClk(iClk), .iReset(iReset),
.iBlockIn(wShiftOut),
.oBlockOut(wMixOut),
.iReady(wValidShift),
.oValid(wValidMix),
.iRound(iRound));
AddRoundKeyEnc addroundkey(.iClk(iClk), .iReset(iReset),
.iBlockIn(wMixOut),
.iRoundKey(iRoundKey),
.oBlockOut(oBlockOut),
.iReady(wValidMix),
.oValid(oValid));
endmodule

`&lt;/pre&gt;

轮子块的实现是很简单的。假定每轮的潜伏期是4个时钟，原因将在后面描述。对于如下的流水线分法这将是合理的（基于逻辑平衡）。

#### 4.1.1 单级流水的字节替换

字节替换是由查找表实现的，因为算法本身是在较小空间上迭代实现的。因此一个8bit到8bit映射可以由一个单级流水的ROM高效实现。如图4.1

![](
</code></pre><p>/uploads/2015/12/2015-12-07_113145.png)</p>
<pre><code>#### 4.1.2 零级流水的行移位变换

这个阶段只是将数据块和行进行混合，因此在这儿不需要任何逻辑。因此，将会导致其它的流水级在这里产生逻辑失衡，进而降低了最大工作频率和总的吞吐量。行移位变换如图4.2

![](
</code></pre><p>/uploads/2015/12/2015-12-29_141139.png)</p>
<pre><code>#### 4.1.3 两级流水的列混合变换

这个阶段包含四轮阶段之外的大部分逻辑，因此这里是添加额外流水最好的地方。列混合变换如图4.3

![](
</code></pre><p>/uploads/2015/12/2015-12-29_141906.png)</p>
<pre><code>如图4.3所示，混合列用了一个叫作Map-Column的内建模块，如图4.4。

![](
</code></pre><p>/uploads/2015/12/2015-12-29_142225.png)</p>
<pre><code>如图4.4所示，Map-Column用了一个叫作Poly-MultX2(polynomial 2 multiplier)作为内建模块，如图4.5.

![](
</code></pre><p>/uploads/2015/12/2015-12-29_142300.png)</p>
<pre><code>#### 4.1.4 一级流水的添加轮密钥

这个阶段是简单地将数据块与由key expasion流水生成的密钥进行异或，如图4.6.

![](
</code></pre><p>/uploads/2015/12/2015-12-29_145209.png)</p>
<pre><code>#### 4.1.5 紧凑架构

我们正在探讨的第一个实现是一个旨在实现逻辑复用的紧凑的实现。初始，输入的数据和密钥一起被加到Initial Round模块，结果进入加密循环前被寄存。数据然后被提供给字节规换模块，行移位变换，列混合，以特定顺序与Round Key相加。在每一轮的结尾，新的数据被寄存。这些操作依据需要的轮数被重复N次。迭代架构的框图如图4.7。

![](
</code></pre><p>/uploads/2015/12/2015-12-29_151657.png)</p>
<pre><code>顶层实现的代码如下：

&lt;pre&gt;`
module AES_Enc_core(
output [32*‘Nb-1:0] oCiphertext, // output cipthertext
output oValid, // data at output is valid
output oKeysValid,

input iClk, iReset,
input [32*‘Nb-1:0] iPlaintext, // input data to be
encrypted
input [32*‘Nk-1:0] iKey, // input cipther key
input iReady, // valid data to encrypt
input iNewKey); // signals new key is
input
// registered inputs
wire [32*‘Nk-1:0] wKeyReg;
wire wNewKeyReg, wReadyReg;
wire [127:0] wPlaintextReg, wBlockOutInit;
wire [127:0] wRoundKeyInit, wRoundKey;
// register inputs
InputRegsEnc InputRegs( .iClk(iClk), .iReset(iReset),
.iKey(iKey),
.iNewKey(iNewKey), .iPlaintext
(iPlaintext),
.oKeysValid(oKeysValid),
.iReady(iReady),
.oKey(wKeyReg), .oPlaintext
(wPlaintextReg),
.oReady(wReadyReg));
// initial addition of round key
AddRoundKeyEnc InitialKey( .iClk(iClk), .iReset(iReset),
.iBlockIn(wPlaintextReg),
.iRoundKey(wRoundKeyInit),
.oBlockOut(wBlockOutInit),
.iReady(wReadyReg),
.oValid(wValidInit));
// Number of rounds is a function of key size (10, 12, or
14)
// Key expansion block

KeyExpansionEnc KeyExpansion( .iClk(iClk), .iReset
(iReset),
.iNkKeys(wKeyReg),
.iReady(wReadyReg),
.oRoundKey(wRoundKey));
RoundsIterEnc RoundsIter( .iClk(iClk), .iReset(iReset),
.iBlockIn(wBlockOutInit),
.oBlockOut(oCiphertext),
.iReady(wValidInit),
.oValid(oValid),
.iRoundKey(wRoundKey));
‘ifdef Nk4
assign wRoundKeyInit = wKeyReg[128-1:0];
‘endif
‘ifdef Nk6
assign wRoundKeyInit = wKeyReg[192-1:192-128];
‘endif
‘ifdef Nk8
assign wRoundKeyInit = wKeyReg[256-1:256-128];
‘endif
endmodule

`&lt;/pre&gt;

在上面的代码中，KeyExpansionEnc和RoundsIterEnc 执行紧凑架构所要求的迭代操作。KeyExpansionaEnc处理密钥展开迭代，RoundsIterEnc处理数据路径。在每一轮迭代中，独一无二的轮密钥通过密钥展开模块传递到密钥表达模块。下面的代码通过同样的扩展模块循环处理密钥信息，以达到每轮进行逻辑复用。

&lt;pre&gt;`
module KeyExpansionEnc(
output [128-1:0] oRoundKey,
input iClk, iReset,
// The last Nk keys generated in initial key expansion
input [32*‘Nk-1:0] iNkKeys,
input iReady); // signals a
new key is input
wire [3:0] KeyIterIn, KeyIterOut;
wire [3:0] KeyIterDivNkIn, KeyIterDivNkOut;
wire [3:0] KeyIterModNkIn, KeyIterModNkOut;
wire [32*‘Nk-1:0] NkKeysOut, NkKeysIn;
wire wReady;
assign wReady = iReady;
assign KeyIterIn = wReady ? ‘Nk : KeyIterOut;
assign oRoundKey = NkKeysOut[32*‘Nk-1:32*‘Nk-128];

assign KeyIterModNkIn = wReady ? 4’h0 : KeyIter
ModNkOut;
assign KeyIterDivNkIn = wReady ? 4’h1 : KeyIter
DivNkOut;
assign NkKeysIn = wReady ? iNkKeys : NkKeysOut;
KeyExp1Enc KeyExp1(.iClk(iClk), .iReset(iReset),
.iKeyIter(KeyIterIn),
.iKeyIterModNk(KeyIterModNkIn),
.iNkKeys(NkKeysIn), .iKeyIterDivNk
(KeyIterDivNkIn),
.oKeyIter(KeyIterOut),
.oKeyIterModNk(KeyIterModNkOut),
.oNkKeys(NkKeysOut),
.oKeyIterDivNk(KeyIterDivNkOut));
endmodule

`&lt;/pre&gt;

在上面的模块中，单个密钥扩展模块的输出回馈到其它的子轮扩展模块中，如图4.8。

![](
</code></pre><p>/uploads/2015/12/2015-12-29_155117.png)</p>
<pre><code>因此，KeyExp1Enc由每一轮复用。

#### 4.1.6典型的流水线结构

在此讨论的第二个实现是一个典型的流水线架构。一个完整的ASE轮需要11到14个时钟周期，具体取决于密钥的大小。

从图4.9中可以看到，多实例的数据路径能够被用来去创建流水设计，密钥扩展以一种静态方式执行。下面代码所展示的实现为N_k = 4。

![](
</code></pre><p>/uploads/2015/12/2015-12-29_161228.png)</p>
<pre><code>&lt;pre&gt;`
module AES_core(
output [32*‘Nb-1:0] oCiphertext, // output cipthertext
output oValid, // data at output is valid
// signals that new key has been completely processed
output oKeysValid,
input iClk, iReset,
input [32*‘Nb-1:0] iPlaintext, // input data to
be encrypted
input [32*‘Nk-1:0] iKey, // input cipther key
input iReady, // valid data to encrypt
input iNewKey); // signals new key
is input
wire [32*‘Nb-1:0] wRoundKey1, wRoundKey2,
wRoundKey3, wRoundKey4,
wRoundKey5, wRoundKey6,
wRoundKey7, wRoundKey8,
wRoundKey9, wRoundKeyFinal,
wRoundKeyInit;
wire [32*‘Nb-1:0] wBlockOut1, wBlockOut2,
wBlockOut3, wBlockOut4,
wBlockOut5, wBlockOut6,

wBlockOut7, wBlockOut8,
wBlockOut9, wBlockOutInit;
wire [32*‘Nk-1:0] wNkKeysInit;
wire [3:0] wKeyIterInit;
wire [3:0] wKeyIterModNkInit;
wire [3:0] wKeyIterDivNkInit;
wire wValid1, wValid2, wValid3,
wValid4,
wValid5, wValid6, wValid7,
wValid8,
wValid9, wValidFinal,
wValidInit;
wire wNewKeyInit;
wire [128*(‘Nr+1)-1:0] wKeys; // complete set
of round keys
// registered inputs
wire [32*‘Nk-1:0] wKeyReg;
wire wNewKeyReg, wReadyReg;
wire [127:0] wPlaintextReg;
// register inputs
InputRegs InputRegs( .iClk(iClk), .iReset(iReset),
.iKey(iKey),
.iNewKey(iNewKey),
.iPlaintext(iPlaintext),
.iReady(iReady), .oKey(wKeyReg),
.oNewKey(wNewKeyReg),
.oPlaintext(wPlaintextReg),
.oReady(wReadyReg));
// initial key expansion
KeyExpInit KeyExpInit( .iClk(iClk), .iReset(iReset),
.iNkKeys(wKeyReg), .iNewKey
(wNewKeyReg),
.oKeyIter(wKeyIterInit),
.oNewKey(wNewKeyInit),
.oKeyIterModNk
(wKeyIterModNkInit),
.oNkKeys(wNkKeysInit),
.oKeyIterDivNk
(wKeyIterDivNkInit));
// initial addition of round key
AddRoundKey InitialKey( .iClk(iClk), .iReset(iReset),
.iBlockIn(wPlaintextReg),
.iRoundKey(wRoundKeyInit),
.oBlockOut(wBlockOutInit),
.iReady(wReadyReg),
.oValid(wValidInit));

// Number of rounds is a function of key size (10, 12, or
14)
// Key expansion block
KeyExpansion KeyExpansion( .iClk(iClk),
.iReset(iReset),
.iKeyIter(wKeyIterInit),
.iKeyIterModNk(wKeyIterMod
NkInit),
.iNkKeys(wNkKeysInit),
.iKeyIterDivNk(wKeyIterDiv
NkInit),
.iNewKey(wNewKeyInit),
.oKeys(wKeys), .oKeysValid
(oKeysValid));
// round transformation blocks
Round R1( .iClk(iClk), .iReset
(iReset),
.iBlockIn(wBlockOutInit),
.iRoundKey(wRoundKey1),
.oBlockOut(wBlockOut1),
.iReady(wValidInit),
.oValid(wValid1));
Round R9( .iClk(iClk), .iReset
(iReset),
.iBlockIn(wBlockOut8),
.iRoundKey(wRoundKey9),
.oBlockOut(wBlockOut9),
.iReady(wValid8),
.oValid(wValid9));
// 10 rounds total
// Initial key addition
assign wRoundKeyFinal = wKeys[128*(‘Nr-7)-1:
128*(‘Nr-8)];
// round key assignments
assign wRoundKey9 = wKeys[128*(‘Nr-6)-1: 128*(‘Nr-7)];
assign wRoundKey8 = wKeys[128*(‘Nr-5)-1: 128*(‘Nr-6)];
assign wRoundKey7 = wKeys[128*(‘Nr-4)-1: 128*(‘Nr-5)];
assign wRoundKey6 = wKeys[128*(‘Nr-3)-1: 128*(‘Nr-4)];
assign wRoundKey5 = wKeys[128*(‘Nr-2)-1: 128*(‘Nr-3)];
assign wRoundKey4 = wKeys[128*(‘Nr-1)-1: 128*(‘Nr-2)];
assign wRoundKey3 = wKeys[128*‘Nr-1: 128*(‘Nr-1)];
assign wRoundKey2 = wKeys[128*(‘Nr+1)-1: 128*‘Nr];
assign wRoundKey1 = wNkKeysInit[128-1:0];
assign wRoundKeyInit = iKey[128-1:0];

FinalRound FinalRound( .iClk(iClk), .iReset(iReset),
.iBlockIn(wBlockOut9),
.iRoundKey(wRoundKeyFinal),
.oBlockOut(oCiphertext),
.iReady(wValid9), .oValid
(oValid));
endmodule

`&lt;/pre&gt;

尽管如上的流水设计能够进行高速率的数据加密，这个架构会产生一个问题，如果如果改变密钥的速度大于加密速度。周边设备必须足够智能，在将新的数据用新的密钥加密时等待流水线为空。这个信息必须被反馈给外部系统以便为它们响应密钥提供信息，这样它们才能正确地缓冲和保持数据。最坏的情况下每个数据块都要求新的密钥，这时候该流水架构和迭代架构有着相近的吞吐量并且会造成大量的逻辑资源浪费（别提没有达到所期待的吞吐量的失望）。下一节将会提供一个解决该问题的架构。

#### 4.1.7 全流水架构

术语&quot;全流水&quot;是指密钥扩展完全并行于轮变换流水的架构，在相应的阶段流水线在相应的时间给其它模块提供准确的信息。换句话说，任何特定阶段的轮密钥只在一个时钟周期内对特定的数据块有效，并被用于这个时段相应的轮变换。这发生成每个平行于流水线的阶段。因此，一个独一无二的密钥能够被用在每个潜在的数据块，没有任何因为延时或等待状态所带来的损失。轮变换流水的最大吞吐量与密钥集的拓扑无关。全流水实现的框图如4.10所示。

![](
</code></pre><p>/uploads/2015/12/2015-12-30_110251.png)</p>
<pre><code>这意味着通过Key Expansion(将用户密钥扩展为32位字)功能的单独迭代将会完全地与用于产生即将用到的密钥的轮对轮同步（好迷糊）。另外，密钥扩展模块的延时也要保持一个时钟周期的延时以达到与轮变换块相等，轮变换典型
情况下的延时为1——4个时钟。

为了让任意密钥扩展块的轮密钥能正确在每一个时钟正确地抵达对应的轮变换块，时序必须非常精确。具体来说，就是每个密钥扩展块必须精确地产生与时钟周期数相等的轮密钥，这样轮块就能够产生相应的数据。另外，当密钥被传递给add-round-key子块的时候，延时必须要使得每个密钥有效。为了处理这些要求，每一个密钥扩展块被分为四个递增的扩展块。每个递扩展块产生一个由NIST规范定义的密钥的单字（128/4=32bits）。这些模块中的每一个都有一个流水级，如图4.11。

![](
</code></pre><p>/uploads/2015/12/2015-12-30_105918.png)</p>
<pre><code>如上所述，每一个Key-Exp1模块生成一个扩展密钥的单字（32bits）。这个阶段添加的流水如图4.12。

![](
</code></pre><p>/uploads/2015/12/2015-12-30_105945.png)</p>
<pre><code>如图4.12，S-box能够用一个8x256的同步ROM来实现，并且提供精确的延时，由NIST规范的R-CON计算必须加入一级流水。

另外，为了确保在密钥流水和数据处理流水之间的精确延时，密钥必须在轮数据结束前一个周期产生。这是因为轮密钥对于add-round-key模块按时钟执行异或操作并存入它的最终寄存器而言是必须的。换句话说，密钥扩展的4个时钟周期必须与对应的轮块的三个时钟周期同步。这是由在密钥扩展进程的前端加入初始密钥来处理的。如图4.13。

![](
</code></pre><p>/uploads/2015/12/2015-12-30_110632.png)</p>
<pre><code>超过最开始的128比特的数据的密钥会在第一个时钟周期得到扩展，当数据流水线在第二个时钟开始的时候（由初始的轮加入密钥产生的一个单周期延时）。顶层实现代码如下，这里N_k = 4 。

&lt;pre&gt;`
module AES_core(
output [32*‘Nb-1:0] oCiphertext, // output cipthertext
output oValid, // data at output is valid
input iClk, iReset,
input [32*‘Nb-1:0] iPlaintext, // input data to be
encrypted
input [32*‘Nk-1:0] iKey, // input cipther key
input iReady); // valid data to encrypt

wire [32*‘Nb-1:0] wRoundKey1, wRoundKey2, wRoundKey3,
wRoundKey4,
wRoundKey5, wRoundKey6, wRoundKey7,
wRoundKey8,
wRoundKey9, wRoundKeyFinal,
wRoundKeyInit;
wire [32*‘Nb-1:0] wBlockOut1, wBlockOut2, wBlockOut3,
wBlockOut4,
wBlockOut5, wBlockOut6, wBlockOut7,
wBlockOut8,
wBlockOut9, wBlockOutInit;
wire [32*‘Nk-1:0] wNkKeys1, wNkKeys2, wNkKeys3,
wNkKeys4,
wNkKeys5, wNkKeys6, wNkKeys7,
wNkKeys8,
wNkKeys9, wNkKeysFinal,
wNkKeysInit;
wire [3:0] wKeyIter1, wKeyIter2, wKeyIter3,
wKeyIter4,
wKeyIter5, wKeyIter6, wKeyIter7,
wKeyIter8,
wKeyIter9, wKeyIterFinal,
wKeyIterInit;
wire [3:0] wKeyIterModNk1, wKeyIterModNk2,
wKeyIterModNk3,
wKeyIterModNk4, wKeyIterModNk5,
wKeyIterModNk6,
wKeyIterModNk7, wKeyIterModNk8,
wKeyIterModNk9,
wKeyIterModNkFinal,
wKeyIterModNkInit;
wire [3:0] wKeyIterDivNk1, wKeyIterDivNk2,
wKeyIterDivNk3,
wKeyIterDivNk4, wKeyIterDivNk5,
wKeyIterDivNk6,
wKeyIterDivNk7, wKeyIterDivNk8,
wKeyIterDivNk9,
wKeyIterDivNkFinal,
wKeyIterDivNkInit;
wire wValid1, wValid2, wValid3, wValid4,
wValid5, wValid6, wValid7, wValid8,
wValid9, wValidFinal, wValidInit;
// registered inputs
wire [32*‘Nk-1:0] wKeyReg;
wire wReadyReg;
wire [127:0] wPlaintextReg;

// Initial key addition
assign wRoundKeyInit = wKeyReg[32*‘Nk-1:32*‘Nk-128];
// round key assignments
assign wRoundKey1 = wNkKeysInit[32*‘Nb-1:0];
assign wRoundKey2 = wNkKeys1[32*‘Nb-1:0];
assign wRoundKey3 = wNkKeys2[32*‘Nb-1:0];
assign wRoundKey4 = wNkKeys3[32*‘Nb-1:0];
assign wRoundKey5 = wNkKeys4[32*‘Nb-1:0];
assign wRoundKey6 = wNkKeys5[32*‘Nb-1:0];
assign wRoundKey7 = wNkKeys6[32*‘Nb-1:0];
assign wRoundKey8 = wNkKeys7[32*‘Nb-1:0];
assign wRoundKey9 = wNkKeys8[32*‘Nb-1:0];
// register inputs
InputRegs InputRegs( .iClk(iClk), .iReset(iReset),
.iKey(iKey),
.iPlaintext(iPlaintext),
.iReady(iReady), .oKey(wKeyReg),
.oPlaintext(wPlaintextReg),
.oReady(wReadyReg));
// initial key expansion
KeyExpInit KeyExpInit( .iClk(iClk), .iReset(iReset),
.iNkKeys(wKeyReg),
.oKeyIter(wKeyIterInit),
.oKeyIterModNk(wKeyIterMod
NkInit),
.oNkKeys(wNkKeysInit),
.oKeyIterDivNk
(wKeyIterDivNkInit));
// initial addition of round key
AddRoundKey InitialKey( .iClk(iClk), .iReset(iReset),
.iBlockIn(wPlaintextReg),
.iRoundKey(wRoundKeyInit),
.oBlockOut(wBlockOutInit),
.iReady(wReadyReg),
.oValid(wValidInit));
// Number of rounds is a function of key size (10, 12, or
14)
// Key expansion blocks
KeyExpBlock KeyExpBlock1( .iClk(iClk), .iReset(iReset),
.iKeyIter(wKeyIterInit),
.iKeyIterModNk(wKeyIterMod
NkInit),
.iNkKeys(wNkKeysInit),
.iKeyIterDivNk(wKeyIterDiv
NkInit),
.oKeyIter(wKeyIter1),

.oKeyIterModNk(wKeyIter
ModNk1),
.oNkKeys(wNkKeys1),
.oKeyIterDivNk(wKeyIter
DivNk1));
KeyExpBlock KeyExpBlock8( .iClk(iClk), .iReset(iReset),
.iKeyIter(wKeyIter7),
.iKeyIterModNk(wKeyIter
ModNk7),
.iNkKeys(wNkKeys7),
.iKeyIterDivNk(wKeyIter
DivNk7),
.oKeyIter(wKeyIter8),
.oKeyIterModNk(wKeyIter
ModNk8),
.oNkKeys(wNkKeys8),
.oKeyIterDivNk(wKeyIter
DivNk8));
// round transformation blocks
Round R1( .iClk(iClk), .iReset(iReset),
.iBlockIn(wBlockOutInit),
.iRoundKey(wRoundKey1),
.oBlockOut(wBlockOut1),
.iReady(wValidInit),
.oValid(wValid1));
...
Round R9( .iClk(iClk), .iReset(iReset),
.iBlockIn(wBlockOut8),
.iRoundKey(wRoundKey9),
.oBlockOut(wBlockOut9),
.iReady(wValid8),
.oValid(wValid9));
// 10 rounds total
assign wRoundKeyFinal = wNkKeys9[32*‘Nb-1:0];
KeyExpBlock KeyExpBlock9( .iClk(iClk), .iReset(iReset),
.iKeyIter(wKeyIter8),
.iKeyIterModNk
(wKeyIterModNk8),
.iNkKeys(wNkKeys8),
.iKeyIterDivNk
(wKeyIterDivNk8),
.oKeyIter(wKeyIter9),
.oKeyIterModNk
(wKeyIterModNk9),
.oNkKeys(wNkKeys9),

.oKeyIterDivNk(wKeyIter
DivNk9));
FinalRound FinalRound( .iClk(iClk), .iReset(iReset),
.iBlockIn(wBlockOut9),
.iRoundKey(wRoundKeyFinal),
.oBlockOut(oCiphertext),
.iReady(wValid9), .oValid
(oValid));
endmodule
</code></pre><h3 id="4-2性能面积比对"><a href="#4-2性能面积比对" class="headerlink" title="4.2性能面积比对"></a>4.2性能面积比对</h3><p>在本节，我们将会讨论在流水设计和紧凑设计之间的速度与面积权衡，并且会提供在典型器件上实际的测试结果。上面三种架构将会用同样的硬件描述语言和同样的编译工具。</p>
<p>第一个作为目标测试器件的是Xilinx Virtex II FPGA。统计结果如表4.1。</p>
<p>作为与FPGA实现的对比，该设计也用在了由0.35um的ASIC处理器上，结果如表4.2。</p>
<p>表中性能指标定义如下：</p>
<p>1.LUTs: AES核在FPGA中的逻辑使用率。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/FPGA/">FPGA</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-lantern-tor-browser-e9-9a-90-e8-b8-aa-e6-9c-80-e4-bd-b3-e6-8b-8d-e6-a1-a3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/13/lantern-tor-browser-e9-9a-90-e8-b8-aa-e6-9c-80-e4-bd-b3-e6-8b-8d-e6-a1-a3/" class="article-date">
      <time datetime="2015-11-13T06:09:30.000Z" itemprop="datePublished">2015-11-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/13/lantern-tor-browser-e9-9a-90-e8-b8-aa-e6-9c-80-e4-bd-b3-e6-8b-8d-e6-a1-a3/">Lantern &amp;&amp; Tor Browser 隐踪最佳拍档</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong>MNBG，FUCK GFW！</strong></p>
<p>最近玩zedboard，发现zedboard.org打不开了，PING倒是可以PING通,用qq邮箱注册居然也收不到验证邮件，最后只能FQ<br>，之前的各种FQ工具要么是不能用，要么是不放心，最后还是用了之前用过的Lantern，虽然慢一点。当然如果你喜欢匿名的，想看看所谓的暗网，可以试试 Tor Browser,两款软件可以同时用，Lantern可以作为Tor Browser的前端工具。</p>
<p><a href="/uploads/2015/11/2015-11-13_094352.png"><img src="/uploads/2015/11/2015-11-13_094352-300x124.png" alt="2015-11-13_094352"></a></p>
<p><a href="/uploads/2015/11/2015-11-13_094339.png"><img src="/uploads/2015/11/2015-11-13_094339-300x273.png" alt="2015-11-13_094339"></a></p>
<p><a href="/uploads/2015/11/2015-11-13_140737.png"><img src="/uploads/2015/11/2015-11-13_140737-300x273.png" alt="2015-11-13_140737"></a></p>
<p><strong>注意Tor Browser上弹出的提示框，不要全屏浏览器，以免因网站获取你的显示分辨率，而间接获取其它暴露你行踪的信息。</strong></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/闲言碎语/">闲言碎语</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e7-94-a8-e4-ba-8e-e9-80-9a-e8-ae-af-e6-95-b0-e6-8d-ae-e7-bc-93-e5-ad-98-e7-9a-84-e9-ab-98-e6-95-88-e8-bd-af-e4-bb-b6fifo-e5-ae-9e-e7-8e-b0" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/26/e7-94-a8-e4-ba-8e-e9-80-9a-e8-ae-af-e6-95-b0-e6-8d-ae-e7-bc-93-e5-ad-98-e7-9a-84-e9-ab-98-e6-95-88-e8-bd-af-e4-bb-b6fifo-e5-ae-9e-e7-8e-b0/" class="article-date">
      <time datetime="2015-10-26T01:01:58.000Z" itemprop="datePublished">2015-10-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/26/e7-94-a8-e4-ba-8e-e9-80-9a-e8-ae-af-e6-95-b0-e6-8d-ae-e7-bc-93-e5-ad-98-e7-9a-84-e9-ab-98-e6-95-88-e8-bd-af-e4-bb-b6fifo-e5-ae-9e-e7-8e-b0/">用于通讯数据缓存的高效软件FIFO实现</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><a href="/uploads/2015/10/6249-01-fifo-concept-4-558x314.jpg"><img src="/uploads/2015/10/6249-01-fifo-concept-4-558x314-300x169.jpg" alt="6249-01-fifo-concept-4-558x314"></a></p>
<p>分享一个shawge自己用于数据缓冲的高效FIFO实现，已用于大型医疗内窥镜系统MCU端软件的串口通讯、手机CMOS摄像头自动化测试系统PC端软件的USB视频显示缓冲等项目，用你自己定义的数据元素替代BUF_NODE即可。</p>
<pre><code>#ifndef _FIFO_
#define _FIFO_

#include &quot;stdint.h&quot;

typedef struct 
{
    BYTE *pBuf;         //数据缓冲区
    BOOL bConvent;      //是否已完成了可显示格式的转换
    BOOL bDisplay;      //是否已经被显示
} BufNode_t;

#define  BUF_NODE BufNode_t

typedef struct _FIFO_t 
{
    int16_t  nHead;
    int16_t  nTail;
    BUF_NODE* pBuf;
    uint16_t size;
    uint16_t rsv;
} FIFO_t;

//获取FIFO内数据长度
#define FIFO_SIZE(fifo) ( ( (fifo).nTail - (fifo).nHead + (fifo).size ) &amp;amp; ((fifo).size - 1) )          

//获取FIFO剩余空间                            
#define FIFO_GET_REMAIN(fifo) ((fifo).size - FIFO_SIZE(fifo))

//设置FIFO头指针
#define FIFO_SET_HEAD(fifo, index) ( (fifo).nHead = (index) )

//设置FIFO尾指针
#define FIFO_SET_TAIL(fifo, index)                                 \
do                                                                  \
{                                                                   \
    (fifo).nTail = ((int16_t) (index)) &amp;amp; ((fifo).size - 1);         \
}                                                                   \
while(0)

//获取FIFO头指针
#define FIFO_GET_HEAD(fifo) ((fifo).nHead)

//获取FIFO尾指针
#define FIFO_GET_TAIL(fifo) ((fifo).nTail)

//获取FIFO中下一个可用空间的索引
#define FIFO_GET_NEXT_INDEX(fifo, pIndex, pbRet)                           \
do                                                                          \
{                                                                           \
    if(((fifo.nTail +1) &amp;amp; ((fifo).size - 1)) == (fifo).nHead)               \
    {                                                                       \
        *((BOOL*) pbRet) = FALSE;                                           \
        break;                                                              \
    }                                                                       \
    *(int16_t *)pIndex = (fifo).nTail &amp;amp; ((fifo).size - 1);                  \
    *((BOOL*) pbRet) = TRUE;                                                \
}                                                                           \
while(0)

//FIFO初始化
//_size必须为2^n
#define FIFO_INIT(fifo, _pBuf, _size)                                       \
do                                                                          \
{                                                                           \
      (fifo).nTail = (fifo).nHead = 0;                                      \
      (fifo).pBuf = (_pBuf);                                                \
      (fifo).size = (_size);                                                \
}                                                                           \
while(0)                                                                    

//FIFO入队
#define FIFO_IN(fifo, data, pbRet)                                                 \
    do                                                                              \
{                                                                               \
    if(((((fifo)).nTail +1) &amp;amp; ((fifo).size - 1))                                \
    == ((fifo)).nHead)                                                  \
{                                                                           \
    *((BOOL *)pbRet) = FALSE;                                               \
    break;                                                                  \
}                                                                           \
    *((BUF_NODE*) (((fifo)).pBuf + ((fifo)).nTail)) = data;                     \
    (fifo).nTail++;                                                             \
    (fifo).nTail &amp;amp;= ((fifo).size - 1);                                          \
    *((BOOL *)(pbRet)) = TRUE;                                                  \
}                                                                               \
    while(0)                                                                   

//FIFO出队
#define FIFO_OUT(fifo, pData, pbRet)                                            \
do                                                                              \
{                                                                               \
    if(fifo.nTail ==  fifo.nHead)                                               \
    {                                                                           \
    *((BOOL *)pbRet) = FALSE;                                                   \
       break;                                                                   \
    }                                                                           \
    ((BUF_NODE*) pData) = (fifo).pBuf + (fifo).nHead;                           \
    (fifo).nHead++;                                                             \
    (fifo).nHead &amp;amp;= (fifo).size - 1;                                            \
    *((BOOL *)pbRet) = TRUE;                                                    \
}                                                                               \
while(0)                                                            

//FIFO判空
#define FIFO_IS_EMPTY(fifo, pbRet)             \
do                                              \
{                                               \
    if(fifo.nTail ==  fifo.nHead )              \
        *((BOOL *)pbRet) = TRUE;                \
    else                                        \
        *((BOOL *)pbRet) = FALSE;               \
}                                               \
while(0)

//FIFO遍历
#define FIFO_FORECH(fifo, pData, index, pbRet)                                     \
do                                                                                  \
{                                                                                   \
    if( (index+1) &amp;gt; (((fifo).nTail - (fifo).nHead                                   \
            + (fifo).size) &amp;amp; ((fifo).size - 1) ) )                                  \
    {                                                                               \
        *((BOOL *) (pbRet)) = FALSE;                                                \
        break;                                                                      \
    }                                                                               \
    *((BUF_NODE*) pData) = *((fifo).pBuf                                                \
        + (((fifo).nHead + ((uint16_t) (index))) &amp;amp; ((fifo).size - 1) ) );           \
    *((BOOL *) (pbRet)) = TRUE;                                                     \
}                                                                                   \
while(0)

#endif
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/MCU-ARM/">MCU/ARM</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e9-ab-98-e9-80-9f-e9-ab-98-e7-b2-be-e5-ba-a6-e7-ba-a2-e5-a4-96-e6-b5-8b-e5-be-84-e4-bb-aa" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/24/e9-ab-98-e9-80-9f-e9-ab-98-e7-b2-be-e5-ba-a6-e7-ba-a2-e5-a4-96-e6-b5-8b-e5-be-84-e4-bb-aa/" class="article-date">
      <time datetime="2015-10-24T10:15:41.000Z" itemprop="datePublished">2015-10-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/24/e9-ab-98-e9-80-9f-e9-ab-98-e7-b2-be-e5-ba-a6-e7-ba-a2-e5-a4-96-e6-b5-8b-e5-be-84-e4-bb-aa/">高速高精度红外测径仪</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><a href="/uploads/2015/10/红外测径仪.png"><img src="/uploads/2015/10/红外测径仪-300x200.png" alt="红外测径仪"></a></p>
<p>新录的视频，看看效果，haha!</p>
<p><strong>由于采用了WORDPRESS默认的HTML5播放器，如果你的浏览器不支持，请右键（电脑）或点击下载图标（手机）下载到本地，然后用视频播放软件打开观看。</strong></p>
<p>[video width=”720” height=”480” mp4=”<br>/uploads/2015/10/红外测径仪.mp4”][/video]</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/FPGA/">FPGA</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-fpga-e6-9e-b6-e6-9e-84-e7-9a-84-e5-8a-9f-e8-80-97-e4-bc-98-e5-8c-96-ef-bc-883-ef-bc-89" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/05/fpga-e6-9e-b6-e6-9e-84-e7-9a-84-e5-8a-9f-e8-80-97-e4-bc-98-e5-8c-96-ef-bc-883-ef-bc-89/" class="article-date">
      <time datetime="2015-10-05T07:42:20.000Z" itemprop="datePublished">2015-10-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/05/fpga-e6-9e-b6-e6-9e-84-e7-9a-84-e5-8a-9f-e8-80-97-e4-bc-98-e5-8c-96-ef-bc-883-ef-bc-89/">FPGA架构的功耗优化（3）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <hr>
<p>原文： 《Advanced FPGA Design Architecture, Implementation,and Optimization》，Architecting Power</p>
<p>作者： Steve Kilts</p>
<p>译者： shawge</p>
<hr>
<h3 id="3-2-输入控制"><a href="#3-2-输入控制" class="headerlink" title="3.2 输入控制"></a>3.2 输入控制</h3><p>一个经常被忽视的降低功耗的技术就是输入转换率。CMOS输入缓存在高端和低端晶体管同时导通时会产生过大的电流。为了概念化这一点，请考虑如图3.5所示的一个基本的描述CMOS晶体管I_ds和V_ds关系的一阶模型，区域的定义如下：</p>
<p>截止：V_gs &lt; V_th<br>线性（电阻特性）：0 &lt; V_ds &lt; V_gs - V_th<br>饱和： 0 &lt; V_gs - V_th &lt; V_ds</p>
<p>式中V_gs是栅源电压， V_th是器个的阀值电压，V_ds漏源电压。</p>
<p><img src="/uploads/2015/10/IV_CURVE_CMOS.png" alt="IV_CURVE_CMOS"></p>
<p>一个理想的切换方案是门能从截止区瞬时切换到线性区，并且在相反的逻辑方向上也能瞬时完成。如果两个元件中的一个总是工作在截止态，将没有电流会同时经过门逻辑门的两端（从而在电源和地之间提供了一个阻抗路径）。对反向器而言，这将意味着NMOS（N沟道MOSEFT）器件从0变化到VDD（正电源轨）会将NMOS由截止区立即转为线性区，同时PMOS(P沟通MOSFET)将会从线性区转为截止区。在相反的转变中，当V_gs从VDD变为0，NMOS将会由线性区转为截止区，同时PMOS将会由截止区转为线性区。</p>
<p>然而在真实的世界里，我们必须将转换时间和在转换期间晶体管的行为考虑进来。举个例子，如果一个CMOS反向器输入0V，输出VDD。当输入从0变为VDD（一个0到1的转换）时，一旦输入超过阀值V_th，NMOS转换器将会离开截止区进入到饱和区。在这种转变的早期PMOS仍将处在线性区，因此电流将从VDD流向地。随着输入的上升沿，输出将产生下降沿。当NMOS的漏极低于栅极电压的阈值时，NMOS过渡到线性区域，并且PMOS转换到饱和区，然后截止。为了最大限度地减少的功耗，希望尽量减少在饱和区的时间;也就是，最小化门处理输入转换的时间。</p>
<p><em>为了最小化器件的输入功耗，最小化趋动输入的上升沿和下降沿时间。</em></p>
<p>可以从上面的方程得出另一个重要的结论。如果驱动信号不在稳定在0或Vdd的阀值电压范围内（例如，当栅极不进行切换时），之前截止的晶体管将会进入饱和区并开始消耗少量电流。在用较小的信号摆幅驱动由更高电压供电的输入系统中这将会是一个系统问题。</p>
<p>与上面的原理相似，输入浮空比欠驱动的输入问题更严重。输入浮空被定义为一个欠驱动的输入，但是如果它是浮空的则没有办法得知是如何欠驱动的。有可能由于两个晶体管同时处于饱和区输入已经进入亚稳态。这将会对功耗产生灾难性的影响。更糟糕的是，这是一个不可重复的问题。因为大多数FPGA器件都可以将不用的输入引脚端接上下拉电阻，定义明确的逻辑状态这是一种好的设计，并且避免了浮空输入所带来的未知影响。</p>
<p><em>务必总是端接未用的输入引脚。决不要让FPGA的输入浮空。</em></p>
<h3 id="3-3-降低供电电压"><a href="#3-3-降低供电电压" class="headerlink" title="3.3 降低供电电压"></a>3.3 降低供电电压</h3><p>尽管降低供电电压通常不是一个理想的选项，但它是值得被提及的，因为它对功耗的往往有着戏剧性的影响。在简单的阻性负载上功耗的降低会与电压呈平方比。因此，让FPGA工作在要求的最小工作电压上将可以显著降低功耗。请重点注意，较低的电压降会降低系统性能。如果用了这个方法，请确保计算最差时序时将低电压考虑进时序分析中。</p>
<p><em>动态功耗的降低将与核心电压呈平方比，但是降低电压会给性能带来负面影响。</em></p>
<p>因为FPGA的核心电压的可调率往往只有规定值的5%到10%，所以需要从系统层面考虑这个问题。典型的，保证电压在规定范围内，功耗问题还可以通过其它方式解决。</p>
<h3 id="3-4-双边沿触发器"><a href="#3-4-双边沿触发器" class="headerlink" title="3.4 双边沿触发器"></a>3.4 双边沿触发器</h3><p>由于功耗正比于信号翻转频率的事实，因此期望最大化每个高扇出网络的功能。常常像这样，高扇出网络是系统时钟，因此任何能够降低系统时钟频率的技术都可以对功态功耗造成极大的影响。双沿触发器提供了一种在时钟的两个边沿同时传播数据的机制。这样允许设计者以一半的时钟频率去达到要求的功能和性能。</p>
<p>对双沿触发器编码是非常简单的。下面的这个例子演示了一个简单的移位寄存器。注意，输入信号是在时钟的上沿捕获，然后被传递到双沿触发器。</p>
<pre><code>module dualedge(
    output reg dataout,
    input clk, datain);

    reg ff0, ff1;
    always @(posedge clk)
        ff0 &amp;lt;= datain;
    always @(posedge clk or negedge clk) begin
        ff1 &amp;lt;= ff0;
        dataout &amp;lt;= ff1;
    end
endmodule
</code></pre><p>注意如果没有双沿触发器可用，冗余的触发器和门电路将会被添加进去以模仿该功能。这样将会完全违背双沿策略的意思，并且应该在实现后进行合理的分析。一个好的综合工具至少会给出一个双沿触发器不可用的警告。</p>
<p><em>双沿触发器只应在它们被作为基本元件提供时才可以使用。</em></p>
<p>Xilinx Coolrunner-II 系列包含有一个命为CoolClock的资源，它可以将输入的时钟分为两路，并且将寄存器切换为上面描述的双沿触发器。从外部来看，系统的行为与单沿系统一样，但是功耗只有单沿系统的一半。</p>
<h3 id="3-5-修改端接"><a href="#3-5-修改端接" class="headerlink" title="3.5 修改端接"></a>3.5 修改端接</h3><p>在系统中常见的阻性负载有总线信号，开漏输出，或者是要求端接的传输线。在所有这些情况中，FPGA输出驱动中的CMOS管中的一个要么是通过这些阻性负载输出或者吸入电流。对于输出要求上拉的，请计算出最小的上升时间并依此取一个尽可能大的阻值。如果既有高端又有低端驱动器，请确没有任何可以让总线出现过大电流的条件，哪所它的持续时间只有几纳秒。对于具有需要进行终端分流负载的传输线，可能会有一系列会依据系统需求改变的端接。如图3.6，是一个没有稳态电流耗散的串行终端。</p>
<p><em>串行终端没有一个稳定的电流耗散。</em></p>
<p>缺点是：</p>
<ul>
<li>会有一个来自负载的初始反射到终端电阻</li>
<li>在传输中会在串联电阻上有一个小的衰减</li>
</ul>
<p><img src="/uploads/2015/10/Termination_types.png" alt="Termination_types"></p>
<p>如果对于一个特定的系统这些性能特性是可接受的，可以通过端接串联电阻来消除静态耗散。</p>
<h3 id="3-6-关键点汇总"><a href="#3-6-关键点汇总" class="headerlink" title="3.6 关键点汇总"></a>3.6 关键点汇总</h3><ul>
<li>像带时钟使能的触发器或者全局时钟切换器这样的时钟控制资源应该被用来代替直接的门控时钟，当它们可用时。</li>
<li>门控时钟意味着直接降低动态功耗，但是它会给实现和时序分析造成困难。</li>
<li>对时钟倾斜的处理不当会导致FPGA出现灾难性的故障。</li>
<li>门控时钟会导致保持时间违规，实现工具有可能会也有可能不会对它进行正确的处理。</li>
<li>最小化输入器件的功耗，就是最小化驱动输入端的信号的上升和下降时间。</li>
<li>总是端接未用的输入缓冲。决不要让FPGA的输入缓冲浮空。</li>
<li>动态功耗的降低与核心电压的降低成平方比，但是降低电压会给性能带来负面影响。</li>
<li>只有当器件内置双沿触发器时才可以在代码中使用双沿触发。</li>
<li>通过端接电阻可以没有静态耗散。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/FPGA/">FPGA</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-fpga-e6-9e-b6-e6-9e-84-e7-9a-84-e5-8a-9f-e8-80-97-e4-bc-98-e5-8c-96-ef-bc-882-ef-bc-89" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/04/fpga-e6-9e-b6-e6-9e-84-e7-9a-84-e5-8a-9f-e8-80-97-e4-bc-98-e5-8c-96-ef-bc-882-ef-bc-89/" class="article-date">
      <time datetime="2015-10-04T02:35:58.000Z" itemprop="datePublished">2015-10-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/04/fpga-e6-9e-b6-e6-9e-84-e7-9a-84-e5-8a-9f-e8-80-97-e4-bc-98-e5-8c-96-ef-bc-882-ef-bc-89/">FPGA架构的功耗优化（2）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <hr>
<p>原文： 《Advanced FPGA Design Architecture, Implementation,and Optimization》，Architecting Power</p>
<p>作者： Steve Kilts</p>
<p>译者： shawge</p>
<hr>
<h4 id="3-1-1-时钟倾斜"><a href="#3-1-1-时钟倾斜" class="headerlink" title="3.1.1 时钟倾斜"></a>3.1.1 时钟倾斜</h4><p>在直接讨论门控时钟的相关问题之前，我们必须首先回顾一下时钟倾斜这个话题。时钟倾斜这个概念在串行逻辑设计中非常重要。</p>
<p><img src="/uploads/2015/10/2015-10-04_103010.png" alt="clock_skew"></p>
<p>在图3.2中，假定第一个寄存器和第二个寄存器之间的传播延时为零。如果通过组合逻辑块的延时为正，那么时序收敛将取决于相对于时钟周期的组合延时+逻辑布线延迟+触发器建立时间。信号在每个时钟边沿只能在一组触发器这间传播。在第个二和第三个寄存器之间的情况与此类似，然而，又有所不同。因为在第二个和第三个寄存器之间时钟线的延时，有效时钟边延不会同时出现在两个元件上。而是，第三个寄存器的有效时钟边延将会有一个共计为dC延时。</p>
<p>如果逻辑延时（定义为dL）小于时钟延时（dC）,那么将会发生这样一钟情况，通过第二寄存器传播的信号可能会在有效时钟到来之前到达第三段。当有效时钟沿抵达时，同样的信号能通过第三段进行传播。因此，一个信号可以在同一个时钟沿同时通过第二段和第三段传播。这种情况将导致电路出现灾难性故障，因此在做时序分析时必须要将时钟倾斜考虑进去。注意，时钟倾斜是与时钟速度无关的这一点也非常重要。无论时钟频率怎么样，上面所描述的这种“飞越”问题完全会发生。</p>
<p><em>在FPGA中如果对时钟倾斜处理不当会导致灾难性故障。</em></p>
<h4 id="3-1-2-管理时钟倾斜"><a href="#3-1-2-管理时钟倾斜" class="headerlink" title="3.1.2 管理时钟倾斜"></a>3.1.2 管理时钟倾斜</h4><p>FPGA内部提供的低倾斜资源能够确保所有时钟输入脚尽可能紧地与时钟信号匹配（ps以内）。如图3.3列举了一个将门引入时钟网络的场景。</p>
<p><img src="/uploads/2015/10/2015-10-04_103028.png" alt="clock_skew_clock_gating"></p>
<p>时钟线必须从低倾斜的全局时钟资源中移除并布局到门逻辑，在这个例子中是一个与门。时钟线倾斜的基本问题跟之前描述的问题一样。可以认为经过门的延时（dG）加上布线延时将会大于逻辑延时（dL）。要处理这个潜在的问题，必须给执行和分析工具约束一组约束，使得与通过门控的倾斜相关的任何时序问题都被消除掉，然后再执行正确的实现后分析。</p>
<p>看看下面这个使用了门控时钟的模块的例子：</p>
<pre><code>// Poor design practice
module clockgating(
    output dataout,
    input clk, datain,
    input clockgate1);
    reg ff0, ff1, ff2;
    wire clk1;
    // clocks are disabled when gate is low
    assign clk1 = clk &amp;amp; clockgate1;
    assign dataout = ff2;
   always @(posedge clk)
       ff0 &amp;lt;= datain;
   always @(posedge clk)
       ff1 &amp;lt;= ff0;
   always @(posedge clk1)
       ff2 &amp;lt;= ff1;
endmodule
</code></pre><p>在上面这个例子中，在数据路径上的寄存器之间没有任何逻辑，但是在时钟路径上去有逻辑，如图3.4。</p>
<p><img src="/uploads/2015/10/2015-10-04_103040.png" alt="clock_skew_dominant_delay"></p>
<p>不同的工具处理这个问题的方式是不同的。有些工具如Synplify默认将会移除这个门控时钟，然后生成一个纯粹的同步设计。如果时钟没有添加任何约束另外一些工具将会忽略时钟倾斜问题，但是一旦添加了正确的时序约束，将会在时钟上增加额外的延时。</p>
<p>不像ASIC设计，保持时间违规在FPGA设计中是罕见的，由于内置的逻辑块和布线资源的延迟。然而能够导致保持时间延长的事就是如上所示在时钟线上产生了过多的延迟。因为数据传播如果小于1ns并且时钟的传播几乎为2ns，那么数据将比时钟早约1ns到达，这将导致严重的时序违规。这依赖于综合工具，有的时候能够通过添加一个时钟约束来解决这个问题。随后的分析可能显示也可能不显示（这取决于所用的技术）被加到数据路径中用于消除保持违规的人工延时。</p>
<p><em>门控时钟会导致保持违规，这有可能也可能不会被实现工具正确处理。</em></p>
<p>值得再次提醒，大多数的厂家都提供了高级的时钟buffer技术用于为时钟树的某些分枝提供使能能力。推荐总是使用这种类型的控制去替代门控时钟。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/FPGA/">FPGA</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-fpga-e6-9e-b6-e6-9e-84-e7-9a-84-e5-8a-9f-e8-80-97-e4-bc-98-e5-8c-96-ef-bc-881-ef-bc-89" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/30/fpga-e6-9e-b6-e6-9e-84-e7-9a-84-e5-8a-9f-e8-80-97-e4-bc-98-e5-8c-96-ef-bc-881-ef-bc-89/" class="article-date">
      <time datetime="2015-09-30T05:53:27.000Z" itemprop="datePublished">2015-09-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/30/fpga-e6-9e-b6-e6-9e-84-e7-9a-84-e5-8a-9f-e8-80-97-e4-bc-98-e5-8c-96-ef-bc-881-ef-bc-89/">FPGA架构的功耗优化（1）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <hr>
<p>原文： 《Advanced FPGA Design Architecture, Implementation,and Optimization》，Architecting Power</p>
<p>作者： Steve Kilts</p>
<p>译者： shawge</p>
<hr>
<p>本章我们将要讨论数字设计三个主要物理因素中的第三点：功耗。我们也会讨论在FPGA中优化架构功耗的方法。</p>
<p>相对于ASICs(专用集成电路)可比较的功能模块，FGPAs通常是耗电大户，并且不适合用于低功耗设计。许多的FPGA厂家提供低功耗的CPLDs（复杂可编程逻辑器修的），但是在面积和功能方面有限制，因此并不能适应需要大量计算能力的应用。本节将会调论如何最大化CPLDs和通用FPGA设计的能耗效率。</p>
<p>在CMOS技术中，动态功耗与对逻辑门和金属走线之间寄生电容的充放电相关。电容的通用电流耗散方程是</p>
<p><strong>I = V &#42; C &#42; f</strong></p>
<p>式中I是总流，V是电压，C是电容，f是频率。</p>
<p>因此，为了减小电流，我们必须降低这三个关键参数。在FPGA设计中，电压通常是固定的。这样只有C和f参数成为电流的主要参数。电容C与在给定时间内翻转的逻辑门的个数以及门电路的走线直接相关。频率f与时钟频率直接相关。所有的降低功耗的技术手段都指在降低这两个参数。</p>
<p>在本章的内容中，我们将会讨论下面几点：</p>
<ul>
<li>时钟控制对动态功耗的影响</li>
<li>门控时钟的问题， 控制时钟倾斜和门控时钟</li>
<li>输入控制的电源优化</li>
<li>核心供电电压的影响</li>
<li>双沿触发的指导</li>
<li>降低终端静态功耗</li>
</ul>
<p>通过最小化高翻转网络的布线长度来降低功耗需要布局和布线的背景知识，因此将在第15章布局规划中讨论。</p>
<h3 id="3-1-门控时钟"><a href="#3-1-门控时钟" class="headerlink" title="3.1 门控时钟"></a>3.1 门控时钟</h3><p>对于同步数字电路动态低功耗设计最有效和广泛使用的技术手段就是禁止那些在数据路径中不需要激活的区域的时钟。因为大多数FPGA的动态功耗直接与FPGA的系统时钟相关，临时关断非活动区域的时钟往往都是最小化动态功耗最直接有效的办法。对于这种情况推荐的方式是用触发器的时钟使能脚或者全局的时钟选择器（在Xilinx器件中叫作BUFGMUX元件）。如果在一个特定的设计没有时钟控制单元可以使用，设计者往往只能诉诸于直接用逻辑门产生时钟。注意在FPGA中不推荐这么干，本节也将会讨论也将会涉及到这种直接的门控时钟。</p>
<p><em>时钟控制资源包括触发器的时钟使能引脚或者是全局时钟选择器应该被用来代替直接的门控时钟</em></p>
<p>请注意，本节假定读者已经熟悉了一般FPGA时钟设计指导。通常，FPGA是同步器件，但是在通过逻辑门或者异步接口引入多时钟域后同步将会变得很困难。有关跨时钟域的讨论可以参见第6章。</p>
<p><img src="/uploads/2015/09/gateClock.png" alt=""></p>
<p>图3.1展示了门控时钟的一个糟糕设计实践。在这个时钟拓扑中，所有的寄存器和组合逻辑都是在注时钟有效时翻转或有效。然而虚线框内的逻辑只有在时钟Clock Enable = 1时才会有效。这里，我们将时钟使能信号作为门或者使信号。如图通过门控电路的某些部分，设计者设图降低在逻辑门的总数（寄生电容C）和相应门电路的平均翻转频率（频率f）。</p>
<p><em>门控时钟是一个降低动态功耗的有直接办法，但是它给实现和时序分析造成困难。</em></p>
<p>在我们着手实施细节之前，注意仔细规划FPGA设计的时钟是非常重要的。系统时钟是所有同步设计的重心。EDA（电子设计自动化）工具是通过系统时钟来驱动优化和验证综合，布局，静态时序分析等等。因此，系统时钟或者时钟是神圣的，并且必须用于作为过程实现的驱动导向。时钟在FPGA中甚至比在ASICs中更神圣，因此对于创建时钟结构有较少的灵活性。</p>
<p>当一个时钟被门控时，即便捡最不紧要的说，由门控时钟驱动的新网络应被认为是一个新的时钟域。这个新的时钟网络将会要求一个在它这个域内对所有触发器都有低时钟倾斜的路径，类似于它所衍生自的系统时钟。对于ASIC设计，这些低时钟倾斜线能够通过定制的时钟树来完成，但是对于FPGA设计而言，这样做不可行，因为它的低倾斜线数量有效而且布局固定。</p>
<p><em>门控时钟引入一个新的时钟域，这会给FPGA设计造成困难。</em></p>
<p>以下各节讨论通过门控时钟引入的问题。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/FPGA/">FPGA</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e5-a6-82-e4-bd-95-e8-a7-a3-e5-86-b3gcc-e6-88-96mdk-e6-88-96iar-e5-bc-80-e5-90-af-o3-ef-bc-88-e6-9c-80-e9-ab-98-e7-ba-a7-e5-88-ab-ef-bc-89-e4-bc-98-e5-8c-96-e5-90-8e-e7-a8-8b-e5-ba-8f-e4-b8-8d" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/25/e5-a6-82-e4-bd-95-e8-a7-a3-e5-86-b3gcc-e6-88-96mdk-e6-88-96iar-e5-bc-80-e5-90-af-o3-ef-bc-88-e6-9c-80-e9-ab-98-e7-ba-a7-e5-88-ab-ef-bc-89-e4-bc-98-e5-8c-96-e5-90-8e-e7-a8-8b-e5-ba-8f-e4-b8-8d/" class="article-date">
      <time datetime="2015-09-25T03:34:41.000Z" itemprop="datePublished">2015-09-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/25/e5-a6-82-e4-bd-95-e8-a7-a3-e5-86-b3gcc-e6-88-96mdk-e6-88-96iar-e5-bc-80-e5-90-af-o3-ef-bc-88-e6-9c-80-e9-ab-98-e7-ba-a7-e5-88-ab-ef-bc-89-e4-bc-98-e5-8c-96-e5-90-8e-e7-a8-8b-e5-ba-8f-e4-b8-8d/">如何解决GCC或MDK或IAR开启-O3（最高级别）优化后程序不能正常运行的问题?</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><a href="/uploads/2015/09/gcclogo.jpg"><img src="/uploads/2015/09/gcclogo-268x300.jpg" alt="gcclogo"></a></p>
<p>最近有个项目用了别人的一些驱动代码，DEBUG正常运行，但是RELEASE却不能运行。</p>
<p>因为是release态，程序下的断点和单步调试基本没法看，除非你去看汇编，所以首先我用了这样一个宏来打印程序运行到哪儿了。</p>
<pre><code> #define TRACE_LINE_FILE do{    TRACE(__FILE__); TRACE(&quot;:%.04d\n&quot;,__LINE__);} while(0)

`&lt;/pre&gt;

直接调用`TRACE_LINE_FILE;`后会打印出当前宏所在文件名和该宏所在的行，效果如下。当然你用printf之类的也完全可以。

[![2015-09-25_111627](
</code></pre><p>/uploads/2015/09/2015-09-25_111627.png)](<br>/uploads/2015/09/2015-09-25_111627.png)</p>
<pre><code>通过这种方式我定位到了下面这行代码被优化了。

&lt;pre&gt;`do
{
    ...

    while(NULL == flag);

    ...
}
...

`&lt;/pre&gt;

于是我试着将它改成了下面的形式就正常了。

&lt;pre&gt;`while(true)
{
  ...

   if(NULL == flag)
       continue;

  ....
}

`&lt;/pre&gt;

然后的通过同样方式我发现很多全局变量也被优化掉了（由于别人的代码是C代码），特别是中断中使用到的标志变量，

&lt;pre&gt;`
void DMA1_Channel2_IRQHandler(void)
{
   /*判断是否是dma1 channel2 接收完成中断*/
    if(DMA_GetITStatus(DMA1_IT_TC2)==SET)
    {
        DMA_ClearITPendingBit(DMA1_IT_TC2);/*清dma1 channel2中断标志*/

#if SPI_W25Q_USE_DMA        
        //Debug(&quot;DMA1_Channel2_IRQHandler\r\n&quot;);
        PI_W25Q_USE_DMA_RX_FLAG = 1;
#endif
#if __GUI_USE_DOUBLE_FRAME
        //在W25QReadBmp_Data 中清空
        W25Q_ReadByteOnce = W25Q_Temp_ReadByteOnce;
        W25Q_Current_Buf = W25Q_Temp_Current_Buf; //TRACE(&quot;W25Q_Current_Buf:%0.8x\n&quot;, W25Q_Temp_Current_Buf); TRACE_LINE_FILE;
        //Test += W25Q_ReadByteOnce;
        //Debug(&quot;DMA%x\r\n&quot;, Test);
        //W25QReadBmp_Data();
#endif     
    }
}

`&lt;/pre&gt;

我将这些变量加上volatile即可。

&lt;pre&gt;`
volatile u8 *W25Q_Current_Buf = NULL;
volatile u8 *W25Q_Temp_Current_Buf = NULL;

volatile u8 *W25Q_Double_Frame_Buf[2] = {NULL};
volatile static u32 W25Q_Read_Count = 0;
volatile u32 W25Q_ReadByteOnce = 0;
volatile u32 W25Q_Temp_ReadByteOnce = 0;

`&lt;/pre&gt;

最后，发现还是有问题，经过查到代码中的依靠计来实现delay的变量也应加了volatile，显然下面代码中的i如果不加上volatile会被优化掉，因为这个变量的值虽然改变了，但并未在其它地方被引用。

&lt;pre&gt;`
/**********************************************
函数名：LCD_Delay
功能：用于LCD配置延时
入口参数：延时数
返回值：无
***********************************************/
static void LCD_DelayMs(u32 Ms)
{
    volatile u32 i;
    for(; Ms; Ms--)
        for(i=1000;i;i--);
}
</code></pre><p>当然如果你是用的GCC，你可以用GCC提供的标准delay函数。</p>
<blockquote>
<p>&#35;include &lt;util/delay.h&gt;<br>  _delay_ms()<br>  _delay_us()</p>
</blockquote>
<p>另外如果你用nop指令来延时，那最好重定nop如下：</p>
<blockquote>
<p>&#35;define nop() <strong>asm</strong> <strong>volatile</strong>(“nop”)</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/MCU-ARM/">MCU/ARM</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e7-ba-bf-e9-98-b5ccd-e4-b8-93-e7-94-a8ad9945-e9-85-8d-e7-bd-ae-e7-a8-8b-e5-ba-8f-e6-ba-90-e7-a0-81-ef-bc-88-e5-b7-b2-e9-aa-8c-e8-af-81-e9-80-9a-e8-bf-87-ef-bc-89" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/19/e7-ba-bf-e9-98-b5ccd-e4-b8-93-e7-94-a8ad9945-e9-85-8d-e7-bd-ae-e7-a8-8b-e5-ba-8f-e6-ba-90-e7-a0-81-ef-bc-88-e5-b7-b2-e9-aa-8c-e8-af-81-e9-80-9a-e8-bf-87-ef-bc-89/" class="article-date">
      <time datetime="2015-09-19T11:05:41.000Z" itemprop="datePublished">2015-09-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/19/e7-ba-bf-e9-98-b5ccd-e4-b8-93-e7-94-a8ad9945-e9-85-8d-e7-bd-ae-e7-a8-8b-e5-ba-8f-e6-ba-90-e7-a0-81-ef-bc-88-e5-b7-b2-e9-aa-8c-e8-af-81-e9-80-9a-e8-bf-87-ef-bc-89/">线阵CCD专用AD9945 配置程序源码（已验证通过）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>这个是用逻辑分析仪捕获的验证结果（虽然这种简单的通信接口不用逻辑分析仪不用示波器调试两下也能搞定，但shawge确实有点强迫症，非得看看确认一下。）</p>
<p><a href="/uploads/2015/09/ad9945_timming.png"><img src="/uploads/2015/09/ad9945_timming-300x231.png" alt="ad9945_timming"></a></p>
<hr>
<p><strong>注意事项</strong></p>
<p>首先看一下AD9945的串行配置时序图，尤其其中我画过红线的注解。</p>
<p><a href="/uploads/2015/09/2015-09-19_185332.png"><img src="/uploads/2015/09/2015-09-19_185332-300x214.png" alt="AD9945_REG"></a></p>
<p>上图的第一部分是只写一个寄存器的操作，这里面要注意第3点“所有发送的数据都必须是12位的，如果寄存器本身的位数少于12，那么要将这些未定义的位用0填充”。</p>
<p>上图的第二部分是连续写寄存器，注意第2点“首先写入起始寄存器地址，然后紧随12bit的数据字”，还有第3点“内部寄存器地址会在每次写入12bit的数据字后自动递增”，因此如我程序中所示，直接写入寄存器起始地址0x0(4bit)，然后把其它寄存器都填充完。</p>
<p>下面再看看AD9945寄存器位的定义。</p>
<p><a href="/uploads/2015/09/2015-09-19_185849.png"><img src="/uploads/2015/09/2015-09-19_185849-300x180.png" alt="AD9945_REGISTER"></a></p>
<p>注意将STARTUP寄存器之前的寄存器全部填充完后，应将Startups寄存器写入一个固定值0x838才能启动AD。这里有一个疑问的是DCLK及SHP、SHD的时钟有效极性，在AD9945手册的时序示例图中是上升沿有效，但是寄存器位中只能选择高电平或低电平有效，经过我的试验，我觉得如果按手册中的时序图来配置，那么这三个寄存器位都应设0，即低电平有效。</p>
<p><strong>adc.h</strong></p>
<pre><code>#ifndef _ADC_H
#define _ADC_H

#include &amp;lt;stdint.h&amp;gt;

#define SCK_H  (GPIO_SetBits(GPIOB, GPIO_Pin_13))
#define SCK_L  (GPIO_ResetBits(GPIOB, GPIO_Pin_13))
#define SDA_H  (GPIO_SetBits(GPIOB, GPIO_Pin_14))
#define SDA_L  (GPIO_ResetBits(GPIOB, GPIO_Pin_14))
#define SL_H   (GPIO_SetBits(GPIOB, GPIO_Pin_15))
#define SL_L   (GPIO_ResetBits(GPIOB, GPIO_Pin_15))

#define ADDR_REG_START 0x00
#define ADDR_REG_STARTUP 0x0d

#define START_ADC 0x838

typedef struct 
{
    struct 
    {
        uint16_t rstSoft:1;         
        uint16_t modePwr:2;         
        uint16_t obDisable:1;       
        uint16_t testMode1:2;       
        uint16_t pblkLevel:1;       
        uint16_t lowGainMode:2;                             
        uint16_t testMod2:3;        
    } reg0;

    ///////////////////////////////////
    struct 
    {
        uint16_t shpdPolarity:1;            
        uint16_t dclkPolarity:1;            
        uint16_t clpobPolarity:1;           
        uint16_t pblkPolarity:1;            
        uint16_t threeStateOutput:1;        
        uint16_t latchingOutput:1;          
        uint16_t codingOutput:1;            
        uint16_t testMode3:5;               
    } reg1;

    ////////////////////////////////////////
    struct  
    {
        uint16_t obClampLevel:8;            
    } reg2;

    ////////////////////////////////////////
    struct 
    {
    uint16_t vgaGain:10;                    
    } reg3;

    /////////////////
    struct 
    {
        uint16_t startup:12;                    
    } regStartup;
}DatAdc;

void initIoAdc(void);
void initAdcStruct(DatAdc* datAdc);
void cfgAdc(DatAdc datAdc);
void startAdc(DatAdc datAdc);
void rstAdc(DatAdc datAdc);

#endif

`&lt;/pre&gt;

**adc.c**

&lt;pre&gt;`

#include &quot;adc.h&quot;
#include &quot;stm32f4xx_gpio.h&quot;

void initIoAdc()
{
    GPIO_InitTypeDef  GPIO_InitStructure;
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13       //PC13 -&amp;gt; SCK
                                    | GPIO_Pin_14   //PC14 -&amp;gt; SDA
                                    | GPIO_Pin_15;  //PC15 -&amp;gt; SL
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT; 
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP; 
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_25MHz;//100MHz
    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP; 
    GPIO_Init(GPIOB, &amp;amp;GPIO_InitStructure);

    SL_H;
    SCK_L;
    SDA_H;

}

void sendStart()
{
    SL_H;
    SL_L;
}

void sendOver()
{
    SL_L;
    SL_H;
    SCK_L;
}

void sendAddr4Bit(uint8_t addr)
{
    for(int i= 0; i&amp;lt;4; i++)
    {
        SCK_L;

        ((addr&amp;gt;&amp;gt;i) &amp;amp; 0x01) ? SDA_H : SDA_L;

        SCK_H;
    }
}

void sendDat12Bit(uint16_t data)
{
    for(int i= 0; i&amp;lt;12; i++)
    {
        SCK_L;

        ((data&amp;gt;&amp;gt;i) &amp;amp; 0x01) ? SDA_H : SDA_L;

        SCK_H;
    }
}

void initAdcStruct(DatAdc* pDatAdc)
{
    pDatAdc-&amp;gt;reg0.rstSoft = 0x0;                // 0 = Normal Operation, 1 = Reset all registers to default
    pDatAdc-&amp;gt;reg0.modePwr = 0x0;                // 00 = Normal Power, 01 = Standby, 10 = Total Shutdown
    pDatAdc-&amp;gt;reg0.obDisable = 0x0;          // 0 = Clamp ON, 1 = Clamp OFF
    pDatAdc-&amp;gt;reg0.testMode1 = 0x0;          // Should always be set to 00.
    pDatAdc-&amp;gt;reg0.pblkLevel = 0x0;          // 0 = Blank Output to Zero, 1 = Blank to OB Clamp Level)
    pDatAdc-&amp;gt;reg0.lowGainMode = 0x0;        // Normally set to 00\. To enable low gain mode, set to 11\. When low gain mode
                                                                            // is enabled, VGA Gain register must be set to all zeroes.
    pDatAdc-&amp;gt;reg0.testMod2 = 0x0;               //Should always be set to 000.

    ///////////////////////////////////
    pDatAdc-&amp;gt;reg1.shpdPolarity = 0x0;           // 0 = Active Low, 1 = Active High
    pDatAdc-&amp;gt;reg1.dclkPolarity = 0x0;           // 0 = Active Low, 1 = Active High
    pDatAdc-&amp;gt;reg1.clpobPolarity = 0x0;      // 0 = Active Low, 1 = Active High
    pDatAdc-&amp;gt;reg1.pblkPolarity = 0x0;           // 0 = Active Low, 1 = Active High
    pDatAdc-&amp;gt;reg1.threeStateOutput = 0x0;       // 0 = Outputs Active, 1 = Outputs Three-Stated
    pDatAdc-&amp;gt;reg1.latchingOutput = 0x0;     //0 = Latched by DATACLK, 1 = Latch is Transparent
    pDatAdc-&amp;gt;reg1.codingOutput = 0x0;           //0 = Binary Output, 1 = Gray Code Output
    pDatAdc-&amp;gt;reg1.testMode3 = 0x00;         //Should always be set to 00000.

    ///////////////////////////////////
    pDatAdc-&amp;gt;reg2.obClampLevel = 128;       // 0 = 0 LSB, 255 = 255 LSB

    ///////////////////////////////////
    pDatAdc-&amp;gt;reg3.vgaGain = 0x0;                // 0 = 6 dB, 1023 = 40 dB

    //////////////////////////////////
    pDatAdc-&amp;gt;regStartup.startup = START_ADC;        // must be set to 0x838 
}

void cfgAdc(DatAdc datAdc)
{
    sendStart();
    //发送起始地址
    sendAddr4Bit(ADDR_REG_START);
    uint16_t* pValue = (uint16_t*) &amp;amp;(datAdc.reg0);
    sendDat12Bit(*pValue); //发送寄存器0数据
    pValue = (uint16_t*) &amp;amp;(datAdc.reg1);
    sendDat12Bit(*pValue);  //发送寄存器1数据
    pValue = (uint16_t*) &amp;amp;(datAdc.reg2);
    sendDat12Bit(*pValue);  //发送寄存器2数据
    pValue = (uint16_t*) &amp;amp;(datAdc.reg3);
    sendDat12Bit(*pValue);  //发送寄存器3数据
    pValue = (uint16_t*) &amp;amp;(datAdc.regStartup);  
    sendDat12Bit(*pValue); //发送启动寄存器数据
    sendOver();
}

//发送启动命令
void startAdc(DatAdc datAdc)
{
    sendStart();
    //先发送起始地址
    sendAddr4Bit(ADDR_REG_STARTUP);
    uint16_t* pValue = (uint16_t*) &amp;amp;(datAdc.regStartup);    
    sendDat12Bit(*pValue);  
    sendOver();
}

void rstAdc(DatAdc datAdc)
{
    datAdc.reg0.rstSoft = 0x1;
    sendStart();
    //先发送起始地址
    sendAddr4Bit(ADDR_REG_START);
    uint16_t* pValue = (uint16_t*) &amp;amp;(datAdc.reg0);  
    sendDat12Bit(*pValue);  
    sendOver();

    datAdc.reg0.rstSoft = 0x0;
    sendStart();
    //先发送起始地址
    sendAddr4Bit(ADDR_REG_START);
    pValue = (uint16_t*) &amp;amp;(datAdc.reg0);    
    sendDat12Bit(*pValue);  
    sendOver(); 
}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/MCU-ARM/">MCU/ARM</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2016 shawge
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/luuman/hexo-theme-spfk" target="_blank">spfk</a> by luuman
            </div>
        </div>
        
    </div>
</footer>

    </div>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 17;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>