<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>hex55</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="hex55">
<meta property="og:url" content="http://hex55.com/page/4/index.html">
<meta property="og:site_name" content="hex55">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="hex55">
  
    <link rel="alternative" href="/atom.xml" title="hex55" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: false,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img src="/img/head.jpg" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/">shawge</a></h1>
        </hgroup>

        
        <p class="header-subtitle">shawge的电子技术分享</p>
        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">博客首页</a></li>
                        
                            <li><a href="/categories/MCU-ARM/">MCU/ARM</a></li>
                        
                            <li><a href="/categories/FPGA/">FPGA</a></li>
                        
                            <li><a href="/categories/windows-linux/">WINDOWS/LINUX</a></li>
                        
                            <li><a href="/categories/硬件设计/">硬件设计</a></li>
                        
                            <li><a href="/archives/">归档</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=27O_o_7um6qq9bi0tg" title="mail">mail</a>
                            
                                <a class="fl rss" target="_blank" href="/atom.xml" title="rss">rss</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/github-提速/" style="font-size: 10px;">github 提速</a>
                    </div>
                </section>
                
                
                

                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">没想好。。。</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">shawge</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img src="/img/head.jpg" class="js-avatar" style="width: 100%; height: 100%; opacity: 1;">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">shawge</a></h1>
            </hgroup>
            
            <p class="header-subtitle">shawge的电子技术分享</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">博客首页</a></li>
                
                    <li><a href="/categories/MCU-ARM/">MCU/ARM</a></li>
                
                    <li><a href="/categories/FPGA/">FPGA</a></li>
                
                    <li><a href="/categories/windows-linux/">WINDOWS/LINUX</a></li>
                
                    <li><a href="/categories/硬件设计/">硬件设计</a></li>
                
                    <li><a href="/archives/">归档</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=27O_o_7um6qq9bi0tg" title="mail">mail</a>
                    
                        <a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-e5-b0-86newlib-e7-9a-84printf-e9-87-8d-e5-ae-9a-e5-90-91-e5-88-b0tft-lcd-e6-98-be-e7-a4-ba" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/15/e5-b0-86newlib-e7-9a-84printf-e9-87-8d-e5-ae-9a-e5-90-91-e5-88-b0tft-lcd-e6-98-be-e7-a4-ba/" class="article-date">
      <time datetime="2015-09-15T08:24:55.000Z" itemprop="datePublished">2015-09-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/15/e5-b0-86newlib-e7-9a-84printf-e9-87-8d-e5-ae-9a-e5-90-91-e5-88-b0tft-lcd-e6-98-be-e7-a4-ba/">将newlib的printf重定向到TFT LCD显示</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>最近实在是厌烦了MDK和IAR这种二逼的IDE工具，MLGB！尤其在多个工程中切换的时候，一会是source insight之类中进行代码编辑一会是在MDK中进行调试，切来切去切得烦死了，总是容易搞错，而且这些工具对中文的编码还不一致，有的用多字节，有的用UNICODE，好好的注释让他们给变成了乱码。KEIL MDK，IAR EWARM你们TMD既然要做IDE为什么不把编辑器做好一点，没办法用惯了eclipse和vs的我实在受不了你们！CoIDE这个工具是用eclipse修改的，之前因为在sonosape的时候看同事试过一次觉得调试下断点太难用了，所以最终我还是找到了一款支持VS进行STM32 MCU开发的工具——visual gdb。其实这工具完完全全地是用GNU编译链做成的，作者为VS写一款GUI界面的插件，用起来也蛮简单，网上有CRACK版，不过在我的VS2012下破解后该插件启动不起来，还好有30天的试用，哈哈足够了！感兴趣可以试一下哦！</p>
<p><a href="/uploads/2015/09/2015-09-15_160638.png"><img src="/uploads/2015/09/2015-09-15_160638-300x240.png" alt="visual gdb"></a></p>
<hr>
<p>下面说正事，这玩意如果用标准C库的话，如果你整点printf之类的函数，或者你再整点C++代码，那基本上你的MCU空间肯定在写了几行代码后就去了一大半，好在它有一个解决方案，用是选用newlib。</p>
<p>你可以在新建工程时就选择newlib，对于已存在的工程（我一开始新建工程时根本不知道newlib是什么，后来发现空间不够了才去查资料，但代码都写了一些了），经过在VISUAL GDB的官网我查询到了方法：</p>
<p>首先点change settings按钮,</p>
<p><a href="/uploads/2015/09/2015-09-15_160938.png"><img src="/uploads/2015/09/2015-09-15_160938-300x240.png" alt="2015-09-15_160938"></a></p>
<p>然后在C Library Type中选择newlib-nano,如果你用C++为了节省空间你最好也勾选上Reduce the size of C++ binaries.</p>
<p><a href="/uploads/2015/09/2015-09-15_161014.png"><img src="/uploads/2015/09/2015-09-15_161014-300x277.png" alt="2015-09-15_161014"></a></p>
<p>记得勾上 provide default stubs for system calls，即提供默认的系统调用，如果你不选上这一项编译的时候会出现下面一系列链接错误。</p>
<pre><code>1&amp;gt;  c:/sysgcc/arm-eabi/bin/../lib/gcc/arm-eabi/5.2.0/../../../../arm-eabi/lib/thumb/cortex_m3\libc_nano.a(lib_a-abort.o): In function `abort&apos;:
1&amp;gt;q:\gnu\newlib-nano\build-2015q2\arm-eabi\thumb\cortex_m3\newlib\libc\stdlib\..\..\..\..\..\..\..\newlib-nano-2015q2\newlib\libc\stdlib\abort.c(63): error VGDB1000: undefined reference to `_exit&apos;
1&amp;gt;  c:/sysgcc/arm-eabi/bin/../lib/gcc/arm-eabi/5.2.0/../../../../arm-eabi/lib/thumb/cortex_m3\libc_nano.a(lib_a-signalr.o): In function `_kill_r&apos;:
1&amp;gt;q:\gnu\newlib-nano\build-2015q2\arm-eabi\thumb\cortex_m3\newlib\libc\reent\..\..\..\..\..\..\..\newlib-nano-2015q2\newlib\libc\reent\signalr.c(61): error VGDB1000: undefined reference to `_kill&apos;
1&amp;gt;  c:/sysgcc/arm-eabi/bin/../lib/gcc/arm-eabi/5.2.0/../../../../arm-eabi/lib/thumb/cortex_m3\libc_nano.a(lib_a-signalr.o): In function `_getpid_r&apos;:
1&amp;gt;q:\gnu\newlib-nano\build-2015q2\arm-eabi\thumb\cortex_m3\newlib\libc\reent\..\..\..\..\..\..\..\newlib-nano-2015q2\newlib\libc\reent\signalr.c(96): error VGDB1000: undefined reference to `_getpid&apos;

`&lt;/pre&gt;

当然你可以自己全部重写这些调用，但是我觉得没有必要，我们只需要要main中重载我们需要的调用即可，比如本文需要对printf进行重定向至LCD，所以我们只需要自己写 ** int _write (int fd, char *pBuffer, int size)  ** 函数即可。

&lt;pre&gt;`
    int _write (int fd, char *pBuffer, int size)
    {
        //for (int i = 0; i &amp;lt; size; i++)
        //{
        //  while (!(USART1-&amp;gt;SR &amp;amp; USART_SR_TXE))
        //  {
        //  }
        //  USART_SendData(USART1, pBuffer[i]);
        //}

        static uint16_t x = 0, y = 0;
        //uint8_t string[16];

        for (uint8_t i=0; i&amp;lt;size; i++)
        {
            uint8_t ch = *(pBuffer+i);

            //控制字符处理
            if(&apos;\n&apos; == ch || &apos;\r&apos; == ch)   //换行
            {
                x = 0;
                y += 16;
                return ch;
            }

            //显示越界处理
            if(x &amp;gt; LCD_WIDTH - 8) //X_MAX是宏定义, 该值为240
            {
                x = 0;         //x置零
                y += 16;       //y移至下一行
            }
            if(y &amp;gt; LCD_HIGHT - 16) //Y_MAX是宏定义, 该值是320
            {
                //return ch;      //直接退出

                y = 0;
            }

            if (0==y &amp;amp;&amp;amp; 0==x)
            {
                LCD_FillScreen(0x0000); //清屏，并从第一行开始    
            }

            //显示可见字符
            drawAsc8x16(x,y,ch);

            x += 8;                //跳转到下一个位置, 是否越界有上面函数判断
        }

        return size;
    }

`&lt;/pre&gt;

将LCD_FillScreen替换成你的LCD清屏函数，将drawAsc8x16替换成你的显示字符的LCD函数。

如果你要将printf重定向到USART，那么将上面代码中的这一段

&lt;pre&gt;`        //  while (!(USART1-&amp;gt;SR &amp;amp; USART_SR_TXE))
        //  {
        //  }
        //  USART_SendData(USART1, pBuffer[i]);
</code></pre><p>替换成你的发送单个字符的USART函数，当然你也可以将那一段代码修改成你批量发送N个字符的函数，其中N就是size，这一点与KEIL的重定向函数 <strong> PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f) </strong> 略有差异。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/MCU-ARM/">MCU/ARM</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e6-9d-a5-e7-82-b9-e5-86-b7-e7-9a-84-e7-94-b5-e5-ad-90-e7-9f-a5-e8-af-86" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/10/e6-9d-a5-e7-82-b9-e5-86-b7-e7-9a-84-e7-94-b5-e5-ad-90-e7-9f-a5-e8-af-86/" class="article-date">
      <time datetime="2015-09-10T13:34:59.000Z" itemprop="datePublished">2015-09-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/10/e6-9d-a5-e7-82-b9-e5-86-b7-e7-9a-84-e7-94-b5-e5-ad-90-e7-9f-a5-e8-af-86/">来点冷的电子知识</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <hr>
<p><strong>CPU及常用的半导体器件为什么都是用硅而不是锗制造的？</strong></p>
<p>通常在我们高中物理及大学的模拟电子技术基础课程书本上，都会讲到硅和锗都是比较常用的半导体器件，但在我个人的现实生活中，除了小时候拆过锗管的收音机，现在生活中用到的无论是二极管、三极管、IC芯片无一不是硅制成的，之前也在网络上见到有人问这个问题，大体上的回答都是从工艺制程及成本方面考虑的，无非以下几点：</p>
<ol>
<li>容易提纯，硅从砂子中就得取得，而锗只能从锗矿中产生，因而成本也比较高。</li>
<li>容易形成较大的晶体（看下面这张制作IC用的晶圆图），便于割加工。</li>
<li>容易形成“硅/氧化硅界面”绝缘层。</li>
<li>做掺杂后，容易用金刚石结构退火工艺修复损伤（这一点shawge我不是学材料和化工的，实在不懂）。</li>
<li>容易完成激光蚀刻等与IC生产相关的工艺。</li>
</ol>
<p><a href="/uploads/2015/09/Wafer.jpg"><img src="/uploads/2015/09/Wafer-300x200.jpg" alt="Wafer"></a></p>
<p>而电气性能方面，锗管又有以缺点：锗管的放大倍数小，泄漏电流大，分布电容较大；工作频率低，功耗大，温度特性不好，工作不稳定。</p>
<p>这些我觉得都说得没什么惊奇的，无非就是锗这玩意又贵，性能又差！性能好，价格贵点有出路；性能差点价格贵点也有出路，但性能又差价格又贵只有死路一条。但是今天登邮箱看到知乎每周推送的一个帖子，其中从物理特性其电学稳定性方面作出了锗退出历史舞台的解释，同时还附送了一个小故事：</p>
<p><a href="/uploads/2015/09/世界上第一个点接触晶体管锗管.png"><img src="/uploads/2015/09/世界上第一个点接触晶体管锗管-300x300.png" alt="世界上第一个点接触晶体管(锗管)"></a></p>
<blockquote>
<p>在遥远的上古时代（1950~），那时候集成电路还没有发明，晶体管的分立器件就已经慢慢由锗变成了硅。这是为什么呢？<br>  世界上第一个和第一个商用的双极结型晶体管都是用锗做的。摩托罗拉公司当时还是一家车载收音机的制造商。摩托&gt; &gt;罗拉是当时第一家使用晶体管来制造收音机的厂商。但是好景不长，摩托罗拉收到了大量用户投诉，说他们发现摩托罗&gt;拉的车载收音机在午后的阳光下曝晒一个下午后，就不再工作了。摩托罗拉被搞得焦头烂额，这从市场层面给了摩托罗&gt;拉公司很强的动力用硅替换锗来制造晶体管。<br>  为啥会这样呢？因为锗在受热之后会变成本征态，这使得n型半导体和p型半导体都失去了他们特有的性质，那结果呢就&gt;是双极结型晶体管不能再工作了。而硅可以经受更高温度的考验。<br>  出自——<a href="http://www.zhihu.com/question/28935966/answer/60729143?utm_campaign=weekly186&amp;utm_source=weekly-digest&amp;utm_medium=email" target="_blank" rel="external">《为什么 CPU 只用硅做，而不用能耗更低的锗做？》</a></p>
</blockquote>
<p><strong>原来锗没能大规模用来做半导体的原因是因为它太容易受温度影响而变得不稳定，你总不想你的电子产品太阳晒一晒就玩完了吧！</strong> 更专业的解释请自行参看上文给出的链接。</p>
<hr>
<p><strong>为什么MOSFET我们常用的只有两种？</strong></p>
<p>通常教科书上都说MOSFET有PMOS和NMOS，而PMOS和NMOS又分别有增强型和耗尽型，也就是说MOSFET应该有四种，但我们在使用时通常只用增强型NMOS和增加型PMOS，而在这两种MOS中我们又更偏好用于NMOS，原因是</p>
<blockquote>
<p>NMOS导通电阻小，且容易制造。（出自——<a href="http://www.21ic.com/jichuzhishi/analog/basic/2013-06-27/185163.html" target="_blank" rel="external">《MOS管使用扫盲》</a>）</p>
</blockquote>
<p><a href="/uploads/2015/09/mosfet.png"><img src="/uploads/2015/09/mosfet.png" alt="mosfet"></a></p>
<p>看上面这个图你还会发现NMOS是正压导通，PMOS是负压导通的。另外在网上还看到了下面这样一个解释</p>
<blockquote>
<p>N-MOS管的优势在于导通电阻更小<br>  手机上用P-MOS管都是在电源部分，特别是电池充电电路。N-MOS导通要求栅极电压高于源级，手机上最高的电压就是<br>  电池电压了，无法控制N-MOS导通，所以多用P-MOS管<br>  其实在直流电源之类的大功率电器里，N-MOS的使用更多</p>
</blockquote>
<p>但是<a href="http://www.21ic.com/jichuzhishi/analog/basic/2013-06-27/185163.html" target="_blank" rel="external">《MOS管使用扫盲》</a>一文说“至于为什么不使用耗尽型的MOS管，不建议刨根问底”，这着实让我更为不解，我试图打破沙锅，在中文世界里没有找到答案，在英语世界里也没有找着（可能我英语太渣，也可能问题太冷门老外对这个也不感兴趣），哪位搞半导体专业的同学能为我解惑一下？</p>
<hr>
<p><strong>未完待续，慢慢收录</strong></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/闲言碎语/">闲言碎语</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e6-95-99-e5-b8-88-e8-8a-82-e5-bf-ab-e4-b9-90-ef-bc-81" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/10/e6-95-99-e5-b8-88-e8-8a-82-e5-bf-ab-e4-b9-90-ef-bc-81/" class="article-date">
      <time datetime="2015-09-10T07:19:43.000Z" itemprop="datePublished">2015-09-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/10/e6-95-99-e5-b8-88-e8-8a-82-e5-bf-ab-e4-b9-90-ef-bc-81/">教师节快乐！</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>话说前几个月给公司同事做了个培训，然后今天就收到人资的鲜花，还有合影（怕是要上公司小报），旁边的妹子说，“你是不是第一次收到鲜花？哈哈”。其实我上大学时也收到过的，不过不是妹子给的，是校长发的，但申明我真的不是学霸，而且也不擅为人师，惭愧！</p>
<p><a href="/uploads/2015/09/2015-09-10-14.32.332.jpg"><img src="/uploads/2015/09/2015-09-10-14.32.332-300x225.jpg" alt="2015-09-10 14.32.33"></a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/闲言碎语/">闲言碎语</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-mcu-e9-80-9a-e7-94-a8-e6-8c-89-e9-94-ae-ef-bc-88-e5-90-ab-e8-a7-a6-e6-91-b8-ef-bc-89-e5-a4-84-e7-90-86-e6-a8-a1-e5-9d-97-ef-bc-8c-e6-94-af-e6-8c-81-e5-a7-94-e6-89-98" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/09/mcu-e9-80-9a-e7-94-a8-e6-8c-89-e9-94-ae-ef-bc-88-e5-90-ab-e8-a7-a6-e6-91-b8-ef-bc-89-e5-a4-84-e7-90-86-e6-a8-a1-e5-9d-97-ef-bc-8c-e6-94-af-e6-8c-81-e5-a7-94-e6-89-98/" class="article-date">
      <time datetime="2015-09-09T14:07:24.000Z" itemprop="datePublished">2015-09-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/09/mcu-e9-80-9a-e7-94-a8-e6-8c-89-e9-94-ae-ef-bc-88-e5-90-ab-e8-a7-a6-e6-91-b8-ef-bc-89-e5-a4-84-e7-90-86-e6-a8-a1-e5-9d-97-ef-bc-8c-e6-94-af-e6-8c-81-e5-a7-94-e6-89-98/">mcu通用按键（含触摸）处理模块，支持委托</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>优点暂且不表，待我大规模使用时再一一添上，当然缺点一目了然，用了STL，会增加对FLASH和SRAM的消耗，当然你也可以自己实现这个vector以减小代码尺寸，还可以通过用回调来取代虚函数，以进一步减小资源消耗。其中 keyDispatch.h、delegate.h、和keyDrv.h，这三个文件为我所写，cypress触摸按键用的是金同学写的（金同学看到莫见怪，哈哈），懒得去封装，也一并奉上。</p>
<p><a href="/uploads/2015/09/T1Y_5aXo4pXXc0Zx3U_015130.jpg_240x240.jpg"><img src="/uploads/2015/09/T1Y_5aXo4pXXc0Zx3U_015130.jpg_240x240.jpg" alt="T1Y_5aXo4pXXc0Zx3U_015130.jpg_240x240"></a></p>
<hr>
<p><strong>keyDispatch.h（实现按键的派遣，用委托实现解耦）</strong></p>
<pre><code>#ifndef _KEY_DISPATCH_H
#define _KEY_DISPATCH_H

#include &quot;delegate.h&quot;
#include &amp;lt;vector&amp;gt;
#include &quot;keyDrv.h&quot;

using namespace delegate;

class COven;

class CKeyDispatch
{
public:
    CKeyDispatch(){};
    ~CKeyDispatch(){};

    //typedef std::vector&amp;lt;DelegateObject&amp;lt;CKeyInfo, COven&amp;gt; *&amp;gt;::iterator ITER_HANDLER;
    typedef std::vector&amp;lt;DelegateBase&amp;lt;CKeyInfo&amp;gt; *&amp;gt;::iterator ITER_HANDLER;

    void invoke(CKeyInfo keyInfo)
    {
        for (ITER_HANDLER it = m_handlers.begin(); it != m_handlers.end(); ++it) 
        {
            if((*it)-&amp;gt;Invoke(&amp;amp;keyInfo))
                return;
        }
    }

    bool operator+=(/*DelegateObject&amp;lt;CKeyInfo, COven&amp;gt;*/DelegateBase&amp;lt;CKeyInfo&amp;gt; * handler)
    {
        m_handlers.push_back(handler);
    }

private:
    //std::vector&amp;lt;DelegateObject&amp;lt;CKeyInfo, COven&amp;gt; *&amp;gt; m_handlers;
    std::vector&amp;lt;DelegateBase&amp;lt;CKeyInfo&amp;gt; *&amp;gt; m_handlers;
};

#endif
`&lt;/pre&gt;

* * *

**delegate.h(一个简单的C++委托实现，参考了网上的一些代码)**

&lt;pre&gt;`

#ifndef __DELEGATE_H__
#define __DELEGATE_H__

namespace delegate
{
    // 委托基类
    // Arg: 目标函数参数
    // Invoke: 调用目标函数[虚函数]
    // operator(): 功能=Invoke
    template&amp;lt;typename Arg&amp;gt;
    class DelegateBase
    {
    public:
        virtual ~DelegateBase(){};
        virtual bool Invoke(Arg* pArg) = 0;
        bool operator()(Arg* pArg) 
        { 
            return Invoke(pArg); 
        };
    }; // class DelegateBase

    // function类型委托
    // m_method: 目标函数
    template&amp;lt;typename Arg&amp;gt;
    class DelegateFunction
        : public DelegateBase&amp;lt;Arg&amp;gt;
    {
    public:
        typedef void(*Method)(Arg* arg);
        DelegateFunction(Method method)
            : m_method(method)
        {

        }

        bool Invoke(Arg* pArg) 
        {
            return m_method(pArg);
        }

        Method m_method;
    }; // class DelegateFunction

    // class类型委托
    // T: class类型
    // m_pObject: class对象
    template&amp;lt;typename Arg, typename T&amp;gt;
    class DelegateObject
        : public DelegateBase&amp;lt;Arg&amp;gt;
    {
    public:
        typedef bool (T::*Method)(Arg* pArg);

        DelegateObject(T* pObject, Method method)
            : m_pObject(pObject)
            , m_method(method)
        { }

        bool Invoke(Arg* pArg) 
        { 
            return (m_pObject-&amp;gt;*m_method)(pArg); 
        }

        T* m_pObject;

        Method m_method;
    }; // class DelegateObject
} // namespace delegate
#endif // __DELEGATE_H__

`&lt;/pre&gt;

* * *

**keyDrv.h（一个简单的按键状态处理逻辑，至于长按计时将由上层调用定时器模块去完成，以降低该模块的复杂度，实现通用性）**

&lt;pre&gt;`

#ifndef _KEY_DRV_H
#define _KEY_DRV_H

#include &amp;lt;stdint.h&amp;gt;
#include &quot;m_CY8C4014_TouchKey.h&quot;

typedef enum 
{
    KEY_NONE = 0x00,                //无按键
    KEY_PWR ,
    KEY_LIGHT,
    KEY_PREHEAT_FAST,
    KEY_CANCEL,
    KEY_OK_PAUSE,
    KEY_LEFT_TOP,
    KEY_RIGHT_TOP,
    KEY_RIGHT_BOTTOM,
    KEY_LEFT_BOTTOM,
} KEY_CODE;

typedef enum
{
    STATE_KEY_INIT = 0x00,          //初始化状态
    STATE_KEY_PUSH = 0x01,          //有键按下
    STATE_KEY_HOLD_DOWN = 0x11, //有键长按
    STATE_KEY_BOUNCE = 0x10     //全部键弹起
} STATE_KEY;

class  CKeyCode
{
public:

    CKeyCode()
    {
        for (uint8_t i=0; i&amp;lt;SIZE_KEY_CODE; i++)
        {
            m_code[i] = KEY_NONE;
        }
    }

    void operator=(const CKeyCode code)
    {
        for (uint8_t i=0; i&amp;lt;SIZE_KEY_CODE; i++)
        {
            m_code[i] = code.m_code[i];
        }
    }

    bool operator==(const CKeyCode code)
    {
        for (uint8_t i=0; i&amp;lt;SIZE_KEY_CODE; i++)
        {
            if(m_code[i] != code.m_code[i])
                return false;
        }

        return true;
    }

    bool operator!=(const CKeyCode code)
    {
        for (uint8_t i=0; i&amp;lt;SIZE_KEY_CODE; i++)
        {
            if(m_code[i] != code.m_code[i])
                return true;
        }

        return false;
    }

    uint8_t m_code[SIZE_KEY_CODE];
};

class CKeyInfo
{
public:
    CKeyInfo()
    {
        for (uint8_t i=0; i&amp;lt;NUM_KEY; i++)
        {
            m_state[i] = STATE_KEY_INIT;
        }
    }

    CKeyCode m_keyCode;
    STATE_KEY m_state[NUM_KEY];
} ;

class CKeyDrv
{
public:

public:
    CKeyDrv()
    {
    }

    ~CKeyDrv()
    {

    }

    const CKeyInfo getKeyInfo()
    {
        return m_keyInfo;
    }

    void keyProc()
    {
        if (readKey())
        {
            for (uint8_t i=0; i&amp;lt;SIZE_KEY_CODE; i++)
            {
                for(uint8_t j=0; j&amp;lt;8; j++)
                {
                    if(((i&amp;lt;&amp;lt;3)+j) &amp;lt; 9)
                        m_keyInfo.m_state[i] = (STATE_KEY) (((m_keyInfo.m_keyCode.m_code[i]&amp;gt;&amp;gt;(j-1)) &amp;amp;0x02) &amp;amp; 
                        ((m_codeKeyCur.m_code[i]&amp;gt;&amp;gt;j) &amp;amp; 0x01));
                }
            }
        }

        m_keyInfo.m_keyCode = m_codeKeyCur;
    }

private:
    inline bool readKey()
    {
        return CyTP_ReadKey_Proc((uint8_t*) &amp;amp;m_codeKeyCur.m_code,sizeof(m_codeKeyCur.m_code));
    }

private:
    CKeyInfo m_keyInfo;
    CKeyCode m_codeKeyCur;
};

#endif

`&lt;/pre&gt;

* * *

**m_CY8C4014_TouchKey.h（CY8C4014触摸IC的驱动头文件）**

&lt;pre&gt;`#ifndef _m_CY8C4041_TouchKey_h
#define _m_CY8C4041_TouchKey_h

#ifdef __cplusplus
extern &quot;C&quot; {
#endif 

#include &quot;stm32f10x.h&quot;
#include &quot;../DefineMacro.h&quot;

#define TPSlaveDevice_Read         0x11
#define TPSlaveReg_Addr                0x00

#define NUM_KEY    9 //按建个数
#define SIZE_CHECK_CODE_KEY 2

#define SIZE_KEY_CODE (NUM_KEY/sizeof(uint8_t))  //

    BOOL CyTP_ReadKey_Proc(u8 *pKeyValue_Ret, u8 Lenth);

#ifdef __cplusplus
}
#endif

#endif

`&lt;/pre&gt;

* * *

**m_CY8C4014_TouchKey.c（CY8C4014触摸IC的驱动实现文件）**

&lt;pre&gt;`
#include &quot;m_CY8C4014_TouchKey.h&quot;
#include &quot;m_IICStandard.h&quot;
#include &quot;m_BeepDrive.h&quot;
#include &quot;../DefineMacro.h&quot;
#include &quot;stm32f10x.h&quot;

#define IIC_ACK        1
#define IIC_NoACK  0

uint16_t LRC(uint8_t *auchMsg,uint8_t usDataLen)
{ 
    uint16_t uchLRC = 0 ; /* LRC ????? */
    while (usDataLen--)
        uchLRC += *auchMsg++;

    uchLRC=~uchLRC;
    uchLRC+=1;

    return uchLRC;
}

BOOL CyTP_ReadKey_Proc(u8 *pKeyValue_Ret, u8 Lenth)
{
    u8 keyValue[SIZE_KEY_CODE + SIZE_CHECK_CODE_KEY];
    u8 i=0;

    StardandIIC_Start(DeviceID_TP);
    StardandIIC_WriteOneByte(DeviceID_TP,TPSlaveDevice_Read);

    StardandIIC_SendACK(DeviceID_TP,IIC_ACK);

    for(i=0;i&amp;lt;Lenth;i++)
    {
        keyValue[i] =StardandIIC_ReadOneByte(DeviceID_TP);
        if(i&amp;lt;SIZE_KEY_CODE)
            *(pKeyValue_Ret+1) = keyValue[i];

        if(i!=(Lenth-1))
            StardandIIC_SendACK(DeviceID_TP,IIC_ACK);
        else
            StardandIIC_SendACK(DeviceID_TP,IIC_NoACK);
    }

    StardandIIC_Stop(DeviceID_TP);

    if(*((uint16_t*) (keyValue+2)) != LRC(keyValue,SIZE_KEY_CODE))
        return FALSE;

    return TRUE;
}

`&lt;/pre&gt;

* * *

**m_IICStandard.h（软件GPIO模拟IIC的头文件）**

&lt;pre&gt;`#ifndef _m_IICStandard_h
#define _m_IICStandard_h

#ifdef __cplusplus
extern &quot;C&quot; {
#endif 

#include &quot;stm32f10x.h&quot;
#include &quot;stm32f10x_gpio.h&quot;
#include &quot;../DefineMacro.h&quot;

#define TPSet_SCL_Pin()                    {GPIOC-&amp;gt;ODR|=GPIO_Pin_2;}
#define TPClr_SCL_Pin()                    {GPIOC-&amp;gt;ODR&amp;amp;=~ GPIO_Pin_2;}
#define TPConv_SCL_Pin()               {GPIOC-&amp;gt;ODR^=GPIO_Pin_2;}

#define TPSet_SDA_Pin()                    {GPIOC-&amp;gt;ODR|=GPIO_Pin_3;}
#define TPClr_SDA_Pin()                    {GPIOC-&amp;gt;ODR&amp;amp;=~ GPIO_Pin_3;}
#define TPConv_SDA_Pin()               {GPIOC-&amp;gt;ODR^=GPIO_Pin_3;}

#define TPRead_SDA_Pin()               (GPIOC-&amp;gt;IDR&amp;amp;Bit16(3))

#define E2PROMSet_SCL_Pin()                {GPIOC-&amp;gt;ODR|=GPIO_Pin_2;}
#define E2PROMClr_SCL_Pin()                {GPIOC-&amp;gt;ODR&amp;amp;=~ GPIO_Pin_2;}
#define E2PROMConv_SCL_Pin()               {GPIOC-&amp;gt;ODR^=GPIO_Pin_2;}

#define E2PROMSet_SDA_Pin()                {GPIOC-&amp;gt;ODR|=GPIO_Pin_3;}
#define E2PROMClr_SDA_Pin()                {GPIOC-&amp;gt;ODR&amp;amp;=~GPIO_Pin_3;}
#define E2PROMConv_SDA_Pin()               {GPIOC-&amp;gt;ODR^=GPIO_Pin_3;}

#define E2PROMRead_SDA_Pin()               (GPIOC-&amp;gt;IDR&amp;amp;Bit16(3))

void TPSDA_OutputMode(void);
void TPSDA_InputMode(void);

#define E2PROMSDA_OutputMode()     {TPSDA_OutputMode();}
#define E2PROMSDA_InputMode()          {TPSDA_InputMode();}

#define DeviceID_TP                    0
#define DeviceID_E2PROM            1

u8 StardandIIC_ReadOneByte(u8 DeviceID);

void IICDevice_IOInit(void);

void StardandIIC_Start(u8 DeviceID);

void StardandIIC_Stop(u8 DeviceID);

void StardandIIC_SendACK(u8 DeviceID,u8 ACK_Flag);

void StardandIIC_WriteOneByte(u8 DeviceID,u8 Data);

u8 StardandIIC_ReadOneByte(u8 DeviceID);

void Delay_Nus(u16 n_us);

#ifdef __cplusplus
}
#endif

#endif

`&lt;/pre&gt;

* * *

**m_IICStandard.c（软件GPIO模拟IIC的实现文件）**

&lt;pre&gt;`
#include &quot;m_IICStandard.h&quot;
#include &quot;m_BeepDrive.h&quot;

void IICDevice_IOInit(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;

    GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Pin=(GPIO_Pin_3|GPIO_Pin_2);
    GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;

    GPIO_Init(GPIOC,&amp;amp;GPIO_InitStructure);

    TPClr_SDA_Pin();
    TPClr_SCL_Pin();
}

__INLINE void Delay_Nus(volatile u16  n_us)
{
    u16  i=0;

    do
    {
        i++;
    }while(i&amp;lt;n_us);
}

void TPSDA_OutputMode(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;

    GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Pin=GPIO_Pin_3;
    GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;

    GPIO_Init(GPIOC,&amp;amp;GPIO_InitStructure);
}

void TPSDA_InputMode(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;

    GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IN_FLOATING;
    GPIO_InitStructure.GPIO_Pin=GPIO_Pin_3;

    GPIO_Init(GPIOC,&amp;amp;GPIO_InitStructure);
}

void StardandIIC_Start(u8 DeviceID)
{
    if(DeviceID==DeviceID_TP)
    {
        TPSet_SDA_Pin();
    }
    else
        E2PROMSet_SDA_Pin();

  Delay_Nus(40);

    if(DeviceID==DeviceID_TP)
  {
        TPSet_SCL_Pin( );
    }
    else
        E2PROMSet_SCL_Pin( );

  Delay_Nus(40);          // repeated start setup time

    if(DeviceID==DeviceID_TP)
  {
        TPClr_SDA_Pin();
    }
    else
        E2PROMClr_SDA_Pin();

  Delay_Nus(40);          // start condition hold time

    if(DeviceID==DeviceID_TP)
  {
        TPClr_SCL_Pin( );
    }
    else
        E2PROMClr_SCL_Pin( );

     Delay_Nus(40); 
}

void StardandIIC_Stop(u8 DeviceID)
{
    if(DeviceID==DeviceID_TP)
  {
        TPClr_SDA_Pin();
    }
    else
        E2PROMClr_SDA_Pin();

  Delay_Nus(40);

    if(DeviceID==DeviceID_TP)
  {
        TPSet_SCL_Pin();
    }
    else
        E2PROMSet_SCL_Pin();

  Delay_Nus(40);      // stop condition setup time

    if(DeviceID==DeviceID_TP)
  {
        TPSet_SDA_Pin();
    }
    else
        E2PROMSet_SDA_Pin();

  Delay_Nus(40);         // bus free time between stop and start
}

void StardandIIC_SendACK(u8 DeviceID,uint8_t ACK_Flag)
{
  Delay_Nus(40);          // data hold time

  if(ACK_Flag) 
  {
        if(DeviceID==DeviceID_TP)
        {
            TPClr_SDA_Pin();
        }
        else
            E2PROMClr_SDA_Pin();
  }
  else 
  {
        if(DeviceID==DeviceID_TP)
        {
            TPSet_SDA_Pin();
        }
        else
            E2PROMSet_SDA_Pin();
  }

  Delay_Nus(40);           // data setup time
  Delay_Nus(40);          // SCL low period

    if(DeviceID==DeviceID_TP)
  {
        TPSet_SCL_Pin();
    }
    else
        E2PROMSet_SCL_Pin();

  Delay_Nus(40);            // SCL high period

    if(DeviceID==DeviceID_TP)
  {
        TPClr_SCL_Pin();
    }
    else
        E2PROMClr_SCL_Pin();

  Delay_Nus(40);               // SCL low period
}

void StardandIIC_WriteOneByte(u8 DeviceID,uint8_t Data)
{
    u8 i=0;
    for(i=0; i&amp;lt;8; i++) 
    {
      Delay_Nus(40);         // data hold time
      if(Data &amp;amp; 0x80) 
      {
                if(DeviceID==DeviceID_TP)
                {
                    TPSet_SDA_Pin();
                }
                else
                    E2PROMSet_SDA_Pin();
      }
      else 
      {
                if(DeviceID==DeviceID_TP)
                {
                    TPClr_SDA_Pin();
                }
                else
                    E2PROMClr_SDA_Pin();
      }

      Data &amp;lt;&amp;lt;= 1;
      Delay_Nus(40);          // data setup time
      Delay_Nus(40);             // SCL low period

            if(DeviceID==DeviceID_TP)
      {
                TPSet_SCL_Pin();
            }
            else
                E2PROMSet_SCL_Pin();

      Delay_Nus(40);            // SCL high period

            if(DeviceID==DeviceID_TP)
      {
                TPClr_SCL_Pin();
            }
            else
                E2PROMClr_SCL_Pin();
   }

    // wait slave ACK
   if(DeviceID==DeviceID_TP) 
    {
            TPSDA_InputMode();   // release SDA
    }
   else
            E2PROMSDA_InputMode();   // release SDA

    Delay_Nus(40);                // SCL low period

        if(DeviceID==DeviceID_TP) 
    {
            TPSet_SCL_Pin();           // slave ACK  (slave should ACK, but we don&apos;t check it)
        }
    else
        {
            E2PROMSet_SCL_Pin();           // slave ACK  (slave should ACK, but we don&apos;t check it)
        }

    Delay_Nus(40);              // SCL high period

        i=8;
        while(i)
        {
            if(DeviceID==DeviceID_TP) 
        {
                if(TPRead_SDA_Pin())   
                {
                    i--;
                }
                else
                {
                    i=0;
                }
            }
            else
            {
                if(E2PROMRead_SDA_Pin())   
                    i--;
                else
                    i=0;
            }
        }

        if(DeviceID==DeviceID_TP) 
        {
            TPClr_SCL_Pin();
        }
        else
            E2PROMClr_SCL_Pin();

    Delay_Nus(40);               // SCL low period

        if(DeviceID==DeviceID_TP) 
        {
                TPSDA_OutputMode();
        }
        else
            E2PROMSDA_OutputMode();

        if(DeviceID==DeviceID_TP) 
    {
            TPSet_SDA_Pin();
        }
        else
            E2PROMSet_SDA_Pin();
}

uint8_t StardandIIC_ReadOneByte(u8 DeviceID)
{
    uint8_t RetData=0;
    uint8_t i=0;

    if(DeviceID==DeviceID_TP)
    TPSDA_InputMode(); 
    else
        E2PROMSDA_InputMode(); 

  for(i=0;i&amp;lt;8;i++)
  {
      RetData &amp;lt;&amp;lt;= 1;
      Delay_Nus(40);                 // SCL low period

            if(DeviceID==DeviceID_TP)
      {
                TPSet_SCL_Pin();
            }
            else
                E2PROMSet_SCL_Pin();

            if(DeviceID==DeviceID_TP)
            {
                if(TPRead_SDA_Pin())
                    RetData|=0x01;
            }
            else
            {
                if(E2PROMRead_SDA_Pin())
                    RetData|=0x01;
            }

      Delay_Nus(40);                // SCL high period

            if(DeviceID==DeviceID_TP)
      {
                TPClr_SCL_Pin();
            }
            else
                E2PROMClr_SCL_Pin();
  }

    if(DeviceID==DeviceID_TP)
        TPSDA_OutputMode(); 
    else
        E2PROMSDA_OutputMode(); 

    return RetData;
}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/MCU-ARM/">MCU/ARM</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e7-ba-bf-e9-98-b5ccd-e6-95-b0-e6-8d-ae-e9-87-87-e9-9b-86adcad9945-e5-88-9d-e5-a7-8b-e9-85-8d-e7-bd-ae-e5-8c-96-e6-ba-90-e7-a0-81" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/07/e7-ba-bf-e9-98-b5ccd-e6-95-b0-e6-8d-ae-e9-87-87-e9-9b-86adcad9945-e5-88-9d-e5-a7-8b-e9-85-8d-e7-bd-ae-e5-8c-96-e6-ba-90-e7-a0-81/" class="article-date">
      <time datetime="2015-09-07T01:52:43.000Z" itemprop="datePublished">2015-09-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/07/e7-ba-bf-e9-98-b5ccd-e6-95-b0-e6-8d-ae-e9-87-87-e9-9b-86adcad9945-e5-88-9d-e5-a7-8b-e9-85-8d-e7-bd-ae-e5-8c-96-e6-ba-90-e7-a0-81/">线阵CCD数据采集ADC(AD9945)初始配置化源码</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>原本是用FPGA来配置AD9945的，后来感觉每次改参数都要重新生成，下载，FPGA的bitstream生成又比单片机慢很多，显得太麻烦。而且很难做到参数的自适应配置，所以最终采用MCU来配置，程序刚写完，还没有测试，迫不及待地发一份作为配份，回头验证完了再补发一个修正版本。源码是.c格式的，MCU是stm32F4,所以喜欢C++的自行封装一下，喜欢用其它MCU的自己改一下端口初始化，如果你是用的STM32F3，那么只需要将包含的头文件“stm32f4_gpio.h”改为“stm32f3_gpio.h”，以及将“stm32f429_439.h”替换为“stm32f10x.h”（我或许对文件名记忆有误，或部分未提及，我相信用stm32的朋友来说解决两个编译错误，这完全不是问题）。</p>
<p><a href="/uploads/2015/09/ad9945_config_initinal.png"><img src="/uploads/2015/09/ad9945_config_initinal-300x268.png" alt="ad9945_config_initinal"></a></p>
<p><a href="/uploads/2015/09/tcd1209.gif"><img src="/uploads/2015/09/tcd1209-300x157.gif" alt="tcd1209"></a></p>
<hr>
<p><strong>AD9945.h(2015/09/07/21:44修正)</strong></p>
<pre><code>#ifndef _ADC_H
#define _ADC_H

#include &amp;lt;stdint.h&amp;gt;

#define SCK_H  (GPIO_SetBits(GPIOB, GPIO_Pin_13))
#define SCK_L  (GPIO_ResetBits(GPIOB, GPIO_Pin_13))
#define SDA_H  (GPIO_SetBits(GPIOB, GPIO_Pin_14))
#define SDA_L  (GPIO_ResetBits(GPIOB, GPIO_Pin_14))
#define SL_H   (GPIO_SetBits(GPIOB, GPIO_Pin_15))
#define SL_L   (GPIO_ResetBits(GPIOB, GPIO_Pin_15))

#define ADDR_DATA 0x00
#define ADDR_STARTUP 0x0d

#define START_ADC 0x838

typedef struct 
{
    struct 
    {
        uint16_t rstSoft:1;         
        uint16_t modePwr:2;         
        uint16_t obDisable:1;       
        uint16_t testMode1:2;       
        uint16_t pblkLevel:1;       
        uint16_t lowGainMode:2;                             
        uint16_t testMod2:3;        
    } reg0;

    ///////////////////////////////////
    struct 
    {
        uint16_t shpdPolarity:1;            
        uint16_t dclkPolarity:1;            
        uint16_t clpobPolarity:1;           
        uint16_t pblkPolarity:1;            
        uint16_t threeStateOutput:1;        
        uint16_t latchingOutput:1;          
        uint16_t codingOutput:1;            
        uint16_t testMode3:5;               
    } reg1;

    ////////////////////////////////////////
    struct  
    {
        uint16_t obClampLevel:8;            
    } reg2;

    ////////////////////////////////////////
    struct 
    {
    uint16_t vgaGain:10;                    
    } reg3;

    /////////////////
    struct 
    {
        uint16_t startup:12;                    
    } regStartup;
}DatAdc;

void initIoAdc(void);
void initAdcStruct(DatAdc* datAdc);
void cfgAdc(DatAdc datAdc);
void startAdc(DatAdc datAdc);
void rstAdc(DatAdc datAdc);

#endif

`&lt;/pre&gt;

**AD9945.c**

&lt;pre&gt;`

#include &quot;adc.h&quot;
#include &quot;stm32f4xx_gpio.h&quot;

void initIoAdc()
{
    GPIO_InitTypeDef  GPIO_InitStructure;
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13       //PC13 -&amp;gt; SCK
                                    | GPIO_Pin_14   //PC14 -&amp;gt; SDA
                                    | GPIO_Pin_15;  //PC15 -&amp;gt; SL
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT; 
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP; 
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_25MHz;//100MHz
    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP; 
    GPIO_Init(GPIOB, &amp;amp;GPIO_InitStructure); 
}

void sendStart()
{
    SL_H;
    SL_L;
}

void sendOver()
{
    SL_L;
    SL_H;
}

void sendAddr3Bit(uint8_t addr)
{
    for(int i= 0; i&amp;lt;3; i++)
    {
        SCK_L;

        ((addr&amp;gt;&amp;gt;i) &amp;amp; 0x01) ? SDA_H : SDA_L;

        SCK_H;
    }
}

void send12Bit(uint16_t data)
{
    for(int i= 0; i&amp;lt;12; i++)
    {
        SCK_L;

        ((data&amp;gt;&amp;gt;i) &amp;amp; 0x01) ? SDA_H : SDA_L;

        SCK_H;
    }
}

void initAdcStruct(DatAdc* pDatAdc)
{
    pDatAdc-&amp;gt;reg0.rstSoft = 0x0;                // 0 = Normal Operation, 1 = Reset all registers to default
    pDatAdc-&amp;gt;reg0.modePwr = 0x0;                // 00 = Normal Power, 01 = Standby, 10 = Total Shutdown
    pDatAdc-&amp;gt;reg0.obDisable = 0x0;          // 0 = Clamp ON, 1 = Clamp OFF
    pDatAdc-&amp;gt;reg0.testMode1 = 0x0;          // Should always be set to 00.
    pDatAdc-&amp;gt;reg0.pblkLevel = 0x0;          // 0 = Blank Output to Zero, 1 = Blank to OB Clamp Level)
    pDatAdc-&amp;gt;reg0.lowGainMode = 0x0;                // Normally set to 00\. To enable low gain mode, set to 11\. When low gain mode
                                            // is enabled, VGA Gain register must be set to all zeroes.
    pDatAdc-&amp;gt;reg0.testMod2 = 0x0;               //Should always be set to 000.

    ///////////////////////////////////
    pDatAdc-&amp;gt;reg1.shpdPolarity = 0x0;           // 0 = Active Low, 1 = Active High
    pDatAdc-&amp;gt;reg1.dclkPolarity = 0x0;           // 0 = Active Low, 1 = Active High
    pDatAdc-&amp;gt;reg1.clpobPolarity = 0x0;      // 0 = Active Low, 1 = Active High
    pDatAdc-&amp;gt;reg1.pblkPolarity = 0x0;           // 0 = Active Low, 1 = Active High
    pDatAdc-&amp;gt;reg1.threeStateOutput = 0x0;       // 0 = Outputs Active, 1 = Outputs Three-Stated
    pDatAdc-&amp;gt;reg1.latchingOutput = 0x0;     //0 = Latched by DATACLK, 1 = Latch is Transparent
    pDatAdc-&amp;gt;reg1.codingOutput = 0x0;           //0 = Binary Output, 1 = Gray Code Output
    pDatAdc-&amp;gt;reg1.testMode3 = 0x00;         //Should always be set to 00000.

    ///////////////////////////////////
    pDatAdc-&amp;gt;reg2.obClampLevel = 128;       // 0 = 0 LSB, 255 = 255 LSB

    ///////////////////////////////////
    pDatAdc-&amp;gt;reg3.vgaGain = 0x0;                // 0 = 6 dB, 1023 = 40 dB

    //////////////////////////////////
    pDatAdc-&amp;gt;regStartup.startup = START_ADC;        // must be set to 0x838 
}

void cfgAdc(DatAdc datAdc)
{
    sendStart();
    //先发送起始地址
    sendAddr3Bit(ADDR_DATA);
    uint16_t* pValue = (uint16_t*) &amp;amp;(datAdc.reg0);
    send12Bit(*pValue);
    pValue = (uint16_t*) &amp;amp;(datAdc.reg1);
    send12Bit(*pValue); 
    pValue = (uint16_t*) &amp;amp;(datAdc.reg2);
    send12Bit(*pValue);
    pValue = (uint16_t*) &amp;amp;(datAdc.reg3);
    send12Bit(*pValue); 
    sendOver();
}

//发送启动命令
void startAdc(DatAdc datAdc)
{
    sendStart();
    //先发送起始地址
    sendAddr3Bit(ADDR_STARTUP);
    uint16_t* pValue = (uint16_t*) &amp;amp;(datAdc.regStartup);    
    send12Bit(*pValue); 
    sendOver();
}

void rstAdc(DatAdc datAdc)
{
    datAdc.reg0.rstSoft = 0x1;
    sendStart();
    //先发送起始地址
    sendAddr3Bit(ADDR_STARTUP);
    uint16_t* pValue = (uint16_t*) &amp;amp;(datAdc.reg0);  
    send12Bit(*pValue); 
    sendOver();

    datAdc.reg0.rstSoft = 0x0;
    sendStart();
    //先发送起始地址
    sendAddr3Bit(ADDR_STARTUP);
    pValue = (uint16_t*) &amp;amp;(datAdc.reg0);    
    send12Bit(*pValue); 
    sendOver(); 
}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/MCU-ARM/">MCU/ARM</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e6-80-8e-e4-b9-88-e8-a7-a3-e5-86-b3mdk-e6-af-8f-e6-ac-a1-e9-83-bd-e5-85-a8-e7-bc-96-e8-af-91-e7-9a-84-e5-8a-9e-e6-b3-95" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/06/e6-80-8e-e4-b9-88-e8-a7-a3-e5-86-b3mdk-e6-af-8f-e6-ac-a1-e9-83-bd-e5-85-a8-e7-bc-96-e8-af-91-e7-9a-84-e5-8a-9e-e6-b3-95/" class="article-date">
      <time datetime="2015-09-06T12:23:18.000Z" itemprop="datePublished">2015-09-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/06/e6-80-8e-e4-b9-88-e8-a7-a3-e5-86-b3mdk-e6-af-8f-e6-ac-a1-e9-83-bd-e5-85-a8-e7-bc-96-e8-af-91-e7-9a-84-e5-8a-9e-e6-b3-95/">怎么解决MDK 每次都全编译的办法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>这个问题之前也遇见过，但时间一长就忘了，所以还是归纳一下在博客里作个记录吧。</p>
<hr>
<p>KEIL MDK 无论你是按F7还是选编译，它都会执行全编译而不是增量编译的原因，除了有可能是MDK部分版本的BUG（4.7~5.0中有部分版本有该问题）外，通常是因为这两个选项</p>
<p><a href="/uploads/2015/09/2015-09-06_201506.png"><img src="/uploads/2015/09/2015-09-06_201506-300x223.png" alt="MDK总是全编译问题1"></a></p>
<p>上面这个“跨模块优化”选项打开，往往会起到很显著的精减代码尺寸的效果，当然速度也有可能会加快，但是每次代码更改会他都会进行全局优化，所以会进行全编译。</p>
<p><a href="/uploads/2015/09/2015-09-06_201623.png"><img src="/uploads/2015/09/2015-09-06_201623-300x223.png" alt="2015-09-06_201623"></a></p>
<p>上图这个“生成批处理”的选项通常用来在外部编辑器中调用KEIL MDK的ARMCC工具链进行编译用，比如用visual stdio调用KIEL的编译链，或者用ECLIPSE调用KIEL完成代码的编译。当这个选项打开时，哪怕你只是添了个空行都会进行全编译。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/MCU-ARM/">MCU/ARM</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-stm32-jtag-e5-8f-a3-e5-a6-82-e4-bd-95-e5-a4-8d-e7-94-a8-ef-bc-9f" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/02/stm32-jtag-e5-8f-a3-e5-a6-82-e4-bd-95-e5-a4-8d-e7-94-a8-ef-bc-9f/" class="article-date">
      <time datetime="2015-09-02T11:12:50.000Z" itemprop="datePublished">2015-09-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/02/stm32-jtag-e5-8f-a3-e5-a6-82-e4-bd-95-e5-a4-8d-e7-94-a8-ef-bc-9f/">STM32 JTAG 口如何复用？</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>我的原理图如下：</p>
<p><a href="/uploads/2015/08/2015-09-02_220530.png"><img src="/uploads/2015/08/2015-09-02_220530-300x156.png" alt="2015-09-02_220530"></a></p>
<p>首先要开启AF复用时钟</p>
<pre><code>    RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOA
                            |RCC_APB2Periph_GPIOB
                            |RCC_APB2Periph_GPIOC
                                                        |RCC_APB2Periph_GPIOD
                            |RCC_APB2Periph_AFIO,ENABLE //使能复用时钟
                            );
`&lt;/pre&gt;

其次要调用GPIO_PinRemapConfig函数禁止JTAG或SWD，例如下面GPIO_Remap_SWJ_JTAGDisable为使能SWD，禁用JTAG。

&lt;pre&gt;`          GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);
`&lt;/pre&gt;

GPIO_PinRemapConfig的第一个参数具体含义如下（注释括号里的东西很形像，哈哈）：

&lt;pre&gt;`#define GPIO_Remap_SWJ_NoJTRST     ((uint32_t)0x00300100)  /* Full SWJ Enabled (JTAG-DP + SW-DP) but without JTRST */
#define GPIO_Remap_SWJ_JTAGDisable ((uint32_t)0x00300200)  /* JTAG-DP Disabled and SW-DP Enabled */
#define GPIO_Remap_SWJ_Disable     ((uint32_t)0x00300400)  /* Full SWJ Disabled (JTAG-DP + SW-DP) */
`&lt;/pre&gt;

最后就是将JTAG中要复用的初始化成普通GPIO，具体取决于你的应用。

&lt;pre&gt;`  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 
                                                    |   GPIO_Pin_11     //WR
                                                | GPIO_Pin_12       //RS
                                                | GPIO_Pin_13       //cs
                                                | GPIO_Pin_14       //RD
                                                | GPIO_Pin_15       //RST
                                                ;

  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
  GPIO_Init(GPIOA, &amp;amp;GPIO_InitStructure);
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/MCU-ARM/">MCU/ARM</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-modelsim-e7-bc-96-e8-af-91-microsemiactel-fpga-e4-bb-bf-e7-9c-9f-e5-ba-93" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/31/modelsim-e7-bc-96-e8-af-91-microsemiactel-fpga-e4-bb-bf-e7-9c-9f-e5-ba-93/" class="article-date">
      <time datetime="2015-08-31T11:06:36.000Z" itemprop="datePublished">2015-08-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/31/modelsim-e7-bc-96-e8-af-91-microsemiactel-fpga-e4-bb-bf-e7-9c-9f-e5-ba-93/">modelsim 编译 microsemi(actel) FPGA 仿真库</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><a href="/uploads/2015/08/SmartFusion2-Block-Diagram.jpg"><img src="/uploads/2015/08/SmartFusion2-Block-Diagram-300x203.jpg" alt="SmartFusion2-Block-Diagram"></a></p>
<p>通常我不太喜欢用EDA工具自带的定制版modelsim AE,各种不好用且不说，万一遇到问题解决起来很麻烦，而且我也不想跟EDA工具绑定。在网上搜索了一番，原本以为还要额外下仿真库，后来记起来在安装libero soc时我点了安装smartfusion2（安装libero soc时一定要记得勾选上你所用器件）的仿真库，可问题是在哪里？</p>
<p>《Compiling SmartFusion Library for Modelsim Full Version (PE/SE/DE) Simulation》（半导体厂商的链接不是太稳定，随时有可能更改故不给出链接，要看原文自己GOOGLE即可，用BAIDU你可能会搜索不到，^_^）这篇文章解决了我的问题，</p>
<blockquote>
<p><libero_installation>\Designer\lib\modelsim\precompiled\vlog\src</libero_installation></p>
</blockquote>
<p>仿真所需的文件也都在这个目录了，我的在</p>
<p><code>C:\Microsemi\Libero_v11.5\Designer\lib\modelsim\precompiled\vlog\src</code> 目录。</p>
<p>顺带他也把编译过程写出来了，我这里当一下搬运工，当然你也可以用你自己喜爱的方式编译，像我通常会把这个仿真库文件直接放到我的SIM目录，这样工程打包时能把这些也一起打包上。</p>
<p>原文也是以smartfusion2为例，仿真总共需要以下四个文，包括smartfusion.v宏单元库，三个VHDL仿真所需要的包文件(是不是说使用verilog仿真只需要包含smartfusion.v？试一下就知道啦，^_^)：</p>
<p>Smartfusion.v - The macro cell library which is common for Vhdl and Verilog.</p>
<p>fixed_float_types_c.vhdl</p>
<p>fixed_pkg_c.vhdl</p>
<p>float_pkg_c.vhdl</p>
<p>其实我的Libero_v11.5\Designer\lib\modelsim\precompiled\vlog\src文件夹下是没有.vhdl文件的，不管了，反正我只需要用到smartfusion2.v就行。</p>
<p><a href="/uploads/2015/08/2015-08-31_095419.png"><img src="/uploads/2015/08/2015-08-31_095419-300x227.png" alt="2015-08-31_095419"></a></p>
<p>编译过程及命令如下：</p>
<p>在modelsim的安装目录下，创建一个新目录，命名为Actel，即路径为<modelsim_install_path>/Actel。</modelsim_install_path></p>
<ul>
<li>打开modelsim PE/SE/DE 仿真软件。</li>
<li><p>输入以下命令:</p>
<pre><code>*   `cd &amp;lt;ModelSim_Install_Path&amp;gt;/Actel (To change the working directory)` 改变modesim的工作目录
</code></pre><ul>
<li><code>vlib smartfusion (To create the smartfusion library at &amp;lt;ModelSim_Install_Path&amp;gt;/Actel/smartfusion)</code></li>
<li><code>vmap smartfusion &amp;lt;ModelSim_Install_Path&amp;gt;/Actel/smartfusion</code></li>
<li>vlog -work smartfusion “<libero_installation>/Designer/lib/modelsim/precompiled/vlog/src/smartfusion.v <libero_installation>/Designer/lib/modelsim/precompiled/vlog/src/fixed_float_types_c.vhdl”</libero_installation></libero_installation></li>
<li>vcom -work smartfusion “<libero_installation>/Designer/lib/modelsim/precompiled/vlog/src/float_pkg_c.vhdl”</libero_installation></li>
</ul>
</li>
</ul>
<p>至此可用于modelsim PE/SE/DE的库就整好了。<br>整个过程可以自己添加到.do文件中让其自动运行，例如我的.do文件就是把编译库和运行仿真及添加仿真信号放到了一块，在modelsim命令行输入一个sim.do即自动运行。</p>
<p><strong>sim.do文件</strong></p>
<pre><code>#如果目录中已经存在work文件夹，就不再新建库文件夹。
if {![file isdirectory work]} {
    vlib work 
}

#将逻辑库映射到实际库文件夹work下
vmap work work 

#编译文件，sim.f是文件列表，-incr是增量编译,避免编译未改动的文件。
vlog -incr -f sim.f -compile_uselibs ./actel/*.v  

#仿真，-novopt是禁止优化，不能使用modelsim的优化，会将testbench的信号优化掉。
vsim -novopt work.testbench

add wave sim:/testbench/*

#add wave sim:/testbench/uTftCtrlTop/tft_ctrl/*
# #删除原信号，*是通配符
# delete wave /*stateTftCur
# delete wave /*stateTftNxt

# #设置该信号以ASC方式显示
# add wave -ascii sim:/testbench/uTftCtrlTop/tft_ctrl/stateTftCur
# add wave -ascii sim:/testbench/uTftCtrlTop/tft_ctrl/stateTftNxt

# add wave -unsigned sim:/testbench/w_sdram_data

# ###############状态机参数名称转换#########################
# 使用ModelSim的virtual type命令定义一个新的枚举类型（FSM_TYPE）
# 注意：状态变量之间需要一个空格
#virtual type {{7'b0000001 WAITE_SDR_INIT} {7'b0000010 AUTO_REF_SDR} {7'b0000100 RD_SDR_TFT} {7'b0001000 NONE_OP_USR} {7'b0010000 NONE_OP_TFT} {7'b0100000 RD_SDR_USR} {7'b1000000 WR_SDR_USR}} FSM_TYPE

#virtual type {{4'd0 IDLE} {4'd1 START} {4'd2 W_COM} {4'd3 W_COM_ACK} {4'd4 W_ADDR} {4'd5 W_ADDR_ACK} {4'd6 A_START} {4'd7 R_COM} {4'd8 R_COM_ACK} {4'd9 R_DATA} {4'd10 R_DATA_ACK} {4'd11 STOP}} FSM_TYPE

# 将需要显示的信号（/testbench/fsm/state_cur，注意信号在wave窗口中的完整名字）进行类型转换，
#转换成一个新的信号state_curNew
#virtual function {(FSM_TYPE)/testbench/uTftCtrlTop/tft_ctrl/stateTftCur} stateTftCur_NEW
#同样处理state_next信号
#virtual function {(FSM_TYPE)/testbench/uTftCtrlTop/tft_ctrl/stateTftNxt} stateTftNxt_NEW

#将新信号加入wave窗口
# add wave /testbench/uTftCtrlTop/tft_ctrl/stateTftCur_NEW
# add wave /testbench/uTftCtrlTop/tft_ctrl/stateTftNxt_NEW

# #########################################################
# add wave sim:/testbench/uTftCtrlTop/tft_drv/clk
# add wave sim:/testbench/uTftCtrlTop/tft_drv/hs
# add wave sim:/testbench/uTftCtrlTop/tft_drv/vs
# add wave -unsigned sim:/testbench/uTftCtrlTop/tft_drv/hcnt
# add wave -unsigned sim:/testbench/uTftCtrlTop/tft_drv/data

#add wave sim:/testbench/uTftCtrlTop/u_Sdram_Control_3Port/read_side_fifo_tft_wusedw
#add wave sim:/testbench/uTftCtrlTop/u_Sdram_Control_3Port/read_side_fifo_tft_rusedw

run -all
#q
</code></pre><p><strong>其中sim.f文件里面列出了你自己要仿真的.v文件。</strong></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/FPGA/">FPGA</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-cpldfpga-e5-81-9a-e7-9a-84tft-e6-8e-a7-e5-88-b6-e5-99-a8verilog-e5-bc-80-e6-ba-90-e4-bb-a3-e7-a0-81" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/30/cpldfpga-e5-81-9a-e7-9a-84tft-e6-8e-a7-e5-88-b6-e5-99-a8verilog-e5-bc-80-e6-ba-90-e4-bb-a3-e7-a0-81/" class="article-date">
      <time datetime="2015-08-30T08:31:32.000Z" itemprop="datePublished">2015-08-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/30/cpldfpga-e5-81-9a-e7-9a-84tft-e6-8e-a7-e5-88-b6-e5-99-a8verilog-e5-bc-80-e6-ba-90-e4-bb-a3-e7-a0-81/">CPLD/FPGA做的TFT控制器verilog开源代码</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>三年以前的作品，CPLD/FPGA + SRAM的架构，代码稚嫩，设计也不规范，应该没什么利害关系了，发布出来给有需要的人。虽然是480&#42;234分辨率的代码，但是稍微改改对于800&#42;480以下中小尺寸分辨率的TFT液晶一样适用。</p>
<p><a href="/uploads/2015/08/TFT薄膜电晶体的结构.jpg"><img src="/uploads/2015/08/TFT薄膜电晶体的结构-300x197.jpg" alt="TFT薄膜电晶体的结构"></a></p>
<hr>
<p><strong>contrl_top.v，控制器顶层代码</strong></p>
<pre><code>// contrl_top.v
module contrl_top(clk,data_inout,Addr,nWE,nOE,
                    Sv,Sh,DE,odata,tftclk,
                    cdata_inout,ncSD,ncCE,ncWE,rst);

  input clk;

  inout [15:0] data_inout;
  output [17:0] Addr;
  output nWE;
  output nOE;
  //-----------------------------------------------------------
  output Sv;
  output Sh;
  output DE;
  output [15:0] odata;
  output tftclk;
   //------------------------------------------------------------
  inout [15:0] cdata_inout;
  input ncSD;
  input ncCE;
  input ncWE;
  input rst;
  //------------------------------------------------------------
  reg [17:0]ADD_WRITE=18&apos;h00000;
  reg [17:0]ADD_TFT=0;
  reg [1:0]tft_div=0;
  reg tftclk=0;
  reg [15:0]tft_data;  
  //-------------------------------------------------------------

  reg   [17:0] Addr;
  reg nWE,nOE;
  reg [15:0] regdata;
  wire [2:0]state;
  wire tft_readflag;
  wire ctrl_writeflag;

  wire ctrl_writecom;
   reg ctrl_writed;
  reg tft_read;

  //-----------------------------------------------------------------------

  wire ctrl_wq;
  wire tft_rq;
  reg ram_op;
  assign ctrl_wq=(ctrl_writeflag&amp;amp;(!(ctrl_writed|tft_rq))&amp;amp;(nOE))?1&apos;b1:1&apos;b0;

  assign tft_rq=((!(tft_read))&amp;amp;(tft_readflag)&amp;amp;(nWE))?1&apos;b1:1&apos;b0;

  assign state={ctrl_wq,tft_rq,ram_op}; 

   reg [7:0]conmmand_count;

   reg [8:0]xend;
   reg [8:0]yend;
   reg [8:0]xstr;
   reg [8:0]ystr;
//-----------------------------------------------------------------------
assign data_inout=(!nWE)?regdata:16&apos;hzzzz;
assign cdata_inout=16&apos;hzzzz;
assign ctrl_writeflag=(ncWE|ncCE)?1&apos;b0:1&apos;b1;
assign ctrl_writecom=(ncWE|ncCE|(ncSD))?1&apos;b0:1&apos;b1;
assign tft_readflag=((!tftclk)&amp;amp;DE)?1&apos;b1:1&apos;b0;

  TFTtimer tftt(
                .clk(tftclk),
                .Sv(Sv),
                .Sh(Sh),
                .DE(DE),
                .rset(rst),
                .data(tft_data),
                .odata(odata)//,
                );
  //------------------------------------------------------------

always@(posedge clk )
begin
    if(!rst)
        begin

            ADD_WRITE&amp;lt;=18&apos;h000000;
            xend&amp;lt;=479;
            yend&amp;lt;=233;
            xstr&amp;lt;=0;
            ystr&amp;lt;=0;

        end
    else 
    begin

    case (state)
    3&apos;b000://wait_state
        begin

            nWE&amp;lt;=1&apos;b1;
            nOE&amp;lt;=1&apos;b1;

        end
    3&apos;b100:
        begin
            nWE&amp;lt;=1&apos;b1;
            nOE&amp;lt;=1&apos;b1;
            Addr&amp;lt;=ADD_WRITE;
            ram_op&amp;lt;=1&apos;b1;

        end
    3&apos;b010:
        begin
            nWE&amp;lt;=1&apos;b1;
            nOE&amp;lt;=1&apos;b0;
            Addr&amp;lt;=ADD_TFT;

            ram_op&amp;lt;=1&apos;b1;

        end
    3&apos;b101:
        begin
            if(ctrl_writecom)
                begin
                    conmmand_count&amp;lt;=cdata_inout[7:0];

                end
            else if(conmmand_count&amp;lt;=8&apos;hC0)
            begin 
                if(conmmand_count==8&apos;h00)
                    begin
                        xstr[8]&amp;lt;=cdata_inout[0];
                    end
                else if(conmmand_count==8&apos;h01)
                    begin
                        xstr[7:0]&amp;lt;=cdata_inout[7:0];
                    end
                else if(conmmand_count==8&apos;h02)
                    begin
                        xend[8]&amp;lt;=cdata_inout[0];
                        ADD_WRITE[8:0]&amp;lt;=xstr;
                    end
                else if(conmmand_count==8&apos;h03)
                    begin
                        xend[7:0]&amp;lt;=cdata_inout[7:0];
                    end
                else if(conmmand_count==8&apos;h04)
                    begin
                        ystr[8]&amp;lt;=cdata_inout[0];
                    end
                else if(conmmand_count==8&apos;h05)
                    begin
                        ystr[7:0]&amp;lt;=cdata_inout[7:0];
                    end
                else if(conmmand_count==8&apos;h06)
                    begin
                        yend[8]&amp;lt;=cdata_inout[0];
                        ADD_WRITE[17:9]&amp;lt;=ystr;
                    end
                else if(conmmand_count==8&apos;h07)
                    begin
                        yend[7:0]&amp;lt;=cdata_inout[7:0];
                    end
                else if(conmmand_count==8&apos;h0A)
                    begin
                        ADD_WRITE[17:16]&amp;lt;=cdata_inout[1:0];
                    end
                else if(conmmand_count==8&apos;h0B)
                    begin
                        ADD_WRITE[15:8]&amp;lt;=cdata_inout[7:0];
                    end
                else if(conmmand_count==8&apos;h0C)
                    begin
                        ADD_WRITE[7:0]&amp;lt;=cdata_inout[7:0];
                    end

                if(conmmand_count&amp;lt;8&apos;h80) conmmand_count&amp;lt;=conmmand_count+1&apos;b1;

            end
            else if(conmmand_count==8&apos;hC1)
                begin

                        begin

                            Addr&amp;lt;=ADD_WRITE;

                            regdata&amp;lt;=cdata_inout;
                            nWE&amp;lt;=1&apos;b0;
                            nOE&amp;lt;=1&apos;b1;

                            if(ADD_WRITE[8:0]&amp;gt;=xend)
                            begin
                                ADD_WRITE[8:0]&amp;lt;=xstr;
                                if(ADD_WRITE[17:9]&amp;gt;=yend)
                                    begin
                                        ADD_WRITE[17:9]&amp;lt;=ystr;
                                    end
                                else
                                    begin
                                        ADD_WRITE[17:9]&amp;lt;=ADD_WRITE[17:9]+1&apos;b1;
                                    end

                            end
                            else
                                begin
                                    ADD_WRITE[8:0]&amp;lt;=ADD_WRITE[8:0]+1&apos;b1;
                                end
                        end 
              end
            ram_op&amp;lt;=1&apos;b0;
            ctrl_writed&amp;lt;=1&apos;b1;
        end
    3&apos;b011:
        begin

            nWE&amp;lt;=1&apos;b1;
            nOE&amp;lt;=1&apos;b1;
            tft_data&amp;lt;=data_inout;

            tft_read&amp;lt;=1&apos;b1;
            ram_op&amp;lt;=1&apos;b0;

        end                                     
    3&apos;b001:
        begin
            ram_op&amp;lt;=1&apos;b0;
            nWE&amp;lt;=1&apos;b1;
            nOE&amp;lt;=1&apos;b1;
        end 
    3&apos;b110:
        begin
            nWE&amp;lt;=1&apos;b1;
            nOE&amp;lt;=1&apos;b0;
            Addr&amp;lt;=ADD_TFT;

            ram_op&amp;lt;=1&apos;b1;

        end 
    3&apos;b111:
        begin

            nWE&amp;lt;=1&apos;b1;
            nOE&amp;lt;=1&apos;b0;
            tft_data&amp;lt;=data_inout;

            tft_read&amp;lt;=1&apos;b1;
            ram_op&amp;lt;=1&apos;b0;

        end 
    default:
        begin
            ram_op&amp;lt;=1&apos;b0;
            nWE&amp;lt;=1&apos;b1;
            nOE&amp;lt;=1&apos;b1;
        end         
    endcase

    if(!tft_readflag) tft_read&amp;lt;=1&apos;b0;
    if(!(ctrl_writeflag)) ctrl_writed&amp;lt;=1&apos;b0;
    end
end  

always @(posedge tftclk)
begin
    if(DE==1&apos;b1)
        begin
            ADD_TFT[8:0]&amp;lt;=ADD_TFT[8:0]+1&apos;b1;//ADD_TFT[8:0]+1&apos;b1;

        end

    else  if(Sh==1&apos;b0)
        begin
            ADD_TFT[8:0]&amp;lt;=0;
        end

end

always @(negedge Sv or negedge DE)
begin
    if(Sv==1&apos;b0)//(DE)
        begin
            ADD_TFT[17:9]&amp;lt;=0;
        end
    else if(!DE)
        begin
            ADD_TFT[17:9]&amp;lt;=ADD_TFT[17:9]+1&apos;b1;//ADD_TFT[17:9]+1&apos;b1;
        end

end

always @(posedge  clk )              
begin      

    if(!rst)
        begin
           tft_div&amp;lt;=2&apos;b00;
           tftclk&amp;lt;=1&apos;b0;
        end
    else if(tft_div==2&apos;b01)
            begin
                tftclk&amp;lt;=~tftclk;
                tft_div&amp;lt;=2&apos;b00;
            end
        else 
            begin
                tft_div&amp;lt;=tft_div+1&apos;b1;
            end

end

endmodule

`&lt;/pre&gt;

**TFTtimer.v，TFT时序模块代码**

&lt;pre&gt;`
// TFTtimer.v
module TFTtimer(clk,Sv,Sh,DE,data,odata,rset);//
    input clk,rset;
    output [15:0] odata;
    input [15:0] data;
    output Sv,Sh,DE;
    //;
/////////////////////////////////////////////////////////////////////////////////////////////////////////// 
    reg [9:0]J1=0;                  
    reg [8:0]J2=0;                   
    reg Sh=1;                      
    reg Sv=1;                      
    reg DE=0;   
    wire [15:0] odata;
    reg hDE=0;

assign odata=(DE)?data:16&apos;hzzzz;

always @(negedge  clk )  
 begin
    if(!rset) J1=1;
    else
    if(J1 == 399) 
         begin
           J1=1; 
           Sh=0;

          end 
    else J1=J1+1;

    if(J1==6)
        begin
          Sh=1;
        end
    else if(J1==59) 
       begin
           if(hDE)
               begin
                   DE=1;

               end
      end  

     else if(J1==378)
          begin

             DE=0;
          end   

end 

/////////////////////////////////////////////////////////////////////////////////////////////////////////// 

always @(negedge  Sh )   
 begin
   if(!rset) J2=0;
   else
   if(J2==262)
     begin
        J2=1;
        hDE=0;
        Sv=0;
     end
    else J2=J2+1;

   if(J2==4)
     begin
        Sv=1;
     end
  else if(J2==20)
      begin
        hDE=1;
      end   
  else if(J2==253)
     begin
        hDE=0;
     end
 end        

////////////////////////////////////////////////////////////////////////////////////////////////////////////

endmodule 
</code></pre><hr>
<p>工程是基于micromesim即actel的AP030 FPGA的，所以工程文件是libero的格式，如有需要的请自行<strong>下载<a href="/uploads/2015/08/480234070M2.rar">480234070M2</a></strong>。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/FPGA/">FPGA</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e9-ab-98-e9-80-9f-e7-ba-bf-e9-98-b5ccd-e7-ba-a2-e5-a4-96-e6-b5-8b-e5-be-84-e4-bb-aa-e9-80-9a-e4-bf-a1-e8-b0-83-e8-af-95-e9-80-9a-e8-bf-87" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/29/e9-ab-98-e9-80-9f-e7-ba-bf-e9-98-b5ccd-e7-ba-a2-e5-a4-96-e6-b5-8b-e5-be-84-e4-bb-aa-e9-80-9a-e4-bf-a1-e8-b0-83-e8-af-95-e9-80-9a-e8-bf-87/" class="article-date">
      <time datetime="2015-08-29T13:41:20.000Z" itemprop="datePublished">2015-08-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/29/e9-ab-98-e9-80-9f-e7-ba-bf-e9-98-b5ccd-e7-ba-a2-e5-a4-96-e6-b5-8b-e5-be-84-e4-bb-aa-e9-80-9a-e4-bf-a1-e8-b0-83-e8-af-95-e9-80-9a-e8-bf-87/">高速线阵CCD红外测径仪通信调试通过</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong>金同学看到的话，替我保密，哈哈。</strong></p>
<p>FPGA和MCU通信完成，发两张图纪念，明天调调CCD的AD数据是否正常。有点郁闷的是，不知道是我的FPGA固件不稳写，还是板子布线有问题，FMC驱动TFT这一块纯色还可以，数据线一跳变屏就玩完了。</p>
<p><a href="/uploads/2015/08/2015-08-29-21.36.20.jpg"><img src="/uploads/2015/08/2015-08-29-21.36.20-300x225.jpg" alt="2015-08-29 21.36.20"></a></p>
<p><a href="/uploads/2015/08/2015-08-29-21.36.08.jpg"><img src="/uploads/2015/08/2015-08-29-21.36.08-300x225.jpg" alt="2015-08-29 21.36.08"></a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/FPGA/">FPGA</a>
    </div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2016 shawge
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/luuman/hexo-theme-spfk" target="_blank">spfk</a> by luuman
            </div>
        </div>
        
    </div>
</footer>

    </div>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>