<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hex55</title>
  <subtitle>shawge的电子技术分享</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hex55.com/"/>
  <updated>2016-07-30T02:22:17.630Z</updated>
  <id>http://hex55.com/</id>
  
  <author>
    <name>shawge</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git push到github提速解决办法</title>
    <link href="http://hex55.com/2016/07/29/git-push%E5%88%B0github%E6%8F%90%E9%80%9F%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://hex55.com/2016/07/29/git-push到github提速解决办法/</id>
    <published>2016-07-29T03:01:08.000Z</published>
    <updated>2016-07-30T02:22:17.630Z</updated>
    
    <content type="html"><![CDATA[<p>github的提交速度只有区区十几K，这太他妈的不合理了，原因当然只有一个，那就是XX墙。然后网上一通胡乱搜索，发现一堆所谓的解决办法，统统无用，也许只是对我无用，大伙就不要再在下面这些法子上白费力气了,我写在这里也只是作一下记录以备日后类似问题参考。</p>
<pre><code>修改 /etc/ssh_config 中的这一项，去掉#
GSSAPIAuthentication no

作用两个说法：
服务器端启用了GSSAPI。登陆的时候客户端需要对服务器端的IP地址进行反解析，如果服务器的IP地址没有配置PTR记录，那么就容易在这里卡住了。
是否允许使用基于 GSSAPI 的用户认证。默认值为&quot;no&quot;。仅用于SSH-2。
</code></pre><p>上面这种我觉得说的不是没有道理，但是没有效果。</p>
<pre><code>修改ssh配置
按照下面的内容修改这个文件vim ~/.ssh/config
ControlMaster auto
##ControlPath /tmp/%r@%h:%p
ControlPath /tmp/git@github.com:22
ControlPersist yes
一些注解
ControlMaster auto可以使多个ssh会话共享一个已经存在的连接,如果没有,则自动创建一个连接。
ControlPath /tmp/%r@%h:%p可以指定想要共享的连接。%r代表远程登录用户名,一般都为git,%h表示目标主机,%p表示端口。
ControlPersist yes 则可以让共享的连接持有处于连接状态。

常用的ControlPath
下面包含开源中国,github,gitcafe等代码托管。
ControlPath /tmp/git@git.oschina.net:22
ControlPath /tmp/git@github.com:22
ControlPath /tmp/git@gitcafe.com:22
快来试一试吧,是不是提高了5倍!
</code></pre><p>上面这种我也试了，然并卵，特别是其中提到添加国内源这个办法我真是不懂。</p>
<p><img src="/uploads/2016/07/解决Github访问超慢问题-zrong-s-blog.png" alt="Github提速"></p>
<p>上面这种办法一样的是然并卵，而且很麻烦，难道每次我都得去找一下到底是哪个DNS被污染了？GFW的策略可是经常变啊。</p>
<p><img src="/uploads/2016/07/GitHub加速访问.png" alt="Github加速"></p>
<p>这个办法跟上面那个DNS被污一样，都是要修改HOSTS文件，非常非常的不方便，GITHUB的IP地址如果变动，或者GFW变动都得重新去修改HOSTS，如果哪天发现有问题了，谁还记得之前改过HOSTS。</p>
<p>无奈啊，只能用代理，但是我的VPS是阿里云的，妈的完全不能拿来做VPN，我靠。于是想到了lantern，这个免费的工具。<br>结果一试喜出望外，一下子300多K了，真是爽，有图为证。</p>
<p><img src="/uploads/2016/07/2016-07-24-09-43-04屏幕截图.png" alt=""></p>
<p>方法如下：</p>
<p>打开浏览器，地址栏输入<a href="http://127.0.0.1:16823/proxy_on.pac可以得到lantern的PAC文件，在该文件中找到如下一行" target="_blank" rel="external">http://127.0.0.1:16823/proxy_on.pac可以得到lantern的PAC文件，在该文件中找到如下一行</a></p>
<pre><code>return “PROXY 127.0.0.1:8787; DIRECT”;
</code></pre><p>如上可以看到代理地址及端口是127.0.0.1:8787。</p>
<p>然后在SHELL中输出下面内容以设置git的代理。</p>
<pre><code>export http_proxy=http://127.0.0.1:8787
export https_proxy=$http_proxy
git config --global http.proxy $http_proxy
git config --global https.proxy $https_proxy
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;github的提交速度只有区区十几K，这太他妈的不合理了，原因当然只有一个，那就是XX墙。然后网上一通胡乱搜索，发现一堆所谓的解决办法，统统无用，也许只是对我无用，大伙就不要再在下面这些法子上白费力气了,我写在这里也只是作一下记录以备日后类似问题参考。&lt;/p&gt;
&lt;pre&gt;&lt;
    
    </summary>
    
      <category term="windows-linux" scheme="http://hex55.com/categories/windows-linux/"/>
    
    
      <category term="github 提速" scheme="http://hex55.com/tags/github-%E6%8F%90%E9%80%9F/"/>
    
  </entry>
  
  <entry>
    <title>解决python 打包 No module named &#39;XXX&#39;</title>
    <link href="http://hex55.com/2016/07/09/e8-a7-a3-e5-86-b3python-e6-89-93-e5-8c-85-no-module-named-xxx/"/>
    <id>http://hex55.com/2016/07/09/e8-a7-a3-e5-86-b3python-e6-89-93-e5-8c-85-no-module-named-xxx/</id>
    <published>2016-07-09T01:34:42.000Z</published>
    <updated>2016-07-20T00:10:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/uploads/2016/07/u39601116451072010492fm21gp0.jpg"><img src="/uploads/2016/07/u39601116451072010492fm21gp0-300x188.jpg" alt="u=3960111645,1072010492&amp;fm=21&amp;gp=0"></a></p>
<blockquote>
<p>No module named ‘math’<br>  No module named ‘_struct’</p>
</blockquote>
<p>打包好的python运行时出现下面这些错误，折腾半天，愣是没找到math.py，后来才搞清楚PYTHON默认是将这些库编译成了动态库，在PYTHON的LIB目录的lib-dynloads下，但是将LIB压缩成ZIP后就办法找到这个路径了，所以只能想办法编译成静态的，即将lib-dynloads中的<em>math</em>.dll静态编译进pythonXX.dll中，方法很简单:<br>把源码中Setup.dist文件里的这一行的注释去掉：</p>
<blockquote>
<p>math mathmodule.c _math.c # -lm # math library functions, e.g. sin()</p>
</blockquote>
<p>你还可以在configure时指定你要链接的特定版本的math库</p>
<blockquote>
<p>–with-libm=”xx/lib/libm.a”</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/uploads/2016/07/u39601116451072010492fm21gp0.jpg&quot;&gt;&lt;img src=&quot;/uploads/2016/07/u39601116451072010492fm21gp0-300x188.jpg&quot; alt=&quot;u=3
    
    </summary>
    
      <category term="windows-linux" scheme="http://hex55.com/categories/windows-linux/"/>
    
    
  </entry>
  
  <entry>
    <title>c/c++内嵌python打包发布</title>
    <link href="http://hex55.com/2016/07/08/cc-e5-86-85-e5-b5-8cpython-e6-89-93-e5-8c-85-e5-8f-91-e5-b8-83/"/>
    <id>http://hex55.com/2016/07/08/cc-e5-86-85-e5-b5-8cpython-e6-89-93-e5-8c-85-e5-8f-91-e5-b8-83/</id>
    <published>2016-07-07T22:52:19.000Z</published>
    <updated>2016-07-30T02:22:12.379Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/uploads/2016/07/C内嵌PYTHON打包发布.jpg"><img src="/uploads/2016/07/C内嵌PYTHON打包发布-300x140.jpg" alt="C内嵌PYTHON打包发布"></a></p>
<p>1.首先在pythonX.X的lib<strong><em>目录内</em></strong>（注意）全部选中文件，压缩成<strong><em>pythonXX.zip</em></strong>(注意是zip文件，不是RAR)。<br>2.将pythonX.X.dll和pythonXX.zip复制到C/C++生成的EXE所在目录。<br>3.在Py_Initialize()前，调用Py_SetPath(L”pythonXX.zip”);</p>
<p><strong><em>为了减小pythonXX.zip的体积，可以删除里面一些不必要的库目录</em></strong>。<br>PS:后面我发现pythonXX.zip可以直接在python官网下载命名类似“Windows x86 embeddable zip file”的压缩包，将其解压获得相应的pythonXX.zip。注意版本匹配。</p>
<p>如果程序运行时显示如下错误，说明你的pythonXX.dll不带ZLIB，需要重新编译。</p>
<blockquote>
<p>Py_Initialize …. zipimport.ZipImportError: can’t decompress data; zlib not available</p>
</blockquote>
<p>重新编译带ZLIB功能的pythonXX.dll方法如下：</p>
<p>1.在configure时加入–with-zlib=”/lib”, /lib是zlib所在目录。<strong><em>可能因为版本与网上查到的不同，我这一版不需要加这一项</em></strong><br>2.在Setup.dist文件中取消这一行的注释：</p>
<blockquote>
<p>zlib zlibmodule.c -I$(prefix)/include -L$(exec_prefix)/lib -lz</p>
</blockquote>
<p>修改完成后重新编译安装。注意如果是用的MAKEPKG工具，要加入-e -f参数，以避免MAKEPKG重新解压源码覆盖我们修改过的Setup.dist。</p>
<p>如果很不幸，你的库里面没有zlib的开发库，如.a等，那么你还得先编译或者安装ZLIB<br>从这一行上面的注释也可以看出该python版本要求的ZLIB版本，该ZLIB版本一般是1.28.从注释中提供的ZLIB官方下载相关的ZLIB源码然行进行编译，安装。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/uploads/2016/07/C内嵌PYTHON打包发布.jpg&quot;&gt;&lt;img src=&quot;/uploads/2016/07/C内嵌PYTHON打包发布-300x140.jpg&quot; alt=&quot;C内嵌PYTHON打包发布&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1.首先在p
    
    </summary>
    
      <category term="windows-linux" scheme="http://hex55.com/categories/windows-linux/"/>
    
    
  </entry>
  
  <entry>
    <title>解决failed-to-load-platform-plugin-windows</title>
    <link href="http://hex55.com/2016/07/06/e8-a7-a3-e5-86-b3failed-to-load-platform-plugin-windows/"/>
    <id>http://hex55.com/2016/07/06/e8-a7-a3-e5-86-b3failed-to-load-platform-plugin-windows/</id>
    <published>2016-07-06T02:29:56.000Z</published>
    <updated>2016-07-23T08:15:05.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/uploads/2016/07/2016-07-06_080706.png"><img src="/uploads/2016/07/2016-07-06_080706-300x146.png" alt="2016-07-06_080706"></a></p>
<p>对于<strong><em>动态链接</em></strong>QT，方法很简单，把安装目录下plugins里的platforms目录（删掉里面你没有用到的插件）拷贝到exe所在的目录就可以了。</p>
<p>或者搞个环境变量</p>
<blockquote>
<p>QT_QPA_PLATFORM_PLUGIN_PATH=<qt_base>\plugins\platforms<br>  例如<br>  QT_QPA_PLATFORM_PLUGIN_PATH=f:\Qt\5\5.4\msvc2013_opengl\plugins\platforms</qt_base></p>
</blockquote>
<p>当然也有朋友发现这样在命令行模式时会有问题，于是他给出了一个终极解决方案（未验证）<br><a href="http://blog.csdn.net/vbvcde/article/details/40181545" target="_blank" rel="external">QT5 Failed to load platform plugin “windows”</a></p>
<pre><code>Failed to load platform plugin &quot;windows&quot; 
 这个错误在双击exe执行时不会出现，当传递命令行参数时出问题 ，解决方法：

int main(int argc, char *argv[])

{
    Q_INIT_RESOURCE(rc);
//解决库路径问题============info@seatrix.com
    QTextCodec *xcodec = QTextCodec::codecForLocale() ;
    QString exeDir = xcodec-&amp;gt;toUnicode( QByteArray(argv[0]) ) ;
    QString BKE_CURRENT_DIR = QFileInfo(exeDir).path() ;
    QStringList  libpath;
    libpath &amp;lt;&amp;lt; BKE_CURRENT_DIR+QString::fromLocal8Bit(&quot;/plugins/platforms&quot;);
    libpath &amp;lt;&amp;lt; BKE_CURRENT_DIR &amp;lt;&amp;lt;BKE_CURRENT_DIR+QString::fromLocal8Bit(&quot;/plugins/imageformats&quot;);
    libpath &amp;lt;&amp;lt; BKE_CURRENT_DIR+QString::fromLocal8Bit(&quot;/plugins&quot;);
    libpath &amp;lt;&amp;lt; QApplication::libraryPaths();
    QApplication::setLibraryPaths(libpath) ;
//=========================
    QApplication a(argc, argv);
    MainWindow w;
    w.show();
    return a.exec();
}
</code></pre><p>对于<strong><em>静态链接</em></strong>，那么就只有stackoverflow中有个网友给出了解决方案（原谅我是个QT初学者），</p>
<pre><code>&lt;pre&gt;`
I solved it. Thanks to this I was able to get everything to work. I added the following libraries:

opengl32.lib
Qt5PlatformSupport.lib
qwindows.lib
I also added the following to my code:

#include &amp;lt;QtPlugin&amp;gt;
Q_IMPORT_PLUGIN (QWindowsIntegrationPlugin);

`&lt;/pre&gt;
</code></pre><p>从上面看作者用的是visual studio，跟我的MINGW CMAKE的解决办法肯定不要样。但无疑给出了思路：先在源码中经引用插件，然后在链接时链接相应的库。<br>在CMAKE中如下做即可：<br>    1. 在源码中添加</p>
<pre><code>&lt;pre&gt;`#include &amp;lt;QtPlugin&amp;gt;
Q_IMPORT_PLUGIN (QWindowsIntegrationPlugin);
</code></pre><p>2.在CMAKE中文中引用Qt5::QWindowsIntegrationPlugin这个target即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/uploads/2016/07/2016-07-06_080706.png&quot;&gt;&lt;img src=&quot;/uploads/2016/07/2016-07-06_080706-300x146.png&quot; alt=&quot;2016-07-06_080706&quot;&gt;&lt;/a&gt;&lt;/
    
    </summary>
    
      <category term="windows-linux" scheme="http://hex55.com/categories/windows-linux/"/>
    
    
  </entry>
  
  <entry>
    <title>解决Fatal Python error: Py_Initialize: can&#39;t initialize sys standard streams</title>
    <link href="http://hex55.com/2016/07/04/e8-a7-a3-e5-86-b3fatal-python-error-py-initialize-cant-initialize-sys-standard-streams/"/>
    <id>http://hex55.com/2016/07/04/e8-a7-a3-e5-86-b3fatal-python-error-py-initialize-cant-initialize-sys-standard-streams/</id>
    <published>2016-07-04T09:08:00.000Z</published>
    <updated>2016-07-30T02:22:06.339Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Fatal Python error: Py_Initialize: can’t initialize sys standard streams LookupError: unknown encoding: cp936</p>
</blockquote>
<p>这个错误有两种解决办法：<br>1.有源码的情况下在Py_Initialize前设置path路径。</p>
<pre><code>#ifdef _WIN32
    Py_SetPath(L&quot;python35;python35/lib-dynload&quot;);
#else
    Py_SetPath(L&quot;python35:python35/lib-dynload&quot;);
#endif
</code></pre><p>2.没有源码的情况下更改系统的非UNICODE语言为英语</p>
<p><a href="/uploads/2016/07/2016-07-04_170640.png"><img src="/uploads/2016/07/2016-07-04_170640-300x147.png" alt="2016-07-04_170640"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Fatal Python error: Py_Initialize: can’t initialize sys standard streams LookupError: unknown encoding: cp936&lt;/p&gt;
&lt;/blockquo
    
    </summary>
    
      <category term="windows-linux" scheme="http://hex55.com/categories/windows-linux/"/>
    
    
  </entry>
  
  <entry>
    <title>逻辑分析仪前端电路</title>
    <link href="http://hex55.com/2016/04/01/e9-80-bb-e8-be-91-e5-88-86-e6-9e-90-e4-bb-aa-e5-89-8d-e7-ab-af-e7-94-b5-e8-b7-af/"/>
    <id>http://hex55.com/2016/04/01/e9-80-bb-e8-be-91-e5-88-86-e6-9e-90-e4-bb-aa-e5-89-8d-e7-ab-af-e7-94-b5-e8-b7-af/</id>
    <published>2016-04-01T09:24:18.000Z</published>
    <updated>2016-07-19T00:29:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/uploads/2016/03/IMG_20160331_194144.jpg"><img src="/uploads/2016/03/IMG_20160331_194144.jpg" alt="IMG_20160331_194144"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/uploads/2016/03/IMG_20160331_194144.jpg&quot;&gt;&lt;img src=&quot;/uploads/2016/03/IMG_20160331_194144.jpg&quot; alt=&quot;IMG_20160331_194144&quot;&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="硬件设计" scheme="http://hex55.com/categories/%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>菊花公司面试记录</title>
    <link href="http://hex55.com/2016/03/14/e8-8f-8a-e8-8a-b1-e5-85-ac-e5-8f-b8-e9-9d-a2-e8-af-95-e8-ae-b0-e5-bd-95/"/>
    <id>http://hex55.com/2016/03/14/e8-8f-8a-e8-8a-b1-e5-85-ac-e5-8f-b8-e9-9d-a2-e8-af-95-e8-ae-b0-e5-bd-95/</id>
    <published>2016-03-14T00:49:59.000Z</published>
    <updated>2016-07-19T00:29:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>周六去菊花公司面试了，技术面感觉还蛮好，个别题有问题技术面的面试官还跟我一一探讨，海天阔地地侃技术，从C语言笔试题、ARM、C++侃到FPGA，双核处理器数据交互。末了，问我对加班怎么看？我靠，直话直说：“做技术的哪个不加班？”然后面试官就笑了。临起身走前他让我也推荐两个兄弟，我就随手写了一个大学同学的电话。然后中午用菊花公司的餐票吃了个免费午餐，菊花公司的食堂是直接外包给外面的餐饮公司，随便一个荤菜10块，感觉比我司食堂贵多了，哈哈。中午休息了一会，下午就HR面试了，本来还以为问题不大，当被问到自我介绍、职业规划，个人优缺点，我为什么要聘你时，我完全膈屁了，好久不面试，真是对不上这些问话，只觉无聊，于是草草应了两句，最后被HR以没有行业背景匹配度不高为由给KILL掉了，传说中变态的性格测试也没进行，真是丢面，实在对不起推荐我的那位仁兄，不过说实话到面试结束我都不知道是菊花公司哪个兄弟推荐我的，推荐人上面我空着啥也没写。只知道是我以前公司的兄弟推荐的，既然没面试过也就不打电话问是哪个朋友帮的忙了。</p>
<p>中午休息闲谈遇到一个港大的博士，一开始不知道他是面试什么岗，只是过去聊聊天，我说哥们面试进行到哪一步了，他一开口问我是博士还是硕士？我去，我一普通小本科。然后得知他是面试实验室的研究岗而不是开发岗，后面问他做哪个方向的研究，结果他说就是一个预研性的，估计人家也觉得就算跟我说了我也搞不清楚。最后的最好，我说明白了，你是专门做研究不管具体应用的。他说，博士不就是干这个的嘛！眼看他的面试官走过来了，我就知趣撤了。</p>
<p><strong>图文无关，好多年前的冷笑话</strong><br><a href="/uploads/2016/03/671065240702861279.jpg"><img src="/uploads/2016/03/671065240702861279-300x200.jpg" alt="671065240702861279"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周六去菊花公司面试了，技术面感觉还蛮好，个别题有问题技术面的面试官还跟我一一探讨，海天阔地地侃技术，从C语言笔试题、ARM、C++侃到FPGA，双核处理器数据交互。末了，问我对加班怎么看？我靠，直话直说：“做技术的哪个不加班？”然后面试官就笑了。临起身走前他让我也推荐两个兄
    
    </summary>
    
      <category term="闲言碎语" scheme="http://hex55.com/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>FPGA 与 CPU 数据交互的漫画广告</title>
    <link href="http://hex55.com/2016/02/24/fpga-e4-b8-8e-cpu-e6-95-b0-e6-8d-ae-e4-ba-a4-e4-ba-92-e7-9a-84-e6-bc-ab-e7-94-bb-e5-b9-bf-e5-91-8a/"/>
    <id>http://hex55.com/2016/02/24/fpga-e4-b8-8e-cpu-e6-95-b0-e6-8d-ae-e4-ba-a4-e4-ba-92-e7-9a-84-e6-bc-ab-e7-94-bb-e5-b9-bf-e5-91-8a/</id>
    <published>2016-02-24T03:18:29.000Z</published>
    <updated>2016-07-19T00:29:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>FPGA与CPU之间进行数据交互，尤其是高速交互通常实现起来比较麻烦，而FPGA工程师跟CPU软件工程师的思路完全不在一个频道，简直就是鸡同鸭讲，然后老外整个了个IP来简化这个玩意，而且用漫画做了个广告，我想说的并不是这个IP，而是这个漫话吸引了我，看到最后我才发现是个广告。</p>
<p><img src="/uploads/2016/02/FPGA_XXOO_CPU.jpg" alt="fpga_xxoo_cpu"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;FPGA与CPU之间进行数据交互，尤其是高速交互通常实现起来比较麻烦，而FPGA工程师跟CPU软件工程师的思路完全不在一个频道，简直就是鸡同鸭讲，然后老外整个了个IP来简化这个玩意，而且用漫画做了个广告，我想说的并不是这个IP，而是这个漫话吸引了我，看到最后我才发现是个广告
    
    </summary>
    
      <category term="FPGA" scheme="http://hex55.com/categories/FPGA/"/>
    
    
  </entry>
  
  <entry>
    <title>Altium designer  ADC多通道设计</title>
    <link href="http://hex55.com/2016/02/23/altium-designer-adc-e5-a4-9a-e9-80-9a-e9-81-93-e8-ae-be-e8-ae-a1/"/>
    <id>http://hex55.com/2016/02/23/altium-designer-adc-e5-a4-9a-e9-80-9a-e9-81-93-e8-ae-be-e8-ae-a1/</id>
    <published>2016-02-23T01:50:20.000Z</published>
    <updated>2016-07-19T00:29:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>网上最常见的Altium designer多通道设计都是针对单个输出或者输入信号进行复用，并没有针对像DAC这种有总线信号输出的例子。我现在有个案子要用4个ADC，每个ADC输出8bit信号，这个该怎么搞？</p>
<p>我自然而然地在单个ADC这子模块图里面放置总线，</p>
<p><a href="/uploads/2016/02/altium-designer-ADC多通道设计2.png"><img src="/uploads/2016/02/altium-designer-ADC多通道设计2-300x175.png" alt="altium designer ADC多通道设计2"></a></p>
<p>然后再用repeat方法在母图里调用4次该模块。</p>
<p><a href="/uploads/2016/02/altium-designer-ADC多通道设计.png"><img src="/uploads/2016/02/altium-designer-ADC多通道设计-300x148.png" alt="altium designer ADC多通道设计"></a></p>
<p>结果当然就是不行咯，你看还没编译在母子的模块信号脚 repeat(DATA[0..7])就标出错误了，然后我就各种尝试啊搜索啊，无果而终。无奈Altium designer是不支持的总线二级分组的，当然也许所有的PCB软件都不支持。</p>
<p>只能用下面这种苦逼的办法来解决。</p>
<p>首先在子图中中DATA[0..7]分别引出端口为DATA0,…DATA7，</p>
<p><a href="/uploads/2016/02/altium-designer-ADC多通道设计3.png"><img src="/uploads/2016/02/altium-designer-ADC多通道设计3-300x216.png" alt="altium designer ADC多通道设计3"></a></p>
<p>然后再在母图中对这7个端口分别复用4次，最后通过线序重建为总线D[0..31]，这里进FPGA的话就无所谓了，不需要重建线序。因为从DATA总线向D总线线序调整的过程中，一根导线有多个标号Altium Designer会报警的，为了让这个ADC子板跟母板的网络标号一至我直接忽略了这个警告。</p>
<p><a href="/uploads/2016/02/altium-designer-ADC多通道设计4.png"><img src="/uploads/2016/02/altium-designer-ADC多通道设计4-300x122.png" alt="altium designer ADC多通道设计4"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网上最常见的Altium designer多通道设计都是针对单个输出或者输入信号进行复用，并没有针对像DAC这种有总线信号输出的例子。我现在有个案子要用4个ADC，每个ADC输出8bit信号，这个该怎么搞？&lt;/p&gt;
&lt;p&gt;我自然而然地在单个ADC这子模块图里面放置总线，&lt;/
    
    </summary>
    
      <category term="硬件设计" scheme="http://hex55.com/categories/%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>Altium Designer 将PCB丝印标号反标至原理图</title>
    <link href="http://hex55.com/2016/02/22/altium-designer-e5-b0-86pcb-e4-b8-9d-e5-8d-b0-e6-a0-87-e5-8f-b7-e5-8f-8d-e6-a0-87-e8-87-b3-e5-8e-9f-e7-90-86-e5-9b-be/"/>
    <id>http://hex55.com/2016/02/22/altium-designer-e5-b0-86pcb-e4-b8-9d-e5-8d-b0-e6-a0-87-e5-8f-b7-e5-8f-8d-e6-a0-87-e8-87-b3-e5-8e-9f-e7-90-86-e5-9b-be/</id>
    <published>2016-02-22T14:18:46.000Z</published>
    <updated>2016-07-19T00:29:49.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/uploads/2016/02/Back-Annotate.jpg"><img src="/uploads/2016/02/Back-Annotate-300x169.jpg" alt="Back Annotate"></a></p>
<p>通常我们在原理图中采用auto annotate自动对原理图中的器件进行标号，但是这似乎没什么实际意义，往往标号在PCB中更有意义，比如方便排料，那么最好的做法是在PCB完成布局后，对PCB中的元件进行重新标号，然后再导入到原理图中对原理图中的元器件进行反标。</p>
<p>操作步骤如下：</p>
<ul>
<li>在PCB中对元器件进行重新编号以后，即PCB中选择Tool -&gt; Re-annotate,选择编号路径后，保存文件；系统自动生成一个后缀为WAS的文件；</li>
<li>打开SCH文件，选择Tool -&gt; Annotate Schematics -&gt; Back Annotate，在弹出的对话框中选择，PCB生成的.WAS文件；选择Accept Change( Create ECO )，则原理图中元件标号更新成功；<br>此时原理图文件中，元件标号有两个，一个是普通的元件标号，它是更新后的标号，另一个是置于括弧中的灰色标号，它是更新前的标号；</li>
<li>选择Project -&gt; Compile Document，则对元件编号更新完成。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/uploads/2016/02/Back-Annotate.jpg&quot;&gt;&lt;img src=&quot;/uploads/2016/02/Back-Annotate-300x169.jpg&quot; alt=&quot;Back Annotate&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通常我们在原
    
    </summary>
    
      <category term="硬件设计" scheme="http://hex55.com/categories/%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>PID初学者指南</title>
    <link href="http://hex55.com/2016/01/25/pid-e5-88-9d-e5-ad-a6-e8-80-85-e6-8c-87-e5-8d-97/"/>
    <id>http://hex55.com/2016/01/25/pid-e5-88-9d-e5-ad-a6-e8-80-85-e6-8c-87-e5-8d-97/</id>
    <published>2016-01-25T06:25:22.000Z</published>
    <updated>2016-07-30T01:47:05.455Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>文中所提的PID算法是一个Ardunio的PDI库，原作者为了让使用者理解这个库中的代码，专门写了一篇指南<a href="http://brettbeauregard.com/blog/2011/04/improving-the-beginner%E2%80%99s-pid-derivative-kick/" target="_blank" rel="external">Improving the Beginner’s PID – Derivative Kick</a>，Ardunio的网站上还有一个与这个PID库相对应的PID参数自整定库<a href="http://playground.arduino.cc/Code/PIDAutotuneLibrary" target="_blank" rel="external">PID Autotune Library</a>，我还没来得及去找它的相关文章。话说这篇指南是从一个很实用的角度对PID进行了深入浅出的讲解，文章没有拘泥于数学论证（咱们的目的只是应用，不是论证理论的正确性或者对PID进行学术研究），而是直接从公式写出最简单的十几行PID算法代码，然后针对这十几行代码结合实际问题让这个算法一步一步变得更稳定实用。</p>
<hr>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在发布新的Arduino PID库的时候我决定发布一系列与它相关的文章。上一版本的库，稳定，但是没有提供任何代码相关的解释。这次我计划详细地解释一下代码为什么这么写。我希望对这两类人是有用的：</p>
<ul>
<li>给想知道Arduino PID内部是怎么工作感兴趣的人提供详解。</li>
<li>让任何想自己写PID算法的人知道我是怎么做的，给他们提供借鉴。</li>
</ul>
<p>这将是一个艰难的跋涉，但我想我找到了一个不太痛苦的方式来解释我的代码。我将一个被称为“初学者PID”的代码开始。然后我将一步步改进它直到我们得到一个高效的键壮的PID算法。</p>
<h4 id="初学者PID"><a href="#初学者PID" class="headerlink" title="初学者PID"></a>初学者PID</h4><p>这是众所周知的PID公式：</p>
<p><img src="/uploads/2016/01/pidalgorithm.png" alt=""></p>
<p>这导致大多数人写出了下面这样的PID控制器代码：</p>
<p><img src="/uploads/2016/01/PID2016-01-25_134231.png" alt=""></p>
<p>Compute() 被规则或者不规则地调用，并且它运行得不错。虽然本系列不是关于“运行得不错”的文章。如果我们打算把代码写得像某些工业PID控制器一样，我们得考虑下面这些问题：</p>
<ol>
<li>彩样时间 —— PID算法最好是规则等间隔地进行评估。如果算法中这个是等间隔的，会简化一些内部数学运算。</li>
<li>微分冲击 —— 不是一个了不起的点子，很容易做到这一点，那么让我们做到这一点吧。</li>
<li>在线修改参数 —— 一个好的PID算法是在运行时改变参数而不会产生抖动的算法。</li>
<li>积分饱和 —— 我们会知道什么是积分饱和，并且能够给出一个对此有益的解决方案。</li>
<li>开关（自动/手动）—— 在大多数应用中，都会有在某些时候需要关闭PID的需求，并且手动判定输出，不需要控制器的干涉。</li>
<li>初始化 —— 当控制器被打开的时候，我们不想转换产生抖动。我们不希望输出突然变成一个新的值。</li>
<li>控制方向 —— 最后一个不是一个与稳定性相关的改动。它是被设计成确保用户输入的参数符号正确。</li>
</ol>
<p>一理我们考虑并处理了这些，我们将会有一个稳定的PID算法。不是巧合，我们将会得到一个与最新版Arduino PID 库相同的代码。因此不管你是否打算去写你自己的算法，或者试着去理解PID库的内部，我希望你这能帮到你。让我们开始吧。</p>
<p>更新： 在所的示例代码中我用了双精度。在Ardunio，双精度等同于单精度浮点。对于PID算法而言使用真正的双精度是杀鸡用牛刀。如果你用的语言支持真正的双精度，我建议你将所有的双精度改为单精度浮点。</p>
<hr>
<h3 id="采样时间"><a href="#采样时间" class="headerlink" title="采样时间"></a>采样时间</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>初学者的PID被设计为不定期调用。这将会导致两个问题：</p>
<ul>
<li>你不会得到一个行为稳定的PID，因为有的时候你规则地调用它，而有的时候却不是。</li>
<li>你需要一个精确地计算微分和积分，因为他们每时每刻都在改变。</li>
</ul>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>确保PID在是被有规则的间隔调用。我决定采用的方法是在每个周期都去运行计算函数。基于一个预定义的采样时间，PID决定是否需要计算还是立即返回。</p>
<p>一旦我们知道PID是被以一个常量间隔进行定计算，那么微分和积分处理起来就简单了。福利！</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><img src="/uploads/2016/01/PID2016-01-25_134526.png" alt=""></p>
<p>在10和11行，算法现在决定计算时间是否到了。同样，因为我们知道每次采样时间都是相同的，我们不需要去乘以这个常数。我们只需要将Ki和Kd进行适当的合并，在数学上结果等同，但是更有效率。</p>
<p>不过还有一点问题。如果用户决定在操作期间更改采样时间，Ki和Kd都将需要重新计算以让新修改生效。39——42行就是处理这个问题的。</p>
<p>也要注意我将采样进间进行了转换在第29行。严格地讲这是不需要的，但是这允许用户输入Ki和Kd是以秒为单位（s），而不是毫秒(mS)。</p>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>以上的改变为我们做了三件事：</p>
<ol>
<li>不管以什么频率调用Compute（）函数，PID算法都将会以一个规则的间隔进行评估。</li>
<li>因为计算时间用了简法（行10），mills()回到0的时候将会有问题。每55天将会发生一次，但是要记得预防这种问题。</li>
<li>在我们再也不需要每个时间间隔都要进行乘法和除法。因为它是一个常量，我们能够把它从计算代码（行15 + 行16）移除，并将它以一个常数整定进参数中。数学上等效，但是它在每次PID进行评估的时候节省了乘法和除法运算。</li>
</ol>
<h4 id="关于中断的附注"><a href="#关于中断的附注" class="headerlink" title="关于中断的附注"></a>关于中断的附注</h4><p>如果PID用在一个微控制器中，非常好的一个争论就是是否在中断中使用它。让采样时间等于中断频率，每当时间到的时候进行计算。这样就不需要第9——12、23和24行。如果你计划这样实现你的PID，那么就这样干吧！但还是经计完这一系列。你仍然有希望对你后面的修改从中受益。这有几个我们为什么不用中断的原因：</p>
<ol>
<li>对于本系列而言，并不是每个人都会用到中断。</li>
<li>如果你想在同一时间实现多个PID控制器，在中断中实际会让这变得很麻烦。</li>
<li>说实话我没有想到这一点。当我校对我这个系列的时候Jimmie Rodgers建议我这么做。在将来的PID库中我可能会这么做。</li>
</ol>
<hr>
<h3 id="微分冲击"><a href="#微分冲击" class="headerlink" title="微分冲击"></a>微分冲击</h3><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>这次的修正主要是争对微分项进行改进，我们的目标是消除微分冲击。</p>
<p><img src="/uploads/2016/01/PID2016-01-25_134630.png" alt=""></p>
<p>上图展示了这个问题。因为error = Setpoint - Input,任何Setpoint（译者注：Setpoint就是你要稳定达到的预设值）的改变都会立即导致error的改变。这种改变会导致微分冲击（实际上，因为dt不是0所以这只会是一个很大而非无限大的数字）。这个数字反馈回PID方程，将会导致输出产生意想不到的毛刺。幸运的是这一点非常容易解决。</p>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p><img src="/uploads/2016/01/DonMExplain.png" alt=""></p>
<p>由于Setpoint是一个常数，所以由1式推出dError / dt = - dInput /dt。推导出Error的微份等于负的微分输入，只有当Setpoint改变时才不成立。<br>这就给出了一个完美的解决方案。我们用减去 Kd <em> 输出的微分 代替 加上 Kd </em> 误差的微分。这就是常说的“在测量上进行微分”。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p><img src="/uploads/2016/01/PID2016-01-25_140154.png" alt=""></p>
<p>修改代码就非常简单了，我们用+dError代替 -dInput。用存储lastInput代替存储lastError。</p>
<h4 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h4><p><img src="/uploads/2016/01/PID2016-01-25_140237.png" alt=""></p>
<p>上面就是修正后我们得到的结果。注意输入看起来是一样的。我们获得了同样能，但是我们没有在每次Setpoint改变的时候导致一个巨大的毛刺。</p>
<p>这是否是一个好主意，完全取决于你的应用对输出毛刺有多敏感。办法看起来行得通，它没有为解决问题做任何更多的工作，因此为什么不这么干呢？</p>
<hr>
<h3 id="修改参数"><a href="#修改参数" class="headerlink" title="修改参数"></a>修改参数</h3><h4 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h4><p>对于任何一个还算可以的PID算法都必须让系统有在线调试参数的能力。</p>
<p><img src="/uploads/2016/01/PID2016-01-25_140336.png" alt=""></p>
<p>当你在线调整参数的时候初学者写的PID动作起来像疯了似的。让我们看看这是为什么。下面是初学者PID参数改变前后的状态：</p>
<p><img src="/uploads/2016/01/PID2016-01-25_140448.png" alt=""></p>
<p>我们很快就能将这种震荡归因于积分项（或者 “I项”）。当参数改变时积分项是唯一大幅改变的项。为什么会这样？这得去看看初学者是怎么处理积分项的。</p>
<p><img src="/uploads/2016/01/PIDE2016-01-25_140516.png" alt=""></p>
<p>直到Ki被改变前积分项都工作得很好。然后，突然之间，你将这个新的Ki乘以了全部error的累加和。这不是我们想要的！我们只是想影响将来发生的事（过去的误差不应被乘以这个Ki）。</p>
<h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><p>处理这个问题我有几个办法。在最新的库里面我用的方法是重新调整errSum.乘以Ki?将errSum减半。那样让I项远离震荡，工作良好。尽管这是一种笨拙的办法，还好我找到了更优雅的办法（没办法我一开始并没有想到这一点，但是我还是自己想到了它。真该列！）。</p>
<p>解决方案要求一点基础的代数知识（或微积分）</p>
<p><img src="/uploads/2016/01/PID2016-01-25_140710.png" alt=""></p>
<p>我们将Ki移到积分号的里面代替原先Ki在积分号外面的情况。看起来我们什么也没干，但是我们将会明白实际上这里有一个巨大的改变。</p>
<p>现在，我们依据是否在那个时间乘以Ki。我们然后我们存储那个和。当Ki改变的时候，不会有震荡产生，因为老的Ki仍在起作用。我们得到了一个平滑的输出，而且没有其它的附加数学运算。它可能让我看起来像一个极客，但是我认为这非常的屌！</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><p><img src="/uploads/2016/01/PID2016-01-25_140729.png" alt=""></p>
<p>那么我们将errSum变量用一个复合的ITerm变量代替（第4行）。它等于Ki * error的累加和,而不只是error(第15行)。还有，因为Ki现在被包含在了了ITerm中，所以必须从主的PID算式中移除（第19行）。</p>
<h4 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h4><p><img src="/uploads/2016/01/PID2016-01-25_140820.png" alt=""></p>
<p>那么这个问题得到了很好的修复。当Ki被改变时，重新计算了整个的erro和；仅针我们遇到的每一个error值。在这个代码中，之前的error不变，新的Ki仅针对从这一刻起的error,这正是我们想要的。</p>
<hr>
<h3 id="积分饱和"><a href="#积分饱和" class="headerlink" title="积分饱和"></a>积分饱和</h3><h4 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h4><p><img src="/uploads/2016/01/PID2016-01-25_140942.png" alt=""></p>
<p>积分饱和是一个比其它问题让初学者更需要认真对待的陷阱。它发生在PID认为自己能做点什么但实际上它不能那么做的时候。举个例子，Arduino能够接受的PWM输出是0——255。默认情况下PID并不知道这一点。如果它认为300——400——500都能够工作，那么它将会去尝试这些我们不希望采用的值。因为现实中值将被钳位在255，仅需要保持不去尝试越来越高的值即可。</p>
<p>这个问题以怪异的滞后表现自己。如上，我们看到输出饱和了远远高于外部限制。当setpoint下降的时候，输出必须在抵达255这条线前逐渐减小。</p>
<h4 id="解决方案第1步"><a href="#解决方案第1步" class="headerlink" title="解决方案第1步"></a>解决方案第1步</h4><p>有几种办法可以缓解饱和，我选择的办法如下：告诉PID输出限制是多少。在下面的代码中你将会看到现在有一个SetOutputLimits函数。一旦抵达限制，PID将会停止求和（积分）。它知道没什么事可做，因为输出已经饱和了，当setpoing下降到一定范围内我们可以做点什么时我们将立即得到响应。</p>
<p><img src="/uploads/2016/01/PID2016-01-25_141021.png" alt=""></p>
<h4 id="解决方案第2步"><a href="#解决方案第2步" class="headerlink" title="解决方案第2步"></a>解决方案第2步</h4><p>注意上图，当我们摆脱了积分滞后性之后，我们并没有将这条路走完。在PID认为它在发送的和实际上发送的之间仍有差异。为什么？因为比例项和（程度较小）微公项的原因。</p>
<p>尽管积分项已经被安全的钳位了，P和D仍然在发挥他们的两个影响，得到的结果将比输出限制要高。这对我来说是不可接受的。如果用户调用了函数SetOutputLimits，那么他们是假定输出必须在这个值以内。因此，第二步是我们作了一个有效的假设。除了钳位积分项，我们还钳位了输出值让它待在我们期望的范围内。</p>
<p>（注意，你可能问为什么我去要两个都钳位。我们在任何情况下都钳位了输出，为什么还要钳位积分项？如果我们所做的只有钳位输出，那么积分项将会一直增长。尽管在饱和时输出看起来非常漂亮，但是我们将会看到下降滞后了（译者注：意思大概就是说如果没有钳位积分项，那么在输出本该下降的时候却因为一直在增长的积分项的值很大而导致输出滞后了）。）</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><p><img src="/uploads/2016/01/PID2016-01-25_141121.png" alt=""></p>
<p>加入了一个允许用户约束输出的新函数（52行-63行）。这些限制被加在积分项（17——18行）和输出上（23——24行）。</p>
<h4 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h4><p><img src="/uploads/2016/01/PID2016-01-25_141157.png" alt=""></p>
<p>如我们所看到的，饱和被消除了。此外输出也落在了我们所希望的地方。这意味着我们不需在外部钳位输出。如果你想让输出落在23——167的范围内，你可以将它们设为出输限制值。</p>
<hr>
<h3 id="开关机"><a href="#开关机" class="headerlink" title="开关机"></a>开关机</h3><h4 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h4><p>PID控制器看起来很不错，有时候你都不必关心它想说什么。</p>
<p><img src="/uploads/2016/01/PID2016-01-25_141228.png" alt=""></p>
<p>比方说，在你程序的有些地方你想强制输出为一个定值（比如0），你当然可以像下面这个函数这样做：</p>
<pre><code>void loop()
{
Compute();
Output=0;
}
</code></pre><p>这种方式，不关心PID想说什么，你仅仅是覆盖它的值。然而在实践中这是一个可怕的主意。PID控制器将会非常困惑：“我持续地输出，但是它妈的什么都没有发生？该怎么搞？还是让我再多输出一些吧。”结果，当你停止覆盖PID的输出，并且切换到PID，你将会在输出值上得到一个巨大的瞬变。</p>
<h4 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h4><p>解决这个问题的办法就是明确地告诉PID开或者关。称呼这两个状态常用的术语是“手动”（我将会自己手动去判断这个值）和“自动”（PID将会自动的判定输出）。让我们看看在代码中该怎么做：</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><p><img src="/uploads/2016/01/PID2016-01-25_141325.png" alt=""></p>
<p>一个相当简单的解决方法。如果你不是在自动模式，立即停止Compute函数，不需在考虑输出或是任何的内部变量。</p>
<h4 id="结果-4"><a href="#结果-4" class="headerlink" title="结果"></a>结果</h4><p><img src="/uploads/2016/01/PID2016-01-25_141402.png" alt=""></p>
<p>显然你可以获得一个类似的作用，只要在不在调用函数里面不调用Compute函数即可，但是这个方案会保留PID内部的工作参数，这正是我们想要的方法。通过保持内部的工作参数，我们可以确认我们处在什么模式下，并且更重要的是当模式改变时我们也会知道。那么让我们开始下一节吧……….</p>
<hr>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在上一节里面，我们实现了对PID的开关。我们关了它，但是让我们看看当然们再次打开它的时候会发生什么：</p>
<p><img src="/uploads/2016/01/PID2016-01-25_141440.png" alt=""></p>
<p>哎呀！PID控制器只是跳回到上次它输出的值那里，然后从那里开始进行判断。结果导致Input产生了一个我们不希望有的坎。</p>
<h4 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h4><p>有一个简单漂亮的办法去修复这个部题。因为我们知道什么时候我们会打开（从手动切到自动），我们只要为平滑过渡初始化一些参数。那意味着需要存储两个工作变量（ITerm和lastInput）去让输出远离那个坎。</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><p><img src="/uploads/2016/01/PID2016-01-25_141607.png" alt=""></p>
<p>我们修改了SetMode(…)函数，让它可以检测从手动到自动的转变，并且我们增加了一个初始化函数。它让ITerm = Output,而不关心内部的积分项，并且lastInput = Input让输出平滑。比例项不依赖过去的任何信息，因此它不需要任何的初始化。</p>
<h4 id="结果-5"><a href="#结果-5" class="headerlink" title="结果"></a>结果</h4><p><img src="/uploads/2016/01/PID2016-01-25_141723.png" alt=""></p>
<p>从上图我们看到正确的初始化会让从手动切换到自动时没有波动：正是我们希望的。</p>
<h4 id="更新：为什么不是ITerm-0"><a href="#更新：为什么不是ITerm-0" class="headerlink" title="更新：为什么不是ITerm = 0?"></a>更新：为什么不是ITerm = 0?</h4><p>最近收到很多人问我为什么不让ITerm = 0 作为初始化。答案是，我将会问你考虑一下以下的情景：PID在手动模式，然后用户让输出值为50。过了一会，该过程持续稳定地输出，对应输入为75.2。用户将Setpoint设为75.2并且开启了PID，将会发生什么？</p>
<p>我认为在切换到自动模式后，输出将仍然会是50。因为P和D项都将为0，这种情况出现的唯一办法就是将ITerm初始化为Output。</p>
<p>如果你的方案中需要将输出初始化为0，不要在上面代码的后面这么干。只要将PID从手动切换为自动前在你的调用函数中将Output = 0 。</p>
<hr>
<h3 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h3><h4 id="问题-5"><a href="#问题-5" class="headerlink" title="问题"></a>问题</h4><p>PID控制器需要有两种处理过程：正向和反向。所有我给你看的例子都还是正向的。就是，输出的增加会导致输入的增加。反向过程正好相反。例如在冰箱中，增加制冷会使温度更进一步下降。让初学者PID控制器能够在反向时依然能工作，埯机将Kp, Ki 和Kd全部取为负数。</p>
<p>这本身并不是一个问题，但用户必须选择正确的符号，并确保所有的参数符号相同。</p>
<h4 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h4><p>为了让过程更简单一点，我要求所有的Kp, Ki 和Kd 都 &gt;= 0。如果用户想要连接一个反向过程，他们需要单独调用SetControllerDirection函数。这将确保所有的参数有相同的符号，希望这能让事情得更直观。</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><p><img src="/uploads/2016/01/PID2016-01-25_141827.png" alt=""></p>
<h4 id="PID结束语"><a href="#PID结束语" class="headerlink" title="PID结束语"></a>PID结束语</h4><p>将上面讲的所有这些组合起来，我们就能将初学者PID控制器转变成一个能用在目前就我所知的大多数机器人控制器中。对于那些希望了解PID库细节的读者，我希望你们来对了地方。对于那些希望自己写PID的读者，我希望你能从我这里得到一些点子而少走一点弯路。</p>
<p>最后注意两点：</p>
<ol>
<li><p>如果在这个系列里面有什么错误请告知我。我可能忘记了什么，或者解释得不够清楚。总之让我知道吧。</p>
</li>
<li><p>这只是一个基本的PID。正如其名为了简单还有很多问题我特意没有处理。浮现在我脑海里的有这么几个：前馈，reset tiebacks（怎么译？），整数运算，差分PID形式，用增量式代替位置式。如果希望我对这些展开请告诉我。</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;文中所提的PID算法是一个Ardunio的PDI库，原作者为了让使用者理解这个库中的代码，专门写了一篇指南&lt;a href=&quot;http://b
    
    </summary>
    
      <category term="MCU/ARM" scheme="http://hex55.com/categories/MCU-ARM/"/>
    
    
  </entry>
  
  <entry>
    <title>运放复习笔记</title>
    <link href="http://hex55.com/2016/01/18/e8-bf-90-e6-94-be-e5-a4-8d-e4-b9-a0-e7-ac-94-e8-ae-b0/"/>
    <id>http://hex55.com/2016/01/18/e8-bf-90-e6-94-be-e5-a4-8d-e4-b9-a0-e7-ac-94-e8-ae-b0/</id>
    <published>2016-01-18T07:38:00.000Z</published>
    <updated>2016-07-19T00:29:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>好久没搞过运放了，今天复习一下。</p>
<p>对于运放最简单的理想分析无非两点：虚短和虚断。在说虚短和虚短之前我们得先知道仅仅当运放处于线性区时才能利用虚短和虚断进行分析，那么如何知道运放是否工作在线性区？就我个人经验，无非两种方式：</p>
<ol>
<li><strong>理论型：</strong>假定其工作在线性区，然后通过计算确认运放的输出VO是否会大于运放的供电电压VDD。</li>
<li><strong>实践型：</strong>用仪表测得+P和-P的电压如果大于1mV（该数值与具体器件相关），运放可能工作在饱和区，当然它也可以坏掉了。</li>
</ol>
<p>那么下面再来说说企么是虚短和虚断：</p>
<ul>
<li><strong>虚短</strong>——运放的+P和-P之间的电位相等（实际上是有很小的电位差，比如小于1mV）。</li>
<li><strong>虚断</strong>——运放的+P和-P之间的电流为零(实际是有很微弱的电流，如果二者之间的电压差是1mV,而运放本身的阻抗通常都是兆欧，你自己算算这电流有多小)。</li>
</ul>
<p>这就是能常所说的虚短和虚断，感觉两句话好像是一个意思，显得很废话。我倒是更喜欢老外的直白。《the art of electronics》中有以下说法：</p>
<blockquote>
<p>1、The output attempts to do whatever is necessary to make the voltage difference between the inputs zero.<br>  2、The inputs draw no current.<br>  One important note of explanation: Golden rule I doesn’t mean that the opamp acturally changes the voltage at its inputs.It can’t do that.(How could it,and be consistent with golden rule Ⅱ?) What it does is “look” at its input terminals and swing its output terminal around so that the external feedback network brings the input differential to zero (if possible)</p>
</blockquote>
<p>上面标出的第一二两点显得更实用：<br>1、运放的两个输入端总会趋于相等（这应该是由引入负反馈产生的一个动态调整的过程）。<br>2、运放的输入端可以认为没有电流输入，因为阻抗很大，相比于外部电路其电流可以忽略（记得在分析三极管电路时我们也认为Ib几乎为0）。</p>
<p>有了上面两点，分析起来就好说了，拿常用的运放电路图进行分析：</p>
<p><a href="/uploads/2016/01/op-amplify1.jpg"><img src="/uploads/2016/01/op-amplify1-300x229.jpg" alt="op amplify1"></a></p>
<p>图1中由于V-等于V+所以V-可以认为是地，而-P这一端没有电流输入那么R1和R2上的电流大小是一样的，但流向相反，所以VI和Vout相对于V-（GND）点的电压就是与R1和R2成正比。所以VO = - Vi &#42; R2/R1 。</p>
<p><a href="/uploads/2016/01/op-amplify2.jpg"><img src="/uploads/2016/01/op-amplify2-255x300.jpg" alt="op amplify2"></a></p>
<p>图2中一样的道理，R2与R1中间这一点的电压等于Vi，所以VOUT = Vi &#42; (R1+R2) / R2。</p>
<p><a href="/uploads/2016/01/op-amplify3.jpg"><img src="/uploads/2016/01/op-amplify3-300x227.jpg" alt="op amplify3"></a></p>
<p>图3假定R1、R2、R3电阻相同，那么V-=V+=GND，由R3流入GND的电流大小等于由R1和R2流入电流之和，方向相反，而R1、R2、R3相等，那么R3的电压必然是-(V1+V2)。</p>
<p><a href="/uploads/2016/01/op-amplify4.jpg"><img src="/uploads/2016/01/op-amplify4-300x203.jpg" alt="op amplify4"></a></p>
<p>图4中假定R1=R2,R4=43。既然没和电流注入+P，那么V+点的电压为（V1+V2）/2。同理V-点的电压也为（V1+V2）/2，那么Vo显然只能等于V1+V2了。</p>
<p><a href="/uploads/2016/01/op-amplify5.jpg"><img src="/uploads/2016/01/op-amplify5-300x274.jpg" alt="op amplify5"></a></p>
<p>图5假定R1=R2,R4=43。既然没有电流注入+P，那么V+ = V2/2，V-也为V2/2。而同时V-=（V1+Vout）/2，所以VOUT= V2 - V1。</p>
<p><a href="/uploads/2016/01/op-amplify6.jpg"><img src="/uploads/2016/01/op-amplify6-300x217.jpg" alt="op amplify6"></a></p>
<p>图6就是将输出在C1上进行积分。</p>
<p><a href="/uploads/2016/01/op-amplify7.jpg"><img src="/uploads/2016/01/op-amplify7-300x206.jpg" alt="op amplify7"></a></p>
<p>图7就是将输入在C1上进行微分。</p>
<p><a href="/uploads/2016/01/op-amplify8.jpg"><img src="/uploads/2016/01/op-amplify8-300x266.jpg" alt="op amplify8"></a></p>
<p>图8咱们先看从R4和R6这里开始，即视Vo1和Vo2，图的右边是不是跟图5一样，是个减法器Vout = Vo2 - Vo1。那么再看Vo2 - Vo1等于多少？显然Vx = V1, Vy = V2,Vo1-Vo2=I*(R1+R2+R3) = (Vx-Vy)(R1+R2+R3)/R2 = (V1-V2) (R1+R2+R3)/R2。</p>
<p><a href="/uploads/2016/01/op-amplify9.jpg"><img src="/uploads/2016/01/op-amplify9-300x186.jpg" alt="op amplify9"></a></p>
<p>图9，V1-Vx = (R2/R4) （Vx - Vo）, V2 - Vy = (R3/R5) Vy, 式中Vx = Vy, R2/R4 = R3/R5， 那么 Vo = (R4/42)/(V2-V1),而V2-V1上的电压即为R1上的差分电压。</p>
<p><a href="/uploads/2016/01/op-amplify10.jpg"><img src="/uploads/2016/01/op-amplify10-300x212.jpg" alt="op amplify10"></a></p>
<p>图10，假定RL远小于 100K的话，由于没有电流注入运放，那么V1=Vi/2,而V2=V3/2，而V1=V2，那么V3 = Vi,由于RL远小于100K，那么R7上流过的电流正比于Vi。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没搞过运放了，今天复习一下。&lt;/p&gt;
&lt;p&gt;对于运放最简单的理想分析无非两点：虚短和虚断。在说虚短和虚短之前我们得先知道仅仅当运放处于线性区时才能利用虚短和虚断进行分析，那么如何知道运放是否工作在线性区？就我个人经验，无非两种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;stro
    
    </summary>
    
      <category term="硬件设计" scheme="http://hex55.com/categories/%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>qmodbus在visual studio中的编译。</title>
    <link href="http://hex55.com/2016/01/12/qmodbus-e5-9c-a8visual-studio-e4-b8-ad-e7-9a-84-e7-bc-96-e8-af-91-e3-80-82/"/>
    <id>http://hex55.com/2016/01/12/qmodbus-e5-9c-a8visual-studio-e4-b8-ad-e7-9a-84-e7-bc-96-e8-af-91-e3-80-82/</id>
    <published>2016-01-12T01:58:46.000Z</published>
    <updated>2016-07-19T00:29:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>MINGW的编译我没弄过，直接上VISUAL STUDIO。原本对QT也不熟。费了些时间整出来，记下来。</p>
<p>1.修改C为变量定义在函数首，不知道如何在QT中启用C99。<br>2.pro文件中    QT += widgets 修改为QT += webkitwidgets,参考《Porting C++ Applications to Qt 5》<br><a href="/uploads/2016/01/qmodbus_visualstdio.png"><img src="/uploads/2016/01/qmodbus_visualstdio-300x164.png" alt="qmodbus_visualstdio"></a><br>3.工程中所有的#include <qtwebkit>替换为#include <qtwebkitwidgets>，参考《Porting C++ Applications to Qt 5》<br>4.工程中所有的#include &lt;qwineventnotifier_p.h&gt;替换为#include &lt;qwineventnotifier.h&gt;<br>5.在qextserialenumerator_win.cpp中添加 #pragma comment(lib,”user32”)，#pragma comment(lib,”Advapi32.lib”)。<br><a href="/uploads/2016/01/qmodbus_visualstdio2.png"><img src="/uploads/2016/01/qmodbus_visualstdio2-300x123.png" alt="qmodbus_visualstdio2"></a></qtwebkitwidgets></qtwebkit></p>
<p>最后看一看生成的程序。<strong>从sourceforge上下载的QMODBUS的可执行程序和我编译生成的QMODBUS是一不一样的，我编译生成这个功能更强大，包含MODBUS RTU、MODBUS TCP、MODBUS ASCII，可能由于我用的源码是较新版本的原因。</strong></p>
<p><a href="/uploads/2016/01/2016-01-13_094752.png"><img src="/uploads/2016/01/2016-01-13_094752-300x184.png" alt="2016-01-13_094752"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MINGW的编译我没弄过，直接上VISUAL STUDIO。原本对QT也不熟。费了些时间整出来，记下来。&lt;/p&gt;
&lt;p&gt;1.修改C为变量定义在函数首，不知道如何在QT中启用C99。&lt;br&gt;2.pro文件中    QT += widgets 修改为QT += webkitwi
    
    </summary>
    
      <category term="windows\linux" scheme="http://hex55.com/categories/windows-linux/"/>
    
    
  </entry>
  
  <entry>
    <title>超高速高精度红外测径仪第三版</title>
    <link href="http://hex55.com/2016/01/10/e8-b6-85-e9-ab-98-e9-80-9f-e9-ab-98-e7-b2-be-e5-ba-a6-e7-ba-a2-e5-a4-96-e6-b5-8b-e5-be-84-e4-bb-aa-e7-ac-ac-e4-b8-89-e7-89-88/"/>
    <id>http://hex55.com/2016/01/10/e8-b6-85-e9-ab-98-e9-80-9f-e9-ab-98-e7-b2-be-e5-ba-a6-e7-ba-a2-e5-a4-96-e6-b5-8b-e5-be-84-e4-bb-aa-e7-ac-ac-e4-b8-89-e7-89-88/</id>
    <published>2016-01-10T03:43:29.000Z</published>
    <updated>2016-07-30T01:58:39.700Z</updated>
    
    <content type="html"><![CDATA[<p>真是生命不息，改版不止啊。</p>
<p><a href="/uploads/2016/01/2016-01-10_114150.png"><img src="/uploads/2016/01/2016-01-10_114150-300x121.png" alt="2016-01-10_114150"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;真是生命不息，改版不止啊。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/uploads/2016/01/2016-01-10_114150.png&quot;&gt;&lt;img src=&quot;/uploads/2016/01/2016-01-10_114150-300x121.png&quot; alt=&quot;2016
    
    </summary>
    
      <category term="硬件设计" scheme="http://hex55.com/categories/%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>如何读懂GIT的DIFF信息</title>
    <link href="http://hex55.com/2016/01/08/e5-a6-82-e4-bd-95-e8-af-bb-e6-87-82git-e7-9a-84diff-e4-bf-a1-e6-81-af/"/>
    <id>http://hex55.com/2016/01/08/e5-a6-82-e4-bd-95-e8-af-bb-e6-87-82git-e7-9a-84diff-e4-bf-a1-e6-81-af/</id>
    <published>2016-01-08T02:17:06.000Z</published>
    <updated>2016-07-30T02:22:15.510Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/uploads/2016/01/git_diff.png"><img src="/uploads/2016/01/git_diff-300x184.png" alt="git_diff"></a></p>
<p>输入git diff后就会显示DIFF信息，由于GIT的DIFF信息并不是标准的UNIX信息，而是一种合并DIFF信息的变体。以下例进行说明。</p>
<pre><code>diff --git a/readme.txt b/readme.txt
index 00388d0..055c47b 100644
--- a/readme.txt
+++ b/readme.txt
@@ -1 +1,2 @@
-git learn.
\ No newline at end of file
+git learn.
+asdfasdf
\ No newline at end of file
</code></pre><ul>
<li><p><code>diff --git a/readme.txt b/readme.txt</code> 中diff –git表示这是GIT版本的DIFF信息，a/readme.txt b/readme.txt这个就表示版本要比较的a\b版本都是readme.txt文件。</p>
</li>
<li><p><code>index 00388d0..055c47b 100644</code>中00388d0..055c47b表示文件的哈希值，即要比较的文件的哈希开头分别是00388d0和055c47b ， 644表示普通权限，这一条信息通常我并不怎么关注。</p>
</li>
<li><p>— a/readme.txt中—表示a的原版本文件是readme.txt。</p>
</li>
<li><p>+++ b/readme.txt中+++给示新产生的b版本文件也是readme.txt。</p>
</li>
<li>@@ -1 +1,2 @@这一行，-1给示原文件的第1行变动了（-表示原文件）， +1，2表示新文件从第一行开始共2行变动了（+表示变动后的文件）。</li>
<li>-git learn.表示原文件的git learn这一行被删除了，-表示删除。</li>
<li>+git learn.以及+asdfasdf表示b版本中新增了这两行，+表示增加。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/uploads/2016/01/git_diff.png&quot;&gt;&lt;img src=&quot;/uploads/2016/01/git_diff-300x184.png&quot; alt=&quot;git_diff&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;输入git diff后就会显示DIFF信息
    
    </summary>
    
      <category term="windows-linux" scheme="http://hex55.com/categories/windows-linux/"/>
    
    
  </entry>
  
  <entry>
    <title>freemodbus源码分析详解</title>
    <link href="http://hex55.com/2016/01/06/freemodbus-e6-ba-90-e7-a0-81-e5-88-86-e6-9e-90-e8-af-a6-e8-a7-a3/"/>
    <id>http://hex55.com/2016/01/06/freemodbus-e6-ba-90-e7-a0-81-e5-88-86-e6-9e-90-e8-af-a6-e8-a7-a3/</id>
    <published>2016-01-06T07:37:47.000Z</published>
    <updated>2016-07-19T00:29:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>我这里为了方便代码浏览，用了VS2013，DEMO自然用WIN32的，选用哪个DEMO进行分析也并不影响我们对FREEMODBUS的解剖。</p>
<h3 id="代码组织结构"><a href="#代码组织结构" class="headerlink" title="代码组织结构"></a>代码组织结构</h3><p><img src="/uploads/2016/01/freemodbus_source_analysis.png" alt="freemodbus_source_analysis"></p>
<p>首先是modbus这个大文件下的文件：</p>
<ul>
<li><strong>ascii</strong>目录的文件是用于实现MODBUS ASCII模式的，这个在modbus里是可选实现代码比较简单，看完RTU的分析我相信你对比着自己也就看明白ASCII模式了，这将不是本文的重点。</li>
<li><strong>funcions</strong>是与RTU的执行功能码相关的代码，主要就是读、写寄存器开关线圈之类的，根据你自己的需要在去实现里面回调，按照相应参数去执行相应功能。</li>
<li><strong>include</strong>是freemodbus的一些定义，这里先不作分析，在看源代码的时候我们再去看每个数据结构的相关定义。</li>
<li><strong>rtu</strong>这个文件夹就是RTU模式的实现了，本文分析重点之一。</li>
<li><strong>port这个是移植相关</strong>，port.h是移植需要的函数声明。portevent.c这个是事件队列的实现，freemodbus只是用了一个消息作为队列简单赋值处理，portother.c是一相从字节里取位等与MODBUS没多大关系的函数，portserial.c是串口移植相关函数，porttimer.c是定时器相关移植（由于RTU方式依赖时间来判断帧头帧尾），移植相关可以参见我的另一篇博文(译自官方文档)<a href="http://www.hex55.com/2016/01/05/freemodbus-rtuascii-%E5%AE%98%E6%96%B9%E7%A7%BB%E6%A4%8D%E6%96%87%E6%A1%A3/" target="_blank" rel="external">freemodbus RTU/ASCII 官方移植文档</a>。</li>
<li><p><strong>mb.c</strong>这个就是modbus的应用层实现，本文分析重点之一。</p>
<p>Source Files目录中的demo.cpp是例程，stdafx.cpp是WIN32的预编译文件与modbusfree无关。</p><p></p>
</li>
</ul>
<h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><h4 id="win32的main（）分析，不感兴趣直接跳到mb-c一节"><a href="#win32的main（）分析，不感兴趣直接跳到mb-c一节" class="headerlink" title="win32的main（）分析，不感兴趣直接跳到mb.c一节"></a>win32的main（）分析，不感兴趣直接跳到<em>mb.c</em>一节</h4><p></p><p>一切还是从main开始吧。</p>
<pre><code>int
_tmain( int argc, _TCHAR * argv[] )
{
    int             iExitCode;
    TCHAR           cCh;
    BOOL            bDoExit;

    const UCHAR     ucSlaveID[] = { 0xAA, 0xBB, 0xCC };

    if( eMBInit( MB_RTU, 0x01, 1, 115200, MB_PAR_EVEN ) != MB_ENOERR )
    {
        _ftprintf( stderr, _T( &quot;%s: can&apos;t initialize modbus stack!\r\n&quot; ), PROG );
        iExitCode = EXIT_FAILURE;
    }
    else if( eMBSetSlaveID( 0x34, TRUE, ucSlaveID, 3 ) != MB_ENOERR )
    {
        _ftprintf( stderr, _T( &quot;%s: can&apos;t set slave id!\r\n&quot; ), PROG );
        iExitCode = EXIT_FAILURE;
    }
    else
    {
        /* Create synchronization primitives and set the current state
         * of the thread to STOPPED.
         */
        InitializeCriticalSection( &amp;amp;hPollLock );
        eSetPollingThreadState( STOPPED );

        /* CLI interface. */
        _tprintf( _T( &quot;Type &apos;q&apos; for quit or &apos;h&apos; for help!\r\n&quot; ) );
        bDoExit = FALSE;
        do
        {
            _tprintf( _T( &quot;&amp;gt; &quot; ) );
            cCh = _gettchar(  );
            switch ( cCh )
            {
            case _TCHAR( &apos;q&apos; ):
                bDoExit = TRUE;
                break;
            case _TCHAR( &apos;d&apos; ):
                eSetPollingThreadState( SHUTDOWN );
                break;
            case _TCHAR( &apos;e&apos; ):
                if( bCreatePollingThread(  ) != TRUE )
                {
                    _tprintf( _T( &quot;Can&apos;t start protocol stack! Already running?\r\n&quot; ) );
                }
                break;
            case _TCHAR( &apos;s&apos; ):
                switch ( eGetPollingThreadState(  ) )
                {
                case RUNNING:
                    _tprintf( _T( &quot;Protocol stack is running.\r\n&quot; ) );
                    break;
                case STOPPED:
                    _tprintf( _T( &quot;Protocol stack is stopped.\r\n&quot; ) );
                    break;
                case SHUTDOWN:
                    _tprintf( _T( &quot;Protocol stack is shuting down.\r\n&quot; ) );
                    break;
                }
                break;
            case _TCHAR( &apos;h&apos; ):
                _tprintf( _T( &quot;FreeModbus demo application help:\r\n&quot; ) );
                _tprintf( _T( &quot;  &apos;d&apos; ... disable protocol stack.\r\n&quot; ) );
                _tprintf( _T( &quot;  &apos;e&apos; ... enabled the protocol stack\r\n&quot; ) );
                _tprintf( _T( &quot;  &apos;s&apos; ... show current status\r\n&quot; ) );
                _tprintf( _T( &quot;  &apos;q&apos; ... quit applicationr\r\n&quot; ) );
                _tprintf( _T( &quot;  &apos;h&apos; ... this information\r\n&quot; ) );
                _tprintf( _T( &quot;\r\n&quot; ) );
                _tprintf( _T( &quot;Copyright 2006 Christian Walter &amp;lt;wolti@sil.at&amp;gt;\r\n&quot; ) );
                break;
            default:
                if( cCh != _TCHAR(&apos;\n&apos;) )
                {
                    _tprintf( _T( &quot;illegal command &apos;%c&apos;!\r\n&quot; ), cCh );
                }
                break;
            }

            /* eat up everything untill return character. */
            while( cCh != &apos;\n&apos; )
            {
                cCh = _gettchar(  );
            }
        }
        while( !bDoExit );

        /* Release hardware resources. */
        ( void )eMBClose(  );
        iExitCode = EXIT_SUCCESS;
    }
    return iExitCode;
}

`&lt;/pre&gt;

eMBInit( MB_RTU, 0x01, 1, 115200, MB_PAR_EVEN ) != MB_ENOERR 初始化modbus协议栈，如果实始化失败则打印错误信息并退出，否则打印命令提示符，要求输入指令。

&lt;pre&gt;`
       do
        {
            _tprintf( _T( &quot;&amp;gt; &quot; ) );
            cCh = _gettchar(  );
            switch ( cCh )
            {
            case _TCHAR( &apos;q&apos; ):
                bDoExit = TRUE;
                break;
            case _TCHAR( &apos;d&apos; ):
                eSetPollingThreadState( SHUTDOWN );
                break;
            case _TCHAR( &apos;e&apos; ):
                if( bCreatePollingThread(  ) != TRUE )
                {
                    _tprintf( _T( &quot;Can&apos;t start protocol stack! Already running?\r\n&quot; ) );
                }
                break;
            case _TCHAR( &apos;s&apos; ):
                switch ( eGetPollingThreadState(  ) )
                {
                case RUNNING:
                    _tprintf( _T( &quot;Protocol stack is running.\r\n&quot; ) );
                    break;
                case STOPPED:
                    _tprintf( _T( &quot;Protocol stack is stopped.\r\n&quot; ) );
                    break;
                case SHUTDOWN:
                    _tprintf( _T( &quot;Protocol stack is shuting down.\r\n&quot; ) );
                    break;
                }
                break;
            case _TCHAR( &apos;h&apos; ):
                _tprintf( _T( &quot;FreeModbus demo application help:\r\n&quot; ) );
                _tprintf( _T( &quot;  &apos;d&apos; ... disable protocol stack.\r\n&quot; ) );
                _tprintf( _T( &quot;  &apos;e&apos; ... enabled the protocol stack\r\n&quot; ) );
                _tprintf( _T( &quot;  &apos;s&apos; ... show current status\r\n&quot; ) );
                _tprintf( _T( &quot;  &apos;q&apos; ... quit applicationr\r\n&quot; ) );
                _tprintf( _T( &quot;  &apos;h&apos; ... this information\r\n&quot; ) );
                _tprintf( _T( &quot;\r\n&quot; ) );
                _tprintf( _T( &quot;Copyright 2006 Christian Walter &amp;lt;wolti@sil.at&amp;gt;\r\n&quot; ) );
                break;
            default:
                if( cCh != _TCHAR(&apos;\n&apos;) )
                {
                    _tprintf( _T( &quot;illegal command &apos;%c&apos;!\r\n&quot; ), cCh );
                }
                break;
            }

            /* eat up everything untill return character. */
            while( cCh != &apos;\n&apos; )
            {
                cCh = _gettchar(  );
            }
        }
        while( !bDoExit );

`&lt;/pre&gt;

如果用户输入e,则会调用bCreatePollingThread(  )启动协议栈线程。那么我们跟进bCreatePollingThread(  )去看看。

&lt;pre&gt;`
BOOL
bCreatePollingThread( void )
{
    BOOL            bResult;

    if( eGetPollingThreadState(  ) == STOPPED )
    {
        if( ( hPollThread = CreateThread( NULL, 0, dwPollingThread, NULL, 0, NULL ) ) == NULL )
        {
            /* Can&apos;t create the polling thread. */
            bResult = FALSE;
        }
        else
        {
            bResult = TRUE;
        }
    }
    else
    {
        bResult = FALSE;
    }

    return bResult;
}

`&lt;/pre&gt;

先是确认一下线程状态，然后创建并启动线程函数dwPollingThread（），

&lt;pre&gt;`
DWORD           WINAPI
dwPollingThread( LPVOID lpParameter )
{
    eSetPollingThreadState( RUNNING );

    if( eMBEnable(  ) == MB_ENOERR )
    {
        do
        {
            if( eMBPoll(  ) != MB_ENOERR )
                break;
        }
        while( eGetPollingThreadState(  ) != SHUTDOWN );
    }

    ( void )eMBDisable(  );

    eSetPollingThreadState( STOPPED );

    return 0;
}

`&lt;/pre&gt;

从这里就跟MCU\ARM上应用freemodbus一样一样的了，无法是先使能协议栈，然后循环调用eMBPoll(  )，同时用eGetPollingThreadState（）检测线程状态。eMBPoll( void )就是我们的重点咯，我们现在已经进入mb.c这个文件啦，这个是freemodbus实现的modbus应用层，虽然代码里面对数据链路层以及应用层分的不是很清晰，但这个mb.c是完完全全的应用层了。

#### mb.c

&lt;pre&gt;`
eMBErrorCode
eMBPoll( void )
{
    static UCHAR   *ucMBFrame;
    static UCHAR    ucRcvAddress;
    static UCHAR    ucFunctionCode;
    static USHORT   usLength;
    static eMBException eException;

    int             i;
    eMBErrorCode    eStatus = MB_ENOERR;
    eMBEventType    eEvent;

    /* Check if the protocol stack is ready. */
    if( eMBState != STATE_ENABLED )
    {
        return MB_EILLSTATE;
    }

    /* Check if there is a event available. If not return control to caller.
     * Otherwise we will handle the event. */
    if( xMBPortEventGet( &amp;amp;eEvent ) == TRUE )
    {
        switch ( eEvent )
        {
        case EV_READY:
            break;

        case EV_FRAME_RECEIVED:
            eStatus = peMBFrameReceiveCur( &amp;amp;ucRcvAddress, &amp;amp;ucMBFrame, &amp;amp;usLength );
            if( eStatus == MB_ENOERR )
            {
                /* Check if the frame is for us. If not ignore the frame. */
                if( ( ucRcvAddress == ucMBAddress ) || ( ucRcvAddress == MB_ADDRESS_BROADCAST ) )
                {
                    ( void )xMBPortEventPost( EV_EXECUTE );
                }
            }
            break;

        case EV_EXECUTE:
            ucFunctionCode = ucMBFrame[MB_PDU_FUNC_OFF];
            eException = MB_EX_ILLEGAL_FUNCTION;
            for( i = 0; i &amp;lt; MB_FUNC_HANDLERS_MAX; i++ )
            {
                /* No more function handlers registered. Abort. */
                if( xFuncHandlers[i].ucFunctionCode == 0 )
                {
                    break;
                }
                else if( xFuncHandlers[i].ucFunctionCode == ucFunctionCode )
                {
                    eException = xFuncHandlers[i].pxHandler( ucMBFrame, &amp;amp;usLength );
                    break;
                }
            }

            /* If the request was not sent to the broadcast address we
             * return a reply. */
            if( ucRcvAddress != MB_ADDRESS_BROADCAST )
            {
                if( eException != MB_EX_NONE )
                {
                    /* An exception occured. Build an error frame. */
                    usLength = 0;
                    ucMBFrame[usLength++] = ( UCHAR )( ucFunctionCode | MB_FUNC_ERROR );
                    ucMBFrame[usLength++] = eException;
                }
                if( ( eMBCurrentMode == MB_ASCII ) &amp;amp;&amp;amp; MB_ASCII_TIMEOUT_WAIT_BEFORE_SEND_MS )
                {
                    vMBPortTimersDelay( MB_ASCII_TIMEOUT_WAIT_BEFORE_SEND_MS );
                }                
                eStatus = peMBFrameSendCur( ucMBAddress, ucMBFrame, usLength );
            }
            break;

        case EV_FRAME_SENT:
            break;
        }
    }
    return MB_ENOERR;
}

`&lt;/pre&gt;

eMBPoll（）就是一个状态机。它只有下面四种状态：

&lt;pre&gt;`
typedef enum
{
    EV_READY,                   /*!&amp;lt; Startup finished. */
    EV_FRAME_RECEIVED,          /*!&amp;lt; Frame received. */
    EV_EXECUTE,                 /*!&amp;lt; Execute function. */
    EV_FRAME_SENT               /*!&amp;lt; Frame sent. */
} eMBEventType;

`&lt;/pre&gt;

从注释中可以看出，分别是启动完成，帧接收完成，执行功能码，执行帧发送。

这个状态机通过xMBPortEventGet( &amp;amp;eEvent ) 获取事件状态，而事件状态的投递方是谁呢？这里我们先不关注（咱们自上向下分析吧）。我们先分析一下这个状态机的流程。

由于我在写这篇文章之前做过功课，所以比较清楚，这里大家过一下就可以了。

在整个协议栈运行的最初肯定是EV_READY态，然后过了一个3.5T（这个就是modbus的帧头帧尾确认时间啦，不清楚？去翻翻协议吧，我当然不建议你去读国人写的那些“modbus协议整理”之类的葵花宝典，而是建议你去modbus官网下载。找不到下载链接？看这里[Modbus Specifications and Implementation Guides](http://www.modbus.org/specs.php),点那个I Accept就可以进去啦。）如果这个时候接收到一个完整的帧那么就会进入EV_FRAME_RECEIVED态，至于是谁负责去接收和检验帧我们后面再去理，你要记住我们还在应用层里打转转。

&lt;pre&gt;`
                /* Check if the frame is for us. If not ignore the frame. */
                if( ( ucRcvAddress == ucMBAddress ) || ( ucRcvAddress == MB_ADDRESS_BROADCAST ) )
                {
                    ( void )xMBPortEventPost( EV_EXECUTE );
                }

`&lt;/pre&gt;

在EV_READY态如果检测收到的地址跟从机地址（freemodbus的开源版本只支持从机，如果你想要主机的可以参考一下[FreeModbus_Slave-Master-RTT-STM32](https://github.com/armink/FreeModbus_Slave-Master-RTT-STM32)）匹配，或是广播地址就自己给自己投递一个EV_EXECUTE 事件。

&lt;pre&gt;`
        case EV_EXECUTE:
            ucFunctionCode = ucMBFrame[MB_PDU_FUNC_OFF];
            eException = MB_EX_ILLEGAL_FUNCTION;
            for( i = 0; i &amp;lt; MB_FUNC_HANDLERS_MAX; i++ )
            {
                /* No more function handlers registered. Abort. */
                if( xFuncHandlers[i].ucFunctionCode == 0 )
                {
                    break;
                }
                else if( xFuncHandlers[i].ucFunctionCode == ucFunctionCode )
                {
                    eException = xFuncHandlers[i].pxHandler( ucMBFrame, &amp;amp;usLength );
                    break;
                }
            }

            /* If the request was not sent to the broadcast address we
             * return a reply. */
            if( ucRcvAddress != MB_ADDRESS_BROADCAST )
            {
                if( eException != MB_EX_NONE )
                {
                    /* An exception occured. Build an error frame. */
                    usLength = 0;
                    ucMBFrame[usLength++] = ( UCHAR )( ucFunctionCode | MB_FUNC_ERROR );
                    ucMBFrame[usLength++] = eException;
                }
                if( ( eMBCurrentMode == MB_ASCII ) &amp;amp;&amp;amp; MB_ASCII_TIMEOUT_WAIT_BEFORE_SEND_MS )
                {
                    vMBPortTimersDelay( MB_ASCII_TIMEOUT_WAIT_BEFORE_SEND_MS );
                }                
                eStatus = peMBFrameSendCur( ucMBAddress, ucMBFrame, usLength );
            }
            break;

`&lt;/pre&gt;

在EV_EXECUTE的第一段就是执行相应的功能码回调，也就是读写寄存器或者是打开线圈什么的，实现上就是执行mbfunctions里面的代码，因为在协议栈初始化的时候这些文件里面的函数都被值给了xFuncHandlers[]，去看看xFuncHandlers[]的定义吧。

&lt;pre&gt;`
/* An array of Modbus functions handlers which associates Modbus function
 * codes with implementing functions.
 */
static xMBFunctionHandler xFuncHandlers[MB_FUNC_HANDLERS_MAX] = {
#if MB_FUNC_OTHER_REP_SLAVEID_ENABLED &amp;gt; 0
    {MB_FUNC_OTHER_REPORT_SLAVEID, eMBFuncReportSlaveID},
#endif
#if MB_FUNC_READ_INPUT_ENABLED &amp;gt; 0
    {MB_FUNC_READ_INPUT_REGISTER, eMBFuncReadInputRegister},
#endif
#if MB_FUNC_READ_HOLDING_ENABLED &amp;gt; 0
    {MB_FUNC_READ_HOLDING_REGISTER, eMBFuncReadHoldingRegister},
#endif
#if MB_FUNC_WRITE_MULTIPLE_HOLDING_ENABLED &amp;gt; 0
    {MB_FUNC_WRITE_MULTIPLE_REGISTERS, eMBFuncWriteMultipleHoldingRegister},
#endif
#if MB_FUNC_WRITE_HOLDING_ENABLED &amp;gt; 0
    {MB_FUNC_WRITE_REGISTER, eMBFuncWriteHoldingRegister},
#endif
#if MB_FUNC_READWRITE_HOLDING_ENABLED &amp;gt; 0
    {MB_FUNC_READWRITE_MULTIPLE_REGISTERS, eMBFuncReadWriteMultipleHoldingRegister},
#endif
#if MB_FUNC_READ_COILS_ENABLED &amp;gt; 0
    {MB_FUNC_READ_COILS, eMBFuncReadCoils},
#endif
#if MB_FUNC_WRITE_COIL_ENABLED &amp;gt; 0
    {MB_FUNC_WRITE_SINGLE_COIL, eMBFuncWriteCoil},
#endif
#if MB_FUNC_WRITE_MULTIPLE_COILS_ENABLED &amp;gt; 0
    {MB_FUNC_WRITE_MULTIPLE_COILS, eMBFuncWriteMultipleCoils},
#endif
#if MB_FUNC_READ_DISCRETE_INPUTS_ENABLED &amp;gt; 0
    {MB_FUNC_READ_DISCRETE_INPUTS, eMBFuncReadDiscreteInputs},
#endif
};

`&lt;/pre&gt;

看到这里你就明白了xFuncHandlers不过是一个功能码和功能回调函数的对应表，eMBFuncWriteHoldingRegister（）就是写保持寄存器回调。我们还是接着看EV_EXECUTE，第一段里面需要注意`if( xFuncHandlers[i].ucFunctionCode == 0 )`这一句是用来在结束遍历表, freemodbus提供了一个eMBRegisterCB（）eMBRegisterCB函数专门用来注册功能码和与之相应的回调，但是对于不响应的功能码freemodbus通过`xFuncHandlers[i].ucFunctionCode = 0;`将其直接置0。

EV_EXECUTE第二段就是对主机作出回应。讲到这里接收处理就讲完了。在mb.c中我们可以看到这一层并不对EV_FRAME_SENT作处理。

#### mbrtu.c分析

在mb.c里面我们留了一个疑惑，是谁在投递事件？或者说是谁在改变mb.c里面状态机的状态？

如果是RTU模式，那么就是这mbrtu.c里面的这个函数了

&lt;pre&gt;`
BOOL
xMBRTUTimerT35Expired( void )
{
    BOOL            xNeedPoll = FALSE;

    switch ( eRcvState )
    {
        /* Timer t35 expired. Startup phase is finished. */
    case STATE_RX_INIT:
        xNeedPoll = xMBPortEventPost( EV_READY );
        break;

        /* A frame was received and t35 expired. Notify the listener that
         * a new frame was received. */
    case STATE_RX_RCV:
        xNeedPoll = xMBPortEventPost( EV_FRAME_RECEIVED );
        break;

        /* An error occured while receiving the frame. */
    case STATE_RX_ERROR:
        break;

        /* Function called in an illegal state. */
    default:
        assert( ( eRcvState == STATE_RX_INIT ) ||
                ( eRcvState == STATE_RX_RCV ) || ( eRcvState == STATE_RX_ERROR ) );
    }

    vMBPortTimersDisable(  );
    eRcvState = STATE_RX_IDLE;

    return xNeedPoll;
}

`&lt;/pre&gt;

这个函数是被vMBPortTimerPoll（）被调用的，vMBPortTimerPoll（）又是被xMBPortEventGet（）调用的，这里我们看一下vMBPortTimerPoll（）是在什么情况下调用xMBRTUTimerT35Expired：

&lt;pre&gt;`
void
    vMBPortTimerPoll(  )
{

    /* Timers are called from the serial layer because we have no high
    * res timer in Win32\. */
    if( bTimeoutEnable )
    {
        DWORD           dwTimeCurrent = GetTickCount(  );

        if( ( dwTimeCurrent - dwTimeLast ) &amp;gt; dwTimeOut )
        {
            bTimeoutEnable = FALSE;
            ( void )pxMBPortCBTimerExpired(  );
        }
    }
}

`&lt;/pre&gt;

可以看到就当系统的tickCount间隔达到一定时间时就调用xMBRTUTimerT35Expired（）（pxMBPortCBTimerExpired在eMBInit()中被赋值为xMBRTUTimerT35Expired），简单点说吧，就相当于单片机定时器中断函数，定时执行xMBRTUTimerT35Expired()函数。

回到mbrtu.c中来吧，跟踪的第一要点是不能迷路，方向感要好！

xMBRTUTimerT35Expired就是根据eRcvState的不同状态来投递不同的事件给mb.c中的eMBPoll（）这个状态机。而eRcvState又是怎么来的呢？在xMBRTUReceiveFSM（）中我们看到了它。

&lt;pre&gt;`
BOOL
xMBRTUReceiveFSM( void )
{
    BOOL            xTaskNeedSwitch = FALSE;
    UCHAR           ucByte;

    assert( eSndState == STATE_TX_IDLE );

    /* Always read the character. */
    ( void )xMBPortSerialGetByte( ( CHAR * ) &amp;amp; ucByte );

    switch ( eRcvState )
    {
        /* If we have received a character in the init state we have to
         * wait until the frame is finished.
         */
    case STATE_RX_INIT:
        vMBPortTimersEnable(  );
        break;

        /* In the error state we wait until all characters in the
         * damaged frame are transmitted.
         */
    case STATE_RX_ERROR:
        vMBPortTimersEnable(  );
        break;

        /* In the idle state we wait for a new character. If a character
         * is received the t1.5 and t3.5 timers are started and the
         * receiver is in the state STATE_RX_RECEIVCE.
         */
    case STATE_RX_IDLE:
        usRcvBufferPos = 0;
        ucRTUBuf[usRcvBufferPos++] = ucByte;
        eRcvState = STATE_RX_RCV;

        /* Enable t3.5 timers. */
        vMBPortTimersEnable(  );
        break;

        /* We are currently receiving a frame. Reset the timer after
         * every character received. If more than the maximum possible
         * number of bytes in a modbus frame is received the frame is
         * ignored.
         */
    case STATE_RX_RCV:
        if( usRcvBufferPos &amp;lt; MB_SER_PDU_SIZE_MAX )
        {
            ucRTUBuf[usRcvBufferPos++] = ucByte;
        }
        else
        {
            eRcvState = STATE_RX_ERROR;
        }
        vMBPortTimersEnable(  );
        break;
    }
    return xTaskNeedSwitch;
}

`&lt;/pre&gt;

这里不兜圈子，直接告诉你xMBRTUReceiveFSM会在串口接收函数中被调用（虽然在这个WIN32例程中并没有中断例程）。我们这里主要分析一下xMBRTUReceiveFSM的流程。

首先xMBRTUReceiveFSM会进入STATE_RX_INIT态，这个时候它调用vMBPortTimersEnable开启定时器，当达到3.5T时间后xMBRTUTimerT35Expired会让  eRcvState = STATE_RX_IDLE，这样xMBRTUReceiveFSM会进入STATE_RX_IDLE态，在STATE_RX_IDLE态一旦通过xMBPortSerialGetByte收到了一个字符，那么就会 进入STATE_RX_RCV态，在这里就是持续的接收字符同时进行两种检测，一种是如果接收的字符超过了MB_SER_PDU_SIZE_MAX（RTU帧的最大值）就会进入STATE_RX_ERROR态，另一种就是检测是否超时，vMBPortTimersEnable(  )就是用来清零定时器的。如果超时则会由xMBRTUTimerT35Expired向mb.c状态机投递一个EV_FRAME_RECEIVED帧结束事件，这个时候帧数据就会被交给mb.c中的状态机去处理。在xMBRTUTimerT35Expired退出前会再次将xMBRTUReceiveFSM的状态置为STATE_RX_IDLE空闲态。

至此从上到下整个接收流程都理清楚了。那么我再看一看发送流程吧，这个比较轻松。

&lt;pre&gt;`
BOOL
xMBRTUTransmitFSM( void )
{
    BOOL            xNeedPoll = FALSE;

    assert( eRcvState == STATE_RX_IDLE );

    switch ( eSndState )
    {
        /* We should not get a transmitter event if the transmitter is in
         * idle state.  */
    case STATE_TX_IDLE:
        /* enable receiver/disable transmitter. */
        vMBPortSerialEnable( TRUE, FALSE );
        break;

    case STATE_TX_XMIT:
        /* check if we are finished. */
        if( usSndBufferCount != 0 )
        {
            xMBPortSerialPutByte( ( CHAR )*pucSndBufferCur );
            pucSndBufferCur++;  /* next byte in sendbuffer. */
            usSndBufferCount--;
        }
        else
        {
            xNeedPoll = xMBPortEventPost( EV_FRAME_SENT );
            /* Disable transmitter. This prevents another transmit buffer
             * empty interrupt. */
            vMBPortSerialEnable( TRUE, FALSE );
            eSndState = STATE_TX_IDLE;
        }
        break;
    }

    return xNeedPoll;
}

`&lt;/pre&gt;

xMBRTUTransmitFSM在eMBInit（）中被赋值给了pxMBFrameCBTransmitterEmpty，而pxMBFrameCBTransmitterEmpty又被xMBPortSerialPoll调用，最后xMBPortSerialPoll被xMBPortEventGet中被调用。

xMBRTUTransmitFSM只有两个状态。

&lt;pre&gt;`
typedef enum
{
    STATE_TX_IDLE,              /*!&amp;lt; Transmitter is in idle state. */
    STATE_TX_XMIT               /*!&amp;lt; Transmitter is in transfer state. */
} eMBSndState;

`&lt;/pre&gt;

在没有发送任务的时候，它是处理STATE_TX_IDLE态，在modbus协议栈初始化的时候它就是这个态，而这个STATE_TX_XMIT发送态则是用来将要发送的数据推送到发送缓冲的（这里你可以用你的串口中断来做，但我觉得用DMA会更好一些），发送完数据后又返回到STATE_TX_IDLE态，但是STATE_TX_XMIT是谁让它进入的呢？

&lt;pre&gt;`
eMBErrorCode
eMBRTUSend( UCHAR ucSlaveAddress, const UCHAR * pucFrame, USHORT usLength )
{
    eMBErrorCode    eStatus = MB_ENOERR;
    USHORT          usCRC16;

    ENTER_CRITICAL_SECTION(  );

    /* Check if the receiver is still in idle state. If not we where to
     * slow with processing the received frame and the master sent another
     * frame on the network. We have to abort sending the frame.
     */
    if( eRcvState == STATE_RX_IDLE )
    {
        /* First byte before the Modbus-PDU is the slave address. */
        pucSndBufferCur = ( UCHAR * ) pucFrame - 1;
        usSndBufferCount = 1;

        /* Now copy the Modbus-PDU into the Modbus-Serial-Line-PDU. */
        pucSndBufferCur[MB_SER_PDU_ADDR_OFF] = ucSlaveAddress;
        usSndBufferCount += usLength;

        /* Calculate CRC16 checksum for Modbus-Serial-Line-PDU. */
        usCRC16 = usMBCRC16( ( UCHAR * ) pucSndBufferCur, usSndBufferCount );
        ucRTUBuf[usSndBufferCount++] = ( UCHAR )( usCRC16 &amp;amp; 0xFF );
        ucRTUBuf[usSndBufferCount++] = ( UCHAR )( usCRC16 &amp;gt;&amp;gt; 8 );

        /* Activate the transmitter. */
        eSndState = STATE_TX_XMIT;
        vMBPortSerialEnable( FALSE, TRUE );
    }
    else
    {
        eStatus = MB_EIO;
    }
    EXIT_CRITICAL_SECTION(  );
    return eStatus;
}

`&lt;/pre&gt;

这个eMBRTUSend就是用来将xMBRTUTransmitFSM置为STATE_TX_XMIT的函数，同时它还使能串口发送功能。eMBRTUSend本身却是在eMBPoll（）的EV_EXECUTE状态的第二段被调用的，就是当收到功能码时我们回应给主机的这一部分。

&lt;pre&gt;`
            /* If the request was not sent to the broadcast address we
             * return a reply. */
            if( ucRcvAddress != MB_ADDRESS_BROADCAST )
            {
                if( eException != MB_EX_NONE )
                {
                    /* An exception occured. Build an error frame. */
                    usLength = 0;
                    ucMBFrame[usLength++] = ( UCHAR )( ucFunctionCode | MB_FUNC_ERROR );
                    ucMBFrame[usLength++] = eException;
                }
                if( ( eMBCurrentMode == MB_ASCII ) &amp;amp;&amp;amp; MB_ASCII_TIMEOUT_WAIT_BEFORE_SEND_MS )
                {
                    vMBPortTimersDelay( MB_ASCII_TIMEOUT_WAIT_BEFORE_SEND_MS );
                }                
                eStatus = peMBFrameSendCur( ucMBAddress, ucMBFrame, usLength );
            }
            break;

`&lt;/pre&gt;

其中的peMBFrameSendCur（）就是eMBRTUSend（），在eMBInit我们将eMBRTUSend赋值给了peMBFrameSendCur（）。 现在咱们终于绕出来了，发送流程也介绍清楚了。

写到这里，我估计你可能会有一些疑惑，在这个例程中真正完成发送和接收串口的代码在哪里？

&lt;pre&gt;`
BOOL
xMBPortEventGet( eMBEventType * eEvent )
{
    BOOL            xEventHappened = FALSE;

    if( xEventInQueue )
    {
        *eEvent = eQueuedEvent;
        xEventInQueue = FALSE;
        xEventHappened = TRUE;
    }
    else
    {        
        /* Poll the serial device. The serial device timeouts if no
         * characters have been received within for t3.5 during an
         * active transmission or if nothing happens within a specified
         * amount of time. Both timeouts are configured from the timer
         * init functions.
         */
        ( void )xMBPortSerialPoll(  );  

        /* Check if any of the timers have expired. */
        vMBPortTimerPoll(  );

    }
    return xEventHappened;
}

`&lt;/pre&gt;

其实它们就在xMBPortSerialPoll里，换句话说，每次当mb.c的状态机调用xMBPortEventGet（）都在进行串口操作，要么是发送要么是接收。

&lt;pre&gt;`
BOOL
xMBPortSerialPoll(  )
{
    BOOL            bStatus = TRUE;
    DWORD           dwBytesRead;
    DWORD           dwBytesWritten;
    DWORD           i;

    while( bRxEnabled )
    {
        /* buffer wrap around. */
        if( uiRxBufferPos &amp;gt;= BUF_SIZE )
            uiRxBufferPos = 0;

        if( ReadFile( g_hSerial, &amp;amp;ucBuffer[uiRxBufferPos],
                      BUF_SIZE - uiRxBufferPos, &amp;amp;dwBytesRead, NULL ) )
        {
            if( dwBytesRead == 0 )
            {
                /* timeout with no bytes. */
                break;
            }
            else if( dwBytesRead &amp;gt; 0 )
            {
                vMBPortLog( MB_LOG_DEBUG, _T( &quot;SER-POLL&quot; ),
                            _T( &quot;detected end of frame (t3.5 expired.)\r\n&quot; ) );
                for( i = 0; i &amp;lt; dwBytesRead; i++ )
                {
                    /* Call the modbus stack and let him fill the buffers. */
                    ( void )pxMBFrameCBByteReceived(  );
                }
            }
        }
        else
        {
            vMBPortLog( MB_LOG_ERROR, _T( &quot;SER-POLL&quot; ), _T( &quot;I/O error on serial device: %s&quot; ),
                        Error2String( GetLastError ( ) ) );
            bStatus = FALSE;
        }
    }
    if( bTxEnabled )
    {
        while( bTxEnabled )
        {
            ( void )pxMBFrameCBTransmitterEmpty(  );
            /* Call the modbus stack to let him fill the buffer. */
        }
        dwBytesWritten = 0;
        if( !WriteFile
            ( g_hSerial, &amp;amp;ucBuffer[0], uiTxBufferPos, &amp;amp;dwBytesWritten, NULL )
            || ( dwBytesWritten != uiTxBufferPos ) )
        {
            vMBPortLog( MB_LOG_ERROR, _T( &quot;SER-POLL&quot; ), _T( &quot;I/O error on serial device: %s&quot; ),
                        Error2String( GetLastError ( ) ) );
            bStatus = FALSE;
        }
    }

    return bStatus;
}

`&lt;/pre&gt;

xMBPortSerialPoll依据bRxEnabled 和 bTxEnabled 来区分到底是发送还是接收。

**我看到有些人说freemodbus只能通过阻塞方式发送和接收串口数据很显然是错误的，它可以用普通串口中断或者是串口DMA来做。**

写第一版的时候忘了分析一下事件队列，虽然说是叫事件队列，其实就是很简单的对一个变量进行了封装,提供了抽象接口，代码也只有这么几行：

&lt;pre&gt;`
/* ----------------------- Variables ----------------------------------------*/
static eMBEventType eQueuedEvent;
static BOOL     xEventInQueue;

/* ----------------------- Start implementation -----------------------------*/
BOOL
xMBPortEventInit( void )
{
    xEventInQueue = FALSE;
    return TRUE;
}

BOOL
xMBPortEventPost( eMBEventType eEvent )
{
    xEventInQueue = TRUE;
    eQueuedEvent = eEvent;
    return TRUE;
}

BOOL
xMBPortEventGet( eMBEventType * eEvent )
{
    BOOL            xEventHappened = FALSE;

    if( xEventInQueue )
    {
        *eEvent = eQueuedEvent;
        xEventInQueue = FALSE;
        xEventHappened = TRUE;
    }
    else
    {        
        /* Poll the serial device. The serial device timeouts if no
         * characters have been received within for t3.5 during an
         * active transmission or if nothing happens within a specified
         * amount of time. Both timeouts are configured from the timer
         * init functions.
         */
        ( void )xMBPortSerialPoll(  );  

        /* Check if any of the timers have expired. */
        vMBPortTimerPoll(  );

    }
    return xEventHappened;
}

`&lt;/pre&gt;

xMBPortEventPost这个投递事件的函数只是将事件枚举赋值给这个模块的变量，同时将xEventInQueue置为真表示队列中有数据，xMBPortEventGet的逻辑稍微复杂一点，它会在eMBPoll状态机中被反复调用，它首先将xEventInQueue置为FALSE，然后如果队列中有数据将就队列中的数字赋给eMBPoll传入的指针，没有事件的话就进行一下串口的接收和发送处理。

**注意**：freemodbus并没有用到T1.5（同一帧内两个字符之间的最大时间间隔）检测，你可以去看源代码里面xMBRTUTimerT15Expired这个函数仅仅只是声明了，我个人猜测是因为T1.5这个时间粒度太小（波特率为19200，按协议t1.5取为750us），一般的MCU根本没精力去做这个检测。

* * *

最后提一下asc模式，在eMBInit()函数中我们看到如果你的初时化时候的选择MB_ASCII作为参数，与modbus协议相关的回调和状态都会被替换成maasiic中的内容，顺着这条藤去摸一下ASC模式的瓜应该不难。

&lt;pre&gt;`
#if MB_RTU_ENABLED &amp;gt; 0
        case MB_RTU:
            pvMBFrameStartCur = eMBRTUStart;
            pvMBFrameStopCur = eMBRTUStop;
            peMBFrameSendCur = eMBRTUSend;
            peMBFrameReceiveCur = eMBRTUReceive;
            pvMBFrameCloseCur = MB_PORT_HAS_CLOSE ? vMBPortClose : NULL;
            pxMBFrameCBByteReceived = xMBRTUReceiveFSM;
            pxMBFrameCBTransmitterEmpty = xMBRTUTransmitFSM;
            pxMBPortCBTimerExpired = xMBRTUTimerT35Expired;

            eStatus = eMBRTUInit( ucMBAddress, ucPort, ulBaudRate, eParity );
            break;
#endif
#if MB_ASCII_ENABLED &amp;gt; 0
        case MB_ASCII:
            pvMBFrameStartCur = eMBASCIIStart;
            pvMBFrameStopCur = eMBASCIIStop;
            peMBFrameSendCur = eMBASCIISend;
            peMBFrameReceiveCur = eMBASCIIReceive;
            pvMBFrameCloseCur = MB_PORT_HAS_CLOSE ? vMBPortClose : NULL;
            pxMBFrameCBByteReceived = xMBASCIIReceiveFSM;
            pxMBFrameCBTransmitterEmpty = xMBASCIITransmitFSM;
            pxMBPortCBTimerExpired = xMBASCIITimerT1SExpired;

            eStatus = eMBASCIIInit( ucMBAddress, ucPort, ulBaudRate, eParity );
            break;
#endif
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我这里为了方便代码浏览，用了VS2013，DEMO自然用WIN32的，选用哪个DEMO进行分析也并不影响我们对FREEMODBUS的解剖。&lt;/p&gt;
&lt;h3 id=&quot;代码组织结构&quot;&gt;&lt;a href=&quot;#代码组织结构&quot; class=&quot;headerlink&quot; title=&quot;代码组
    
    </summary>
    
      <category term="MCU/ARM" scheme="http://hex55.com/categories/MCU-ARM/"/>
    
    
  </entry>
  
  <entry>
    <title>freemodbus RTU/ASCII 官方移植文档</title>
    <link href="http://hex55.com/2016/01/05/freemodbus-rtuascii-e5-ae-98-e6-96-b9-e7-a7-bb-e6-a4-8d-e6-96-87-e6-a1-a3/"/>
    <id>http://hex55.com/2016/01/05/freemodbus-rtuascii-e5-ae-98-e6-96-b9-e7-a7-bb-e6-a4-8d-e6-96-87-e6-a1-a3/</id>
    <published>2016-01-05T13:12:40.000Z</published>
    <updated>2016-07-19T00:29:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/uploads/2016/01/freeModbus.jpg"><img src="/uploads/2016/01/freeModbus-300x167.jpg" alt="freeModbus"></a></p>
<p>原文：<a href="http://www.freemodbus.org/api/index.html" target="_blank" rel="external">Porting for RTU/ASCII</a></p>
<p>第一步你应该先创建一个移植目录，例如创建一个demo/PLATFORM的目录，里面包含应用程序和工程文件，然后再创建一个子目录专门用来放置移植相关文件。</p>
<blockquote>
<p>demo/PLATFORM/Makefile<br>  demo/PLATFORM/main.c<br>  demo/PLATFORM/port/portserial.c<br>  demo/PLATFORM/port/porttimer.c<br>  demo/PLATFORM/port/portother.c<br>  demo/PLATFORM/port/port.h</p>
</blockquote>
<p>你也可以将demo/BARE作为开始，复制它然后重命名它。</p>
<h3 id="移植约定（port-h）"><a href="#移植约定（port-h）" class="headerlink" title="移植约定（port.h）"></a>移植约定（port.h）</h3><p>首先看一下port.h文件，看看是不是已经有了适合你的平台的例子。你至少应该定义一下使能中断ENTER_CRITICAL_SECTION和禁能中断EXIT_CRITICAL_SECTION的宏。</p>
<h3 id="实现定时函器函数（porttimer-c）"><a href="#实现定时函器函数（porttimer-c）" class="headerlink" title="实现定时函器函数（porttimer.c）"></a>实现定时函器函数（porttimer.c）</h3><p>Modbus协议栈需要一个定时器用于检测帧结束。定时器的分辨率必须是串口参数的一半。举个例子，假定波特率是38400一个11bit字符那么大概是280us，。这样对于协议栈来说最小的超时时间是3.5倍的单个字符传输时间。</p>
<p>从实现xMBPortTimersInit( USHORT usTim1Timerout50us )和 vMBPortTimersEnable( )开始。可以用下面的代码进行测试</p>
<pre><code>xMBPortTimersInit( 20 );
vMBPortTimersEnable( );
for( ;; );

`&lt;/pre&gt;

在中断处理函数中下一个断点或者每次调用pxMBPortCBTimerExpired时闪烁一下LED，在调用vMBPortTimersEnable()一个毫秒后中断服务将会触发。你也要检查一下 vMBPortTimersDisable( )是否按预期工作。

**注意**：

_如果你用ASCII模式的Modbus，定时计的范围是以秒计的，因为那里的超时非常大。确保你的usTim1Timerout50us能处理输入值为2000的情况，超时为1秒时。参见mbconfig.h中MB_ASCII_TIMEOUT_SEC的定义。_

### 移植RTU/ASCII模式。

串口移植层必须初始化串口，禁能或者使能接收器和发送器，以及在接收或者发送一个字符的时候回调函数能够执行。通过实现xMBPortSerialInit( UCHAR ucPORT, ULONG ulBaudRate, UCHAR ucDataBits, eMBParity eParity ) 和 vMBPortSerialEnable( BOOL xRxEnable, BOOL xTxEnable )开始。另外你还需要为你的通讯器件创建两个中断服务函数。从接收中断开始将会非常简单。

创建一个接收中断处理函数，设置一个断点用来检查xMBPortSerialGetByte( CHAR * pucByte )是否能正确地返回一个字符。能通过以下的代码进行测试。

&lt;pre&gt;`
/* Initialize COM device 0 with 38400 baud, 8 data bits and no parity. */
if( xMBPortSerialInit( 0, 38400, 8, MB_PAR_NONE ) == FALSE )
{
  fprintf(stderr, &quot;error: com init failed&quot;);
}
else
{
  /* Enable the receiver. */ 
  vMBPortSerialEnable( TRUE, FALSE );
  /* Now block. Any character received should cause an interrupt now. */
  for( ;; );
}

`&lt;/pre&gt;

你的串口接收中断函数看起来应该是这样子的：

&lt;pre&gt;`
static void prvvUARTTxReadyISR( void )
{
    CHAR cByte;
    ( void )xMBPortSerialGetByte( &amp;amp;cByte );
    /* Now cByte should contain the character received. */
}

`&lt;/pre&gt;

下一步你应该测试一下发送部分是否如预期的那样正常工作。打开一终端程序，然后在空的发送中断函数中简单地调用一下 xMBPortSerialPutByte( &apos;a&apos; ) 。如果你用下面这个简单代码来测试应该准确地收到10个字符。

&lt;pre&gt;`
/* Initialize COM device 0 with 38400 baud, 8 data bits and no parity. */
if( xMBPortSerialInit( 0, 38400, 8, MB_PAR_NONE ) == FALSE )
{
  fprintf(stderr, &quot;error: com init failed&quot;);
}
else
{
  /* Enable the transmitter. */ 
  vMBPortSerialEnable( FALSE, TRUE );
  /* Now block. Any character received should cause an interrupt now. */
  for( ;; );
}

`&lt;/pre&gt;

你的发送中断函数看起来应该是这样子的：

&lt;pre&gt;`
static unsigned int uiCnt = 0;

void prvvUARTTxReadyISR( void )
{
    if( uiCnt++ &amp;lt; 10 )
    {
        ( void )xMBPortSerialPutByte( &apos;a&apos; );
    }
    else
    {
        vMBPortSerialEnable( FALSE, FALSE );
    }
}

`&lt;/pre&gt;

如果你确定上面的都正常工作了，那么改一下portserial.c的中断函数。

### 实现事件队列(portevent.c)

如果你没有用操作系统那么移植到此就结束了，并且例程会如预期地正常工作。如果你刚好要在一个操作系统中用FreeModbus作为协议本，那么方法有些不同：
</code></pre><ul>
<li><p>在启动的时候创建另一个任务循环调用eMBPoll()。像这样：</p>
<p><pre>`<br>If you in the luck of having an operating system usage of the FreeModbus protocol stack differs in the following way</pre></p>
</li>
<li><p>修改用于向队列中投递事件的xMBPortEventPost函数。注意这个函数会在中断服务函数里面被调用，因此看看你的RTOS文档。</p><p></p>
</li>
<li>修改用于从队列中接收事件的xMBPortEventGet函数。eMBPoll将会周期性地调用这个函数。这个函数将会是阻塞的直到队列中已被投递了一个事件。</li>
</ul>
<p></p><p>另外对串口和定时器中断函数进行修正。每当协议处理回调pxMBFrameCBByteReceived, pxMBFrameCBTransmitterEmpty 和 pxMBPortCBTimerExpired 返回TRUE 时应该在退出ISR后进行一次上下文切换，因为一个事件已经被投递到队列中。如果忘记了做这一步，将会导致协议本的性能低下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/uploads/2016/01/freeModbus.jpg&quot;&gt;&lt;img src=&quot;/uploads/2016/01/freeModbus-300x167.jpg&quot; alt=&quot;freeModbus&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文：&lt;a href=&quot;htt
    
    </summary>
    
      <category term="MCU/ARM" scheme="http://hex55.com/categories/MCU-ARM/"/>
    
    
  </entry>
  
  <entry>
    <title>chipscope 连接platform cable usb JTAG失败原因及解决办法</title>
    <link href="http://hex55.com/2016/01/02/chipscope-e8-bf-9e-e6-8e-a5platform-cable-usb-jtag-e5-a4-b1-e8-b4-a5-e5-8e-9f-e5-9b-a0-e5-8f-8a-e8-a7-a3-e5-86-b3-e5-8a-9e-e6-b3-95/"/>
    <id>http://hex55.com/2016/01/02/chipscope-e8-bf-9e-e6-8e-a5platform-cable-usb-jtag-e5-a4-b1-e8-b4-a5-e5-8e-9f-e5-9b-a0-e5-8f-8a-e8-a7-a3-e5-86-b3-e5-8a-9e-e6-b3-95/</id>
    <published>2016-01-02T04:11:14.000Z</published>
    <updated>2016-07-19T00:29:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>报以下错误：</p>
<blockquote>
<p>Number of bytes peeked does not match number of bytes requested.  Corrupted file?</p>
</blockquote>
<p>经搜索找到<a href="http://www.xilinx.com/support/answers/32912.html，得知原因是由系统的UAC导致（VISTA以上系统出于安全考虑默认都有这个玩意，就是你双击一个EXE的时候会先弹出一个对话框问你是否确认运行，如果你装的是原版一般都是默认开启的，如果是其它一些修改版本这个功能可能被删掉了）。既然找到原因，那就好办了。" target="_blank" rel="external">http://www.xilinx.com/support/answers/32912.html，得知原因是由系统的UAC导致（VISTA以上系统出于安全考虑默认都有这个玩意，就是你双击一个EXE的时候会先弹出一个对话框问你是否确认运行，如果你装的是原版一般都是默认开启的，如果是其它一些修改版本这个功能可能被删掉了）。既然找到原因，那就好办了。</a></p>
<p>找到chipsope所成的位置，通常在ISE按装目录下的</p>
<p><a href="/uploads/2016/01/2016-01-02_134030.png"><img src="/uploads/2016/01/2016-01-02_134030-300x177.png" alt="2016-01-02_134030"></a></p>
<p>然后右键</p>
<p><a href="/uploads/2016/01/2016-01-02_133428.png"><img src="/uploads/2016/01/2016-01-02_133428-260x300.png" alt="2016-01-02_133428"></a></p>
<p>勾上以管理员权限运行此程序。</p>
<p>或者关闭UAC，<a href="http://technet2.microsoft.com/WindowsVista/en/library/0d75f774-8514-4c9e-ac08-4c21f5c6c2d91033.mspx?mfr=true。" target="_blank" rel="external">http://technet2.microsoft.com/WindowsVista/en/library/0d75f774-8514-4c9e-ac08-4c21f5c6c2d91033.mspx?mfr=true。</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;报以下错误：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Number of bytes peeked does not match number of bytes requested.  Corrupted file?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经搜索找到&lt;a
    
    </summary>
    
      <category term="FPGA" scheme="http://hex55.com/categories/FPGA/"/>
    
    
  </entry>
  
  <entry>
    <title>altium-designer自动添加成片的拼接孔（缝合孔）</title>
    <link href="http://hex55.com/2015/12/24/altium-designer-e8-87-aa-e5-8a-a8-e6-b7-bb-e5-8a-a0-e6-88-90-e7-89-87-e7-9a-84-e6-8b-bc-e6-8e-a5-e5-ad-94-ef-bc-88-e7-bc-9d-e5-90-88-e5-ad-94-ef-bc-89/"/>
    <id>http://hex55.com/2015/12/24/altium-designer-e8-87-aa-e5-8a-a8-e6-b7-bb-e5-8a-a0-e6-88-90-e7-89-87-e7-9a-84-e6-8b-bc-e6-8e-a5-e5-ad-94-ef-bc-88-e7-bc-9d-e5-90-88-e5-ad-94-ef-bc-89/</id>
    <published>2015-12-24T13:26:48.000Z</published>
    <updated>2016-07-19T00:29:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>通常为了降低对地阻抗(当然也可以是针对其它非地网络)，我们会在板子上空闲的地方打上连接过孔（Via Stitching）。</p>
<p><a href="/uploads/2015/12/Via-Stitching.png"><img src="/uploads/2015/12/Via-Stitching-300x195.png" alt="Via Stitching"></a></p>
<p>之前都是手动粘贴复制，在edit菜单下选择特殊粘贴</p>
<p><a href="/uploads/2015/12/2015-12-24_172817.png"><img src="/uploads/2015/12/2015-12-24_172817.png" alt="2015-12-24_172817"></a></p>
<p>勾上保持网络名复选框</p>
<p><a href="/uploads/2015/12/2015-12-24_172826.png"><img src="/uploads/2015/12/2015-12-24_172826.png" alt="2015-12-24_172826"></a></p>
<p>然后选择组粘贴，设置好粘贴数量和坐标增长方式（也即间距）</p>
<p><a href="/uploads/2015/12/2015-12-24_172833.png"><img src="/uploads/2015/12/2015-12-24_172833-300x200.png" alt="2015-12-24_172833"></a></p>
<p>现在不用了，可以直接采用Tools » Via Stitching » Add Stitch Net命令来完成。</p>
<p><a href="/uploads/2015/12/2015-12-24_211133.png"><img src="/uploads/2015/12/2015-12-24_211133-300x235.png" alt="2015-12-24_211133"></a></p>
<p>左边的属性分别是区域设置，当选上constrain area区域约束后就会出现十字光标让你选取要打孔的区域。左下面分别是过孔间距、过孔或焊盘安全距离，距板边的安全距离等。左边则是先取过孔相关参数。如果你不勾选constrain area复选框，则会自动在整块板子上打缝合孔。</p>
<p><strong>注意，打孔之前必须是板子先覆实铜，不覆铜或覆网络都会显示不能找到打孔的可适区域</strong></p>
<p>在选完区域后点鼠标右键则会再次回到上面的属性界面框，此时constrain area复选框已打上勾。点击OK后就会自动运行打孔了，效果如下：</p>
<p><a href="/uploads/2015/12/2015-12-24_212632.png"><img src="/uploads/2015/12/2015-12-24_212632-300x238.png" alt="2015-12-24_212632"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通常为了降低对地阻抗(当然也可以是针对其它非地网络)，我们会在板子上空闲的地方打上连接过孔（Via Stitching）。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/uploads/2015/12/Via-Stitching.png&quot;&gt;&lt;img src=&quot;/uploads/2015
    
    </summary>
    
      <category term="硬件设计" scheme="http://hex55.com/categories/%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>高速高精度测径仪主板第二版完工</title>
    <link href="http://hex55.com/2015/12/22/e9-ab-98-e9-80-9f-e9-ab-98-e7-b2-be-e5-ba-a6-e6-b5-8b-e5-be-84-e4-bb-aa-e4-b8-bb-e6-9d-bf-e7-ac-ac-e4-ba-8c-e7-89-88-e5-ae-8c-e5-b7-a5/"/>
    <id>http://hex55.com/2015/12/22/e9-ab-98-e9-80-9f-e9-ab-98-e7-b2-be-e5-ba-a6-e6-b5-8b-e5-be-84-e4-bb-aa-e4-b8-bb-e6-9d-bf-e7-ac-ac-e4-ba-8c-e7-89-88-e5-ae-8c-e5-b7-a5/</id>
    <published>2015-12-22T14:55:05.000Z</published>
    <updated>2016-07-19T00:29:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉11点了，打完收工，好好休息。</p>
<p><a href="/uploads/2015/12/2015-12-29_104721.png"><img src="/uploads/2015/12/2015-12-29_104721-300x225.png" alt="高速高精度直径测量仪主板"></a></p>
<p><a href="/uploads/2015/12/高速高精度直径测量仪主板.png"><img src="/uploads/2015/12/高速高精度直径测量仪主板-300x225.png" alt="高速高精度直径测量仪主板"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知不觉11点了，打完收工，好好休息。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/uploads/2015/12/2015-12-29_104721.png&quot;&gt;&lt;img src=&quot;/uploads/2015/12/2015-12-29_104721-300x225.png&quot; alt
    
    </summary>
    
      <category term="硬件设计" scheme="http://hex55.com/categories/%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
</feed>
